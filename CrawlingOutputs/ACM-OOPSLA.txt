1225
CommonLoops: merging Lisp and object-oriented programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
<italic>CommonLoops blends object-oriented programming smoothly and tightly with the procedure-oriented design of Lisp. Functions and methods are combined in a more general abstraction. Message passing is invoked via normal Lisp function call. Methods are viewed as partial descriptions of procedures. Lisp data types are integrated with object classes. With these integrations, it is easy to incrementally move a program between the procedure and object-oriented styles.</italic><italic>One of the most important properties of CommonLoops is its extensive use of meta-objects. We discuss three kinds of meta-objects: objects for classes, objects for methods, and objects for discriminators. We argue that these meta-objects make practical both efficient implementation and experimentation with new ideas for object-oriented programming.</italic><italic>CommonLoops' small kernel is powerful enough to implement the major object-oriented systems in use today.</italic>
[Language types, Software notations and tools, Very large scale integration design, Interval arithmetic, Theory of computation, Numerical analysis, Mathematical analysis, General programming languages, Hardware, Mathematics of computing, Design and analysis of algorithms, Arbitrary-precision arithmetic, Software and its engineering]
Mentat: An object-oriented macro data flow system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Mentat is an object-oriented macro data flow system designed to facilitate parallelism in distributed systems. Its underlying model of computation is the macro data flow model. The Macro data flow model is similar to the traditional, large grain data flow model with two differences: (1) Some macro actors are persistent actors that maintain state information between firings; (2) Program graphs are dynamic. Macro data flow programs are represented by dynamic structures called future lists that may be constructed and modified at run time. This paper discusses the motivation of the macro data flow model; the relationship between objects, actors, and tokens; the use of future lists; extensions to the programming language C++ for writing macro data flow programs; and the structure of a virtual macro data flow machine for executing macro data flow programs.
[Macro languages, Assembly languages, Data flow architectures, Context specific languages, Language types, Software notations and tools, Runtime environments, Distributed systems organizing principles, Theory of computation, Models of computation, Computer systems organization, Software system structures, General programming languages, Other architectures, Logic, Software organization and properties, Architectures, Software and its engineering, Compilers]
Tenuring policies for generation-based storage reclamation
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
One of the most promising automatic storage reclamation techniques, generation-based storage reclamation, suffers poor performance if many objects live for a fairly long time and then die. We have investigated the severity of this problem by simulating Generation Scavenging automatic storage reclamation from traces of actual four-hour sessions. There was a wide variation in the sample runs, with garbage-collection overhead ranging from insignificant, during the interactive runs, to severe, during a single non-interactive run. All runs demonstrated that performance could be improved with two techniques: segregating large bitmaps and strings, and mediating tenuring with demographic feedback. These two improvements deserve consideration for any generation-based storage reclamation strategy.
[File systems management, Information storage systems, Operating systems, Storage management, Memory management, Software notations and tools, Contextual software domains, Development frameworks and environments, Software organization and properties, Information systems, Software and its engineering]
Design of the opportunistic garbage collector
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
The Opportunistic Garbage Collector (OGC) is a generational garbage collector for stock hardware and operating systems. While incorporating important features of previous systems, the OGC includes several innovations. A new <italic>bucket brigade</italic> heap organization supports advancement thresholds between one and two scavenges, using only two or three spaces per generation, and without requiring per-object counts. <italic>Opportunistic</italic> scavenging decouples scavenging from the filling of available memory, in order to hide potentially disruptive scavenge pauses and improve efficiency. <italic>Card marking</italic> efficiently records which small areas of the heap may contain pointers into younger generations, and is supported by a refinement of the <italic>crossing map</italic> technique, to enable scanning of arbitrary cards.
[Software creation and management, Operating systems, Memory management, Allocation / deallocation strategies, Software notations and tools, Software development techniques, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Portia: an instance-centered environment for Smalltalk
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
LO and behold! Concurrent structured processes
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
<italic>We introduce a novel concurrent logic programming language, which we call LO, based on an extension of Horn logic. This language enhances the process view of objects implementable in Horn-based concurrent logic programming languages with powerful capabilities for knowledge structuring, leading to a flexible form of variable-structure inheritance. The main novelty about LO is a new kind of OR-concurrency which is dual to the usual AND-concurrency and provides us with the notion of</italic> structured process. <italic>Such OR-concurrency can be nicely characterized with a sociological metaphor as modelling the internal distribution of tasks inside a complex organization; this complements the external cooperation among different entities accounted for by AND-concurrency</italic>.
[Theory of computation, Software creation and management, General programming languages, Language features, Concurrent programming structures, Constraint and logic programming, Software notations and tools, Logic, Software development techniques, Software and its engineering]
A framework for dynamic program analyzers
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software defect analysis, Networks, Network structure, Software creation and management, Object oriented languages, Software verification and validation, Language types, Computing methodologies, Software notations and tools, Distributed computing methodologies, Development frameworks and environments, Network properties, Software testing and debugging, Distributed programming languages, General programming languages, Software and its engineering]
What contributes to successful object-oriented learning?
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Object oriented languages, Language types, Human-centered computing, Professional topics, Computing education, Software notations and tools, Human computer interaction (HCI), Computing education programs, General programming languages, Computer science education, Social and professional topics, Software and its engineering]
Application of OOP type theory: state, decidability, integration
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Important strides toward developing expressive yet semantically sound type systems for object-oriented programming languages have recently been made by Cook, Bruce, Mitchell, and others. This paper focusses on how the theoretical work using F-bounded quantification may be brought more into the realm of actual language implementations while preserving rigorous soundness properties. We simultaneously address three of the more significant problems: adding a notion of global state, proving type-checking is decidable, and integrating the more widely implemented view that subclasses correspond to subtypes with the F-bounded view.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering]
Lessons from the experiences of leading-edge object technology projects in Hewlett-Packard
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
A study of leading-edge HP object technology projects was conducted to understand the current state of object-oriented practice, and projects' object-oriented analysis and design method needs. In this paper, we distill general best practices and pitfalls from the lessons learned in these projects. We also consider how the OOA/D methods support what the businesses have set out to accomplish, where they are deficient, and how they are being modified to better support project needs. We draw upon these lessons to point out areas where OOA/D methods and CASE tools require improvement.
[Management of computing and information systems, Project and people management, General programming languages, Object oriented languages, Software management, Language types, Professional topics, Software notations and tools, Social and professional topics, Software and its engineering]
Lessons from the experiences of leading-edge object technology projects in Hewlett-Packard
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
A study of leading-edge HP object technology projects was conducted to understand the current state of object-oriented practice, and projects' object-oriented analysis and design method needs. In this paper, we distill general best practices and pitfalls from the lessons learned in these projects. We also consider how the OOA/D methods support what the businesses have set out to accomplish, where they are deficient, and how they are being modified to better support project needs. We draw upon these lessons to point out areas where OOA/D methods and CASE tools require improvement.
[Management of computing and information systems, Project and people management, General programming languages, Object oriented languages, Software management, Language types, Professional topics, Software notations and tools, Social and professional topics, Software and its engineering]
The basic object system: supporting a spectrum from prototypes to hardened code
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
BOS is a prototype-based, object-oriented toolkit aimed at better supporting evolutionary software development. BOS attempts to support a spectrum of activities in one environment---ranging from rapid prototyping to code hardening. Features enabling rapid prototyping include a prototype-based object model, an interpreted language, run-time argument constraints, position and keyword arguments, and a user interface toolkit. BOS also provides features for code hardening such as multi-methods, multiple inheritance, external code wrapping mechanisms, and interfaces to other packages such as database management systems. BOS thus enables the end-to-end programming of software in an integrated and unified environment. BOS has been used to develop several full-size applications which have been evaluated and delivered externally.
[Management of computing and information systems, Software prototyping, Software creation and management, Software development methods, Object oriented languages, Language features, Language types, Professional topics, Software notations and tools, Program constructs, Software development techniques, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Software management, Social and professional topics, Rapid application development, Software and its engineering]
Reuse of algorithms: still a challenge to object-oriented programming
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
This paper is about reusable, efficient implementations of complex algorithms and their integration into software packages. It seems that this problem is not yetwell understood, and that it is not at all clear how object-oriented and other approaches may contribute to a solution. We analyze the problem and try to reduce it to a few key design goals. Moreover, we discuss various existing approaches in light of these goals, and we briefly report experiences with experimental case studies, in which these goals were rigorously addressed.
[Software creation and management, Reusability, Language features, Object oriented languages, Language types, Software notations and tools, Mathematical software, Software development techniques, General programming languages, Data types and structures, Mathematics of computing, Software and its engineering]
JRes: a resource accounting interface for Java
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
With the spread of the Internet the computing model on server systems is undergoing several important changes. Recent research ideas concerning dynamic operating system extensibility are finding their way into the commercial domain, resulting in designs of extensible databases and Web servers. In addition, both ordinary users and service providers must deal with untrusted downloadable executable code of unknown origin and intentions.Across the board, Java has emerged as the language of choice for Internet-oriented software. We argue that, in order to realize its full potential in applications dealing with untrusted code, Java needs a flexible resource accounting interface. The design and prototype implementation of such an interface --- JRes --- is presented in this paper. The interface allows to account for heap memory, CPU time, and network resources consumed by individual threads or groups of threads. JRes allows limits to be set on resources available to threads and it can invoke callbacks when these limits are exceeded. The JRes prototype described in this paper is implemented on top of standard Java virtual machines and requires only a small amount of native code.
[Transport protocols, Networks, Network protocols, Language types, Human-centered computing, Web applications, Software notations and tools, World Wide Web, Human computer interaction (HCI), Network types, Development frameworks and environments, Information systems, Web-based interaction, Web services, Integrated and visual development environments, General programming languages, Public Internet, Interaction paradigms, Software and its engineering]
Removing unnecessary synchronization in Java
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Java programs perform many synchronization operations on data structures. Some of these synchronization are unnecessary; in particular, if an object is reachable only by a single thread, concurrent access is impossible and no synchronization is needed. We describe an interprocedural, flow- and context-insensitive dataflow analysis that finds such situations. A global optimizing transformation then eliminates synchronizations on these objects. For every program in our suite of ten Java benchmarks consisting of SPECjvm98 and others, our system optimizes over 90% of the alias sets containing at least one synchronized object. As a result, the dynamic frequency of synchronizations is reduced by up to 99%. For two benchmarks that perform synchronizations very frequently, this optimization leads to speedups of 36% and 20%.
[Cross-computing tools and techniques, Evaluation, Language types, Software notations and tools, Contextual software domains, Metrics, Operating systems, General programming languages, Process synchronization, General and reference, Software organization and properties, Software and its engineering, Process management, Compilers]
Object-oriented real-time concurrency
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
The primary goal of a real-time system is predictability. Achieving this goal requires all levels of the system to work in concert to provide fixed worst-case execution-times. Un-fortunately, many real-time systems are overly restrictive, providing only ad-hoc scheduling facilities and basic concurrent functionality. Ad-hoc scheduling makes developing, verifying, and maintaining a real-time system extremely difficult and time consuming. Basic concurrent functionality forces programmers to develop complex concurrent programs without the aid of high-level concurrency features.Encouraging the use of sophisticated real-time theory and methodology, in conjunction with high-level concurrency features, requires flexibility and extensibility. Giving real-time programmers access to the underlying system data-structures makes it possible to interact with the system to incorporate new ideas and fine-tune specific applications. This paper explores this approach by examining its effect on a selection of crucial real-time issues: real-time monitors, timeouts, dynamic-priority scheduling and basic priority inheritance. The approach is implemented in &amp;mu;C++.
[Machine learning theory, Embedded and cyber-physical systems, Software notations and tools, Contextual software domains, Embedded software, Theory of computation, Theory and algorithms for application domains, Computer systems organization, Scheduling algorithms, Operating systems, Concurrency, Approximation algorithms analysis, Real-time systems, Software organization and properties, Software and its engineering, Real-time systems software, Object oriented languages, Online learning algorithms, Reinforcement learning, Language types, Computing methodologies, Scheduling, Planning and scheduling, Models of computation, Online algorithms, Software system structures, Embedded systems, General programming languages, Sequential decision making, Design and analysis of algorithms, Artificial intelligence, Parallel computing models, Process management]
A core calculus for Java exceptions
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
In this paper we present a simple calculus (called CJE) in ourder to fully investigate the exception mechanism of Java, and in particular its interaction with inheritance, which turns out to be non trivial. Moreover, we show that the type system for the calculus directly dirven by the Java language specification (called FULL) uses too many types, in the sense that there are different types which rpovide exactly the same information. Hence, we obtain from FULL a simplified type system called MIN where equivalent types have been identified. We show that is useful both for type-checking optimization and for clarifying the static semantics of the language. The two type systems are proved to satisfy the subject reduction property
[Theory of computation, Semantics and reasoning, General programming languages, Language types, Functional languages, Software notations and tools, Program constructs, Type structures, Software and its engineering]
Reconsidering custom memory allocation
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Programmers hoping to achieve performance improvements often use custom memory allocators. This in-depth study examines eight applications that use custom allocators. Surprisingly, for six of these applications, a state-of-the-art general-purpose allocator (the Lea allocator) performs as well as or better than the custom allocators. The two exceptions use regions, which deliver higher performance (improvements of up to 44%). Regions also reduce programmer burden and eliminate a source of memory leaks. However, we show that the inability of programmers to free individual objects within regions can lead to a substantial increase in memory consumption. Worse, this limitation precludes the use of regions for common programming idioms, reducing their usefulness.We present a generalization of general-purpose and region-based allocators that we call reaps. Reaps are a combination of regions and heaps, providing a full range of region semantics with the addition of individual object deletion. We show that our implementation of reaps provides high performance, outperforming other allocators with region-like semantics. We then use a case study to demonstrate the space advantages and software engineering benefits of reaps in practice. Our results indicate that programmers needing fast regions should use reaps, and that most programmers considering custom allocators should instead use the Lea allocator.
[Dynamic compilers, Operating systems, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Applying traits to the smalltalk collection classes
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Traits are a programming language technology that promote the reuse of methods between unrelated classes. This paper reports on a refactoring of the Smalltalk collections classes using traits. The original collection classes contained much duplication of code; traits let us remove all of it. We also found places where the protocols of the collections lacked uniformity; traits allowed us to correct these non-uniformities without code duplication.Traits also make it possible to reuse fragments of collection code outside of the existing hierarchy; for example, they make it easy to convert other collection-like things into true collections. Our refactoring reduced the number of methods in the collection classes by approximately 10 per cent. More importantly, understandability maintainability and reusability of the code were significantly improved.
[Classes and objects, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
MC 2 : high-performance garbage collection for memory-constrained environments
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Java is becoming an important platform for memory-constrained consumer devices such as PDAs and cellular phones, because it provides safety and portability. Since Java uses garbage collection, efficient garbage collectors that run in constrained memory are essential. Typical collection techniques used on these devices are mark-sweep and mark-compact. Mark-sweep collectors can provide good throughput and pause times but suffer from fragmentation. Mark-compact collectors prevent fragmentation, have low space overheads, and provide good throughput. However, they can suffer from long pause times. Copying collectors can provide higher throughput than either of these techniques, but because of their high space overhead, they previously were unsuitable for memory-constrained devices. This paper presents MC&#60;sup>2&#60;/sup> (Memory-Constrained Copying), a copying generational garbage collector that meets the needs of memory-constrained devices with soft real-time requirements. MC&#60;sup>2&#60;/sup> has low space over-head and tight space bounds, prevents fragmentation, provides good throughput, and yields short pause times. These qualities make MC&#60;sup>2&#60;/sup> attractive for other environments, including desktops and servers.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Micro patterns in Java code
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Micro patterns are similar to design patterns, except that micro patterns are stand at a lower, closer to the implementation, level of abstraction. Micro patterns are also unique in that they are mechanically recognizable, since each such pattern can be expressed as a formal condition on the structure of a class.This paper presents a catalog of 27 micro-patterns defined on Java classes and interfaces. The catalog captures a wide spectrum of common programming practices, including a particular and (intentionally restricted) use of inheritance, immutability, data management and wrapping, restricted creation, and emulation of procedural-, modular-, and even functional- programming paradigms with object oriented constructs. Together, the patterns present a set of prototypes after which a large portion of all Java classes and interfaces are modeled. We provide empirical indication that this portion is as high as 75%.A statistical analysis of occurrences of micro patterns in a large software corpus, spanning some 70,000 Java classes drawn from a rich set of application domains, shows, with high confidence level that the use of these patterns is not random. These results indicate consciousness and discernible design decisions, which are sustained in the software evolution. With high confidence level, we can also show that the use of these patterns is tied to the specification, or the purpose, that the software realizes.The traceability, abundance and the statistical significance of micro pattern occurrence raise the hope of using the classification of software into these patterns for a more founded appreciation of its design and code quality.
[General programming languages, Software notations and tools, Software and its engineering]
JTL: the Java tools language
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
We present an overview of JTL (the Java Tools Language, pronounced "Gee-tel"), a novel language for querying JAVA [8] programs. JTL was designed to serve the development of source code software tools for JAVA, and as a small language which to aid programming language extensions to JAVA. Applications include definition of pointcuts for aspect-oriented programming, fixing type constraints for generic programming, specification of encapsulation policies, definition of micro-patterns, etc. We argue that the JTL expression of each of these is systematic, concise, intuitive and general.JTL relies on a simply-typed relational database for program representation, rather than an abstract syntax tree. The underlying semantics of the language is restricted to queries formulated in First Order Predicate Logic augmented with transitive closure (FOPL).Special effort was taken to ensure terse, yet readable expression of logical conditions. The JTL pattern &lt;B&gt;public abstract class&lt;/B&gt;, for example, matches all abstract classes which are publicly accessible, while &lt;B&gt;class&lt;/B&gt; (&lt;B&gt;public&lt;/B&gt; clone();) matches all classes in which method clone is public. To this end, JTL relies on a DATALOG-like syntax and semantics, enriched with quantifiers and pattern matching which all but entirely eliminate the need for recursive calls.JTL's query analyzer gives special attention to the fragility of the "closed world assumption" in examining JAVA software, and determines whether a query relies on such an assumption.The performance of the JTL interpreter is comparable to that of JQuery after it generated its database cache, and at least an order of magnitude faster when the cache has to be rebuilt.
[General programming languages, Software notations and tools, Software and its engineering]
Probabilistic calling context
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Calling context enhances program understanding and dynamic analyses by providing a rich representation of program location. Compared to imperative programs, object-oriented programs use more interprocedural and less intraprocedural control flow, increasing the importance of context sensitivity for analysis. However, prior online methods for computing calling context, such as stack-walking or maintaining the current location in a calling context tree, are expensive in time and space. This paper introduces a new online approach called probabilistic calling context (PCC) that continuously maintains a probabilistically unique value representing the current calling context. For millions of unique contexts, a 32-bit PCC value has few conflicts. Computing the PCC value adds 3% average overhead to a Java virtual machine. PCC is well-suited to clients that detect new or anomalous behavior since PCC values from training and production runs can be compared easily to detect new context-sensitive behavior; clients that query the PCC value at every system call, Java utility call, and Java API call add 0-9% overhead on average. PCC adds space overhead proportional to the distinct contexts stored by the client (one word per context). Our results indicate PCC is efficient and accurate enough to use in deployed software for residual testing, bug detection, and intrusion detection.
[Software defect analysis, Middleware for databases, Software creation and management, Distributed transaction monitors, Software verification and validation, Contextual software domains, Information systems, Software testing and debugging, Operating systems, Data management systems, Monitors, Software organization and properties, Software and its engineering, Process management]
Join patterns for visual basic
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
We describe an extension of Visual Basic 9.0 with asynchronous concurrency constructs - join patterns - based on the join calculus. Our design of Concurrent Basic (CB) builds on earlier work on Polyphonic C# and Comega. Since that work, the need for language-integrated concurrency has only grown, both due to the arrival of commodity, multi-core hardware, and the trend for Rich Internet Applications that rely on asynchronous client-server communication to hide latency. Unlike its predecessors, CB adopts an event-like syntax that should be familiar to existing VB programmers. Coupled with Generics, CB allows one to declare re-useable concurrency abstractions that were clumsy to express previously. CB removes its ancestors' inconvenient inheritance restriction, while providing new extensibility points useful in practical applications that must co-exist with or want to exploit alternative threading models available on the platform. CB is implemented as an extension of the production VB 9.0 compiler.
[Control structures, Classes and objects, General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
CZ: multiple inheritance without diamonds
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Multiple inheritance has long been plagued with the "diamond" inheritance problem, leading to solutions that restrict expressiveness, such as mixins and traits. Instead, we address the diamond problem directly, considering two difficulties it causes: ensuring a correct semantics for object initializers, and typechecking multiple dispatch in a modular fashion-the latter problem arising even with multiple interface inheritance. We show that previous solutions to these problems are either unsatisfactory or cumbersome, and suggest a novel approach: supporting multiple inheritance but forbidding diamond inheritance. Expressiveness is retained through two features: a "requires" construct that provides a form of subtyping without inheritance (inspired by Scala), and a dynamically-dispatched "super" call similar to that found in traits. Through examples, we illustrate that inheritance diamonds can be eliminated via a combination of "requires" and ordinary inheritance. We provide a sound formal model for our language and demonstrate its modularity and expressiveness.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Art, science, and fear
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Scientists and artists share a conviction that key elements of their work-creativity, craft, analysis, intuition--are somehow deeply similar. Most Onward! participants will have a clear sense of the scientific variants of these qualities, and of what it takes to manifest them in our day-to-day work as researchers and software designers. This talk looks at how ideas are developed and refined in the making of visual art, how the same qualities--especially creativity, the most ineffable--come into play, and how artists and scientists grapple with the various fears that beset creative work.
[Software and its engineering]
Accentuating the positive: atomicity inference and enforcement using correct executions
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Concurrency bugs are often due to inadequate synchronization that fail to prevent specific (undesirable) thread interleavings. Such errors, often referred to as Heisenbugs, are difficult to detect, prevent, and repair. In this paper, we present a new technique to increase program robustness against Heisenbugs. We profile correct executions from provided test suites to infer fine-grained atomicity properties. Additional deadlock-free locking is injected into the program to guarantee these properties hold on production runs. Notably, our technique does not rely on witnessing or analyzing erroneous executions. The end result is a scheme that only permits executions which are guaranteed to preserve the atomicity properties derived from the profile. Evaluation results on large, real-world, open-source programs show that our technique can effectively suppress subtle concurrency bugs, with small runtime overheads (typically less than 15%).
[Software defect analysis, Middleware for databases, Software creation and management, Distributed transaction monitors, Software verification and validation, Contextual software domains, Information systems, Traceability, Software testing and debugging, Operating systems, Process validation, Data management systems, Monitors, Software organization and properties, Software and its engineering, Process management]
Predicate abstraction of Java programs with collections
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Our goal is to develop precise and scalable verification techniques for Java programs that use collections and properties that depend on their content. We apply the popular approach of predicate abstraction to Java programs and collections. The main challenge in this context is precise and compact modeling of collections that enables practical verification. We define a predicate language for modeling the observable state of Java collections at the interface level. Changes of the state by API methods are captured by weakest preconditions. We adapt existing techniques for construction of abstract programs. Most notably, we designed optimizations based on specific features of the predicate language. We evaluated our approach on Java programs that use collections in advanced ways. Our results show that interesting properties, such as consistency between multiple collections, can be verified using our approach. The properties are specified using logic formulas that involve predicates introduced by our language.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Empirical analysis of programming language adoption
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Some programming languages become widely popular while others fail to grow beyond their niche or disappear altogether. This paper uses survey methodology to identify the factors that lead to language adoption. We analyze large datasets, including over 200,000 SourceForge projects, 590,000 projects tracked by Ohloh, and multiple surveys of 1,000-13,000 programmers. We report several prominent findings. First, language adoption follows a power law; a small number of languages account for most language use, but the programming market supports many languages with niche user bases. Second, intrinsic features have only secondary importance in adoption. Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not. Third, developers will steadily learn and forget languages. The overall number of languages developers are familiar with is independent of age. Finally, when considering intrinsic aspects of languages, developers prioritize expressivity over correctness. They perceive static types as primarily helping with the latter, hence partly explaining the popularity of dynamic languages.
[General programming languages, Software notations and tools, Software and its engineering]
Tardis: affordable time-travel debugging in managed runtimes
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Developers who set a breakpoint a few statements too late or who are trying to diagnose a subtle bug from a single core dump often wish for a time-traveling debugger. The ability to rewind time to see the exact sequence of statements and program values leading to an error has great intuitive appeal but, due to large time and space overheads, time traveling debuggers have seen limited adoption. A managed runtime, such as the Java JVM or a JavaScript engine, has already paid much of the cost of providing core features - type safety, memory management, and virtual IO - that can be reused to implement a low overhead time-traveling debugger. We leverage this insight to design and build affordable time-traveling debuggers for managed languages. Tardis realizes our design: it provides affordable time-travel with an average overhead of only 7% during normal execution, a rate of 0.6MB/s of history logging, and a worst-case 0.68s time-travel latency on our benchmark applications. Tardis can also debug optimized code using time-travel to reconstruct state. This capability, coupled with its low overhead, makes Tardis suitable for use as the default debugger for managed languages, promising to bring time-traveling debugging into the mainstream and transform the practice of debugging.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Programming with enumerable sets of structures
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We present an efficient, modular, and feature-rich framework for automated generation and validation of complex structures, suitable for tasks that explore a large space of structured values. Our framework is capable of exhaustive, incremental, parallel, and memoized enumeration from not only finite but also infinite domains, while providing fine-grained control over the process. Furthermore, the framework efficiently supports the inverse of enumeration (checking whether a structure can be generated and fast-forwarding to this structure to continue the enumeration) and lazy enumeration (achieving exhaustive testing without generating all structures). The foundation of efficient enumeration lies in both direct access to encoded structures, achieved with well-known and new pairing functions, and dependent enumeration, which embeds constraints into the enumeration to avoid backtracking. Our framework defines an algebra of enumerators, with combinators for their composition that preserve exhaustiveness and efficiency. We have implemented our framework as a domain-specific language in Scala. Our experiments demonstrate better performance and shorter specifications by up to a few orders of magnitude compared to existing approaches.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, General programming languages, Language features, Software notations and tools, Software and its engineering]
Portable inter-workgroup barrier synchronisation for GPUs
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Despite the growing popularity of GPGPU programming, there is not yet a portable and formally-specified barrier that one can use to synchronise across workgroups. Moreover, the occupancy-bound execution model of GPUs breaks assumptions inherent in traditional software execution barriers, exposing them to deadlock. We present an occupancy discovery protocol that dynamically discovers a safe estimate of the occupancy for a given GPU and kernel, allowing for a starvation-free (and hence, deadlock-free) inter-workgroup barrier by restricting the number of workgroups according to this estimate. We implement this idea by adapting an existing, previously non-portable, GPU inter-workgroup barrier to use OpenCL 2.0 atomic operations, and prove that the barrier meets its natural specification in terms of synchronisation. We assess the portability of our approach over eight GPUs spanning four vendors, comparing the performance of our method against alternative methods. Our key findings include: (1)Â the recall of our discovery protocol is nearly 100%; (2)Â runtime comparisons vary substantially across GPUs and applications; and (3)Â our method provides portable and safe inter-workgroup synchronisation across the applications we study.
[General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Combining visual and textual languages for dyslexia
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
This paper describes the research of a Software, Systems and Computing PhD thesis conducted at the Universidad Polit&#233;cnica de Madrid. The aim of this research is threefold: i) design a model to promote interaction between programmers with and without dyslexia during software development as part of a team, ii) overcome the obstacles facing dyslexic programmers when they are writing a program, and iii) increase software development performance and efficiency levels when one of the programmers has symptoms of dyslexia.
[HCI theory, concepts and models, Human-centered computing, Human computer interaction (HCI)]
Object-oriented programming with flavors
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
This paper describes Symbolics' newly redesigned object-oriented programming system, <italic>Flavors. Flavors</italic> encourages program modularity, eases the development of large, complex programs, and provides high efficiency at run time. <italic>Flavors</italic> is integrated into Lisp and the Symbolics program development environment. This paper describes the philosophy and some of the major characteristics of Symbolics' <italic>Flavors</italic> and shows how the above goals are addressed. Full details of <italic>Flavors</italic> are left to the programmers' manual, <italic>Reference Guide to Symbolics Common Lisp. (5)</italic>
[Software creation and management, Software notations and tools, Formal languages and automata theory, Program constructs, Development frameworks and environments, Software development techniques, Theory of computation, Semantics and reasoning, Formal language definitions, Type structures, Software and its engineering, Compilers]
An introduction to Trellis/Owl
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Trellis/Owl is an object-based language incorporating a type hierarchy with multiple inheritance and compile-time type checking. The combination of features in the language facilitates the design, implementation, and evolution of large computer programs. This paper provides an brief introduction to the Trellis/Owl language. It discusses the basic elements of the language, objects, and shows how these are specified and implemented using <italic>types, operations,</italic> and <italic>components</italic>. The notion of a type hierarchy is introduced by a discussion of <italic>subtyping</italic> and <italic>inheritance</italic>. Other elements of the Trellis/Owl language such as <italic>type generators, iterators,</italic> and <italic>exceptions</italic> are briefly presented.
[Theory of computation, Mathematical analysis, General programming languages, Language types, Software notations and tools, Mathematics of computing, Mathematical optimization, Design and analysis of algorithms, Software and its engineering]
Oaklisp: an object-oriented scheme with first class types
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
The Scheme papers demonstrated that lisp could be made simpler and more expressive by elevating functions to the level of first class objects. Oaklisp shows that a message based language can derive similar benefits from having first class types.
[General programming languages, Discrete mathematics, Language types, Software notations and tools, Graph theory, Mathematics of computing, Graph algorithms, Software and its engineering]
Encapsulation and inheritance in object-oriented programming languages
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Object-oriented programming is a practical and useful programming methodology that encourages modular design and software reuse. Most object-oriented programming languages support <italic>data abstraction</italic> by preventing an object from being manipulated except via its defined external operations. In most languages, however, the introduction of <italic>inheritance</italic> severely compromises the benefits of this encapsulation. Furthermore, the use of inheritance itself is globally visible in most languages, so that changes to the inheritance hierarchy cannot be made safely. This paper examines the relationship between inheritance and encapsulation and develops requirements for full support of encapsulation with inheritance.
[Theory of computation, Software creation and management, General programming languages, Language types, Software notations and tools, Mathematics of computing, Software development techniques, Software and its engineering]
An object-oriented operating system interface
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
This paper discusses an object-oriented interface from the Smalltalk-80&trade; programming environment to a Unix-like operating system. This interface imposes an object-oriented paradigm on operating system facilities. We discuss some of the higher order abstractions that were created to make use of these facilities, and discuss difficulties we encountered implementing this interface. Several examples of cooperating Smalltalk and operating system processes are presented.
[Operating systems, General programming languages, Data management systems, Language types, Software notations and tools, Database design and models, Contextual software domains, Software organization and properties, Information systems, Software and its engineering]
A probe-based monitoring scheme for an object-oriented distributed operating system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
None
[Cross-computing tools and techniques, Middleware for databases, Distributed transaction monitors, Web applications, World Wide Web, Contextual software domains, Information systems, Distributed systems organizing principles, Software system structures, Operating systems, Internet communications tools, Data management systems, Monitors, Performance, General and reference, Software organization and properties, Software and its engineering, Process management]
Mach and Matchmaker: kernel and language support for object-oriented distributed systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Mach, a multiprocessor operating system kernel providing capability-based interprocess communication, and Matchmaker, a language for specifying and automating the generation of multi-lingual interprocess communication interfaces, are presented. Their usage together providing a heterogeneous, distributed, object-oriented programming environment is described. Performance and usage statistics are presented. Comparisons are made between the Mach/Matchmaker environment and other related systems. Possible future directions are examined.
[Networks, Life and medical sciences, Web applications, Health care information systems, Language types, World Wide Web, Software notations and tools, Network architectures, Development frameworks and environments, Information systems, Distributed systems organizing principles, Applied computing, Software system structures, Integrated and visual development environments, General programming languages, Internet communications tools, Software organization and properties, Software and its engineering]
Object structure in the Emerald system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
<italic>Emerald is an object-based language for the construction of distributed applications. The principal features of Emerald include a uniform object model appropriate for programming both private local objects and shared remote objects, and a type system that permits multiple user-defined and compiler-defined implementations. Emerald objects are fully mobile and can move from node to node within the network, even during an invocation. This paper discusses the structure, programming, and implementation of Emerald objects, and Emerald's use of abstract types.</italic>
[Networks, Computing / technology policy, Language types, Software notations and tools, Network architectures, Computer crime, Distributed systems organizing principles, Software system structures, Security and privacy, Intrusion/anomaly detection and malware mitigation, General programming languages, Social and professional topics, Software organization and properties, Software and its engineering]
Virtual memory on a narrow machine for an object-oriented language
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
LOOM (Large Object-Oriented Memory) is a virtual memory implemented in software that supports the Smalltalk-80(&trade;) programming language and environment on the Xerox Dorado computer. LOOM provides 8 billion bytes of secondary memory address space and is specifically designed to run on computers with a narrow word size (16-bit wide words). All storage is viewed as objects that contain fields. Objects may have an average size as small as 10 fields. LOOM swaps objects between primary and secondary memory, and addresses each of the two memories with a different sized object pointer. When objects are cached in primary memory, they are known only by their short pointers. On a narrow word size machine, the narrow object pointers in primary memory allow a program such as the Smalltalk-80 interpreter to enjoy a substantial speed advantage. Interesting design problems and solutions arise from the mapping between the two address spaces and the temporary nature of an object's short address. The paper explains why the unusual design choices in LOOM were made, and provides an interesting example of the process of designing an integrated virtual memory and storage management system.
[Life and medical sciences, Language types, Software notations and tools, Dynamic memory, Semiconductor memory, Integrated circuits, Applied computing, Document types, General programming languages, Consumer health, Hardware, General and reference, Health informatics, Reference works, Software and its engineering]
SOAR: Smalltalk without bytecodes
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We have implemented Smalltalk-80 on an instruction-level simulator for a RISC microcomputer called SOAR. Measurements suggest that even a conventional computer can provide high performance for Smalltalk-80 by abandoning the 'Smalltalk Virtual Machine' in favor of compiling Smalltalk directly to SOAR machine code, linearizing the activation records on the machine stack, eliminating the object table, and replacing reference counting with a new technique called Generation Scavenging. In order to implement these techniques, we had to find new ways of hashing objects, accessing often-used objects, invoking blocks, referencing activation records, managing activation record stacks, and converting the virtual machine images.
[Applied computing, Computer systems organization, Life and medical sciences, Context specific languages, Software notations and tools, Other architectures, Software and its engineering, Architectures]
A third generation Smalltalk-80 implementation
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
A new, high performance Smalltalk-80&trade; implementation is described which builds directly upon two previous implementation efforts. This implementation supports a large object space while retaining compatibility with previous Smalltalk-80&trade; images. The implementation utilizes a interpreter which incorporates a generation based garbage collector and which does not have an object table. This paper describes the design decisions which lead to this implementation and reports preliminary performance results.
[Applied computing, Cross-computing tools and techniques, Evaluation, Metrics, General programming languages, Language types, Software notations and tools, General and reference, Physical sciences and engineering, Software and its engineering]
Swamp: a fast processor for Smalltalk-80
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
A processor for the Smalltalk-80&uarr; programming language is described. This machine is implemented using a standard bit slice ALU and sequencer, TTL MSI, and NMOS LSI RAMS. It executes an instruction set similar to the Smalltalk-80 virtual machine instruction set. The data paths of the machine are optimized for rapid Smalltalk-80 execution by the inclusion of a context cache, tag checking, and a hardware method cache. Each context is only partly initialized when created, and has no memory allocated for it until a possibly non-LIFO reference to it is created. The machine is microprogrammed, and uses a simple next micro-address prediction strategy to obtain most of the performance of pipelining without the attendant complexity. The machine can execute simple instructions at over 7M bytecodes per second and has a predicted average throughput of 1.9M bytecodes per second.A processor for the Smalltalk-80&uarr; programming language is described. This machine is implemented using a standard bit slice ALU and sequencer, TTL MSI, and NMOS LSI RAMS. It executes an instruction set similar to the Smalltalk-80 virtual machine instruction set. The data paths of the machine are optimized for rapid Smalltalk-80 execution by the inclusion of a context cache, tag checking, and a hardware method cache. Each context is only partly initialized when created, and has no memory allocated for it until a possibly non-LIFO reference to it is created. The machine is microprogrammed, and uses a simple next micro-address prediction strategy to obtain most of the performance of pipelining without the attendant complexity. The machine can execute simple instructions at over 7M bytecodes per second and has a predicted average throughput of 1.9M bytecodes per second.
[Language types, Software notations and tools, Formal languages and automata theory, Computability, Theory of computation, Models of computation, Computer systems organization, General programming languages, Formal language definitions, Logic, Software and its engineering, Architectures]
QUICKTALK: a Smalltalk-80 dialect for defining primitive methods
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
QUICKTALK is a dialect of Smalltalk-80 that can be compiled directly into native machine code, instead of virtual machine bytecodes. The dialect includes "hints" on the class of method arguments, instance variables, and class variables. We designed the dialect to describe primitive Smalltalk methods. QUICKTALK achieves improved performance over bytecodes by eliminating the interpreter loop on bytecode execution, by reducing the number of message send/returns via binding some target methods at compilation, and by eliminating redundant class checking. We identify changes to the Smalltalk-80 system and compiler to support the dialect, and give performance measurements.
[Applied computing, General programming languages, Language types, Software notations and tools, Physical sciences and engineering, Software and its engineering]
Hurricane: an optimizing compiler for Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We discuss a recent attempt at providing a more efficient compilation system for the Smalltalk-80&trade; language than currently exists. The approach is unique in that it attempts to work within the existing semantics of the language. A type declaration and inference mechanism is developed in order to make the problem tractable. Details concerning the compiler implemented to date are given, as well as preliminary speed tests of compiled object code.
[Operating systems, General programming languages, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Virtual copies: at the boundary between classes and instances
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Knowledge bases built in object-oriented systems use networks of interconnected objects in their representations. The mechanism described here provides a way to use such a network as a prototype by making virtual copies of it. The virtual copy is created incrementally. Values of instance variables in the virtual copy are inherited from the prototype until locally overridden in the copy, similar to inheritance of defaults between instances and classes in Loops. A virtual copy preserves the topology of the original network. Virtual copies can be made from virtual copies. Alternative implementations of virtual copies allow different tradeoffs in space and lookup time. Virtual copies can be used for building knowledge bases for design, for representing contexts in a problem solving system, and have other uses in ordinary programming.
[Software creation and management, General programming languages, Machine learning, Computing methodologies, Context specific languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Impulse-86: a substrate for object-oriented interface design
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Impulse-86 provides a general and extensible substrate upon which to construct a wide variety of interactive user interfaces for developing, maintaining, and using knowledge-based systems. The system is based on five major building blocks: <italic>Editor, Editor Window, PropertyDisplay, Menu</italic>, and <italic>Operations</italic>. These building blocks are interconnected via a uniform framework and each has a well-defined set of responsibilities in an interface.Customized interfaces can be designed by declaratively replacing some of the building blocks in existing Impulse-86 templates. Customization may involve a wide range of activities, ranging from simple override of default values or methods that control primitive operations (<italic>e.g.</italic>, font selection), to override of more central Impulse-86 methods (<italic>e.g.</italic>, template instantiation). Most customized interfaces require some code to be written-to handle domain-specific commands. However, in all cases, the Impulse-86 substrate provides considerable leverage by taking care of the low-level details of screen, mouse, and keyboard manipulation.Impulse-86 is implemented in Strobe, a language that provides object-oriented programming support for Lisp. This simplifies customization and extension.
[Software creation and management, Simulation types and techniques, Computing methodologies, Language types, Software notations and tools, Probabilistic reasoning algorithms, Mathematical software, Development frameworks and environments, Software development techniques, Modeling and simulation, Integrated and visual development environments, General programming languages, Probability and statistics, Sequential Monte Carlo methods, Mathematics of computing, Markov-chain Monte Carlo methods, Simulation evaluation, Software and its engineering]
Experience with Flamingo: a distributed, object-oriented user interface system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
The Flamingo Window Management System is based on a <italic>remote method invocation</italic> mechanism that provides separate processes running in a heterogeneous, distributed computing environment with complete access to Flamingo's objects and methods. This object-oriented interface has made Flamingo a <italic>kernel window manager</italic> into which device drivers, graphics libraries, window managers and user interfaces can be dynamically loaded. This paper discusses the strengths and weaknesses of Flamingo's system architecture, and introduces a new architecture which will provide a network-wide object space with object protection, migration, and garbage collection.
[Partial differential equations, Computing methodologies, Software notations and tools, Development frameworks and environments, Modeling and simulation, Integrated and visual development environments, Mathematical analysis, Differential equations, Ordinary differential equations, Mathematics of computing, Simulation evaluation, Software and its engineering]
Intermedia: The architecture and construction of an object-oriented hypemedia system and applications framework
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
This article presents a case study of the development of the Intermedia system, a large, object-oriented hypermedia system and associated applications development framework providing sophisticated document linkages. First it presents the educational and technological objectives underlying the project. Subsequent sections capture the process of developing the Intermedia product and detail its architecture and construction, concentrating on the areas in which object-oriented technology has had a significant role. Finally, the successes and failures of the development approach are examined, and several areas of standardization and research that would enhance the process are proposed.
[Networks, Cross-computing tools and techniques, Software creation and management, Language types, Dependable and fault-tolerant systems and networks, Software notations and tools, Software development techniques, Physical sciences and engineering, Applied computing, Engineering, Computer systems organization, General programming languages, Performance, General and reference, Network performance evaluation, Software and its engineering]
Building a timeline editor from prefab parts: the architecture of an object-oriented application
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
<italic>This article describes InterVal, a software tool that allows authors to create dynamic timelines. It is one tool in Intermedia, a framework developed at Brown University's institute for Research in Information and Scholarship (IRIS) that allows professors and students to create linked multimedia documents and encourages exploration, connectivity, and visualization of ideas. The system was written using an object-oriented extension to C, MacApp, and a set of underlying building blocks, or functional groups of objects. This paper describes InterVal and discusses the architecture of the InterVal application, focusing on the design of the object-oriented architecture and on the use of appropriate building blocks. Concluding sections evaluate object-oriented programming and outline future work</italic>.
[Software design techniques, Software creation and management, Information systems applications, Language types, Software notations and tools, Software development techniques, Information systems, Software implementation planning, Designing software, Software development process management, General programming languages, Software and its engineering]
Using prototypical objects to implement shared behavior in object-oriented systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
A traditional philosophical controversy between representing general concepts as abstract <italic>sets</italic> or <italic>classes</italic> and representing concepts as concrete <italic>prototypes</italic> is reflected in a controversy between two mechanisms for sharing behavior between objects in object oriented programming languages. <italic>Inheritance</italic> splits the object world into <italic>classes</italic>, which encode behavior shared among a group of <italic>instances</italic>, which represent individual members of these sets. The class/instance distinction is not needed if the alternative of using <italic>prototypes</italic> is adopted. A prototype represents the <italic>default</italic> behavior for a concept, and new objects can re-use part of the knowledge stored in the prototype by saying how the new object differs from the prototype. The prototype approach seems to hold some advantages for representing default knowledge, and incrementally and dynamically modifying concepts. <italic>Delegation</italic> is the mechanism for implementing this in object oriented languages. After checking its idiosyncratic behavior, an object can forward a message to prototypes to invoke more general knowledge. Because class objects must be created before their instances can be used, and behavior can only be associated with classes, inheritance fixes the communication patterns between objects at instance creation time. Because any object can be used as a prototype, and any messages can be forwarded at any time, delegation is the more flexible and general of the two techniques.
[Cross-computing tools and techniques, Software creation and management, Language features, Language types, Extra-functional properties, Software notations and tools, Software reliability, Software development techniques, General programming languages, Reliability, General and reference, Software organization and properties, Software and its engineering]
An experience with a Prolog-based object-oriented language
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
This paper presents an experience with a programming language SPOOL which is based on the combination of object-oriented programming and logic programming. This language inherits the capability of knowledge base organization from object-oriented programming and its expressive power from logic programming.The experience of the application of SPOOL to the program annotation system showed that this combination was quite useful to formalize domain knowledge into declarative data types and make them reusable in different contexts. It also showed the need for further study such as better linguistic support to exploit the full power of this combination.
[Algebraic algorithms, Symbolic and algebraic algorithms, Computing methodologies, Symbolic and algebraic manipulation, Context specific languages, Software notations and tools, Software and its engineering]
A concurrent object-oriented knowledge representation language Orient84/K: its features and implementation
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Orient84/K is an object oriented concurrent programming language for describing knowledge systems. In Orient84/K, an object is composed of the <italic>behavior part</italic>, the <italic>knowledge-base part</italic>, and the <italic>monitor part</italic>, in order to provide <italic>object-oriented, logic-based, demon-oriented</italic>, and <italic>concurrent-programming</italic> paradigms in the object framework. Every object is capable of concurrent execution in Orient84/K.In this paper, after describing an overview of Orient84/K, we will describe implementation issues in a concurrent object oriented language. Then, a new method for an efficient implementation of concurrent objects is proposed and formally described. A new virtual machine for Orient84/K is designed using this method, and some preliminary results of evaluation are presented.
[Applied computing, General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Physical sciences and engineering, Software and its engineering]
Objects in concurrent logic programming languages
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Concurrent Prolog supports object-oriented programming with a clean semantics and additional programming constructs such as incomplete messages, unification, direct broadcasting, and concurrency synchronization [Shapiro 1983a]. While it provides excellent computational support, we claim it does not provide good notation for expressing the abstractions of object-oriented programming. We describe a preprocessor that remedies this problem. The resulting language, Vulcan, is then used as a behicle for exploring new variants of object-oriented programming which become possible in this framework.
[Computations in finite fields, Computing methodologies, Symbolic and algebraic manipulation, Context specific languages, Language types, Software notations and tools, Linear algebra algorithms, Mathematical software, Numerical analysis, Mathematical analysis, General programming languages, Differential equations, Computations on matrices, Symbolic and algebraic algorithms, Ordinary differential equations, Concurrent programming languages, Mathematics of computing, Concurrent computing methodologies, Software and its engineering]
Object-oriented concurrent programming in ABCL/1
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
An object-oriented computation model is presented which is designed for modelling and describing a wide variety of concurrent systems. In this model, three types of message passing are incorporated. An overview of a programming language called ABCL/1, whose semantics faithfully reflects this computation model, is also presented. Using ABCL/1, a simple scheme of distributed problem solving is illustrated. Furthermore, we discuss the reply destination mechanism and its applications. A distributed "same fringe" algorithm is presented as an illustration of both the reply destination mechanism and the future type message passing which is one of the three message passing types in our computation model.
[Computing methodologies, Language types, Software notations and tools, Physics, Physical sciences and engineering, Theory of computation, Models of computation, Applied computing, Concurrency, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering, Parallel computing models]
An object-oriented architecture for intelligent tutoring systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We describe an object-oriented architecture for intelligent tutoring systems. The architecture is oriented around objects that represent the various knowledge elements that are to be taught by the tutor. Each of these knowledge elements, called <italic>bites</italic>, inherits both a knowledge organization describing the kind of knowledge represented and tutoring components that provide the functionality to accomplish standard tutoring tasks like diagnosis, student modeling, and task selection. We illustrate the approach with several tutors implemented in our lab.
[Software design techniques, Software creation and management, Professional topics, Computing education, Language types, Software notations and tools, Software development techniques, Physical sciences and engineering, Software implementation planning, Applied computing, Designing software, Software development process management, Education, General programming languages, Social and professional topics, Software and its engineering]
A Smalltalk system for algebraic manipulation
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
This paper describes the design of an algebra system Views implemented in Smalltalk. Views contains facilities for dynamic creation and manipulation of <italic>computational domains</italic>, for <italic>viewing</italic> these domains as various <italic>categories</italic> such as groups, rings, or fields, and for expressing algorithms generically at the level of categories. The design of Views has resulted in the addition of some new abstractions to Smalltalk that are quite useful in their own right. <italic>Parameterized classes</italic> provide a means for run-time creation of new classes that exhibit generally very similar behavior, differing only in minor ways that can be described by different instantiations of certain parameters. <italic>Categories</italic> allow the abstraction of the common behavior of classes that derives from the class objects and operations satisfying certain laws independently of the implementation of those objects and operations. <italic>Views</italic> allow the run-time association of classes with categories (and of categories with other categories), facilitating the use of code written for categories with quite different interpretations of operations. Together, categories and views provide an additional mechanism for code sharing that is richer than both single and multiple inheritance. The paper gives algebraic as well as non-algebraic examples of the above-mentioned features.
[Numerical analysis, Mathematical analysis, General programming languages, Computing / technology policy, Intellectual property, Language types, Software notations and tools, Mathematics of computing, Social and professional topics, Software and its engineering]
Petri net-based object-oriented modelling of distributed systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
This paper presents an object-oriented approach for building distributed systems. An example taken from the field of computer integrated manufacturing systems is taken as a guideline. According to this approach a system is built up through three steps: control and synchronization aspects for each class of objects are treated first using PROT nets, which are a high-level extension to Petri nets; then data are introduced specifying the internal states of the objects as well as the messages they send each other; finally the connections between the objects are introduced by means of a data flow diagram between classes. The implementation uses ADA as the target language, exploiting its tasking and structuring mechanisms. The flexibility of the approach and the possibility of using a knowledge-based user interface promote rapid prototyping and reusability.
[Operations research, Software creation and management, Emerging technologies, Software notations and tools, Quantum technologies, Computer-aided manufacturing, Theory of computation, Computer systems organization, Software development process management, Mathematical analysis, Integral equations, Quantum dots and cellular automata, Hardware, Mathematics of computing, Rapid application development, Software and its engineering, Cellular architectures, Software prototyping, Software development methods, Language types, Parallel architectures, Software development techniques, Models of computation, Applied computing, Numerical analysis, General programming languages, Differential equations, Ordinary differential equations, Architectures]
The application accelerator illustration system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
The Application Accelerator Illustration System is a prototype of an integrated CAD environment that supports the development of application-specific integrated circuits. The current implementation features a hardware description language compiler, timing analyzer, functional simulator, waveform tracer, and data path place and route facility. The system is implemented in Smalltalk-80&trade;.
[Emerging technologies, Language types, Software notations and tools, Mathematical foundations of cryptography, Physical sciences and engineering, Coding theory, Applied computing, Engineering, Security and privacy, General programming languages, Hardware, Mathematics of computing, Cryptography, Information theory, Software and its engineering, Compilers]
Virtual instruments: object-oriented program synthesis
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Virtual Instruments<supscrpt>1</supscrpt> is an experimental programming environment for developing electronic test and measurement (T&amp;M) applications. Intended users are test engineers, who are not programmers, but computer literate domain specialists. Unlike traditional programming environments, that provide weak support for a broad range of applications, virtual instruments provides strong support for a specific application. The programming paradigm is bottom-up synthesis of layers of virtual machines - called virtual instruments - using human interface models from the application domain, so that software development occurs without writing code. The object-oriented view of the world has proven a natural fit. Implementation was in Berkeley Smalltalk on a SUN workstation.
[Applied computing, Chemistry, Electronics, Software notations and tools, Development frameworks and environments, Physical sciences and engineering, Software and its engineering]
Type-checking Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Although most attempts to speed-up Smalltalk have focused on providing more efficient interpreters, code optimization is probably necessary for further increases in speed. A type-system for Smalltalk is a prerequisite for building an optimizing compiler. Unfortunately, none of the type-systems so far proposed for Smalltalk are adequate; they either cause nearly all Smalltalk programs to be type incorrect, allow run-time type errors, or do not provide enough information for optimization. This paper presents a type-system for Smalltalk that is suitable for code optimization.
[Reconstruction, Computer vision, Computer vision problems, Language features, Computing methodologies, Language types, Software notations and tools, Mathematical software, Theory of computation, Numerical analysis, Mathematical analysis, General programming languages, Computation of transforms, Differential equations, Computer graphics, Data types and structures, Ordinary differential equations, Image manipulation, Mathematics of computing, Mathematical optimization, Design and analysis of algorithms, Artificial intelligence, Software and its engineering]
An exemplar based Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Two varieties of object-oriented systems exist: one based on classes as in Smalltalk and another based on exemplars (or prototypical objects) as in Act/1. By converting Smalltalk from a class based orientation to an exemplar base, independent instance hierarchies and class hierarchies can be provided. Decoupling the two hierarchies in this way enables the user's (logical) view of a data type to be separated from the implementer's (physical) view. It permits the instances of a class to have a representation totally different from the instances of a superclass. Additionally, it permits the notion of multiple representations to be provided without the need to introduce specialized classes for each representation. In the context of multiple inheritance, it leads to a novel view of inheritance (or-inheritance) that differentiates it from the more traditional multiple inheritance notions (and-inheritance). In general, we show that exemplar based systems are more powerful than class based systems. We also describe how an existing class based Smalltalk can be transformed into an exemplar-based Smalltalk and discuss possible approaches for the implementation of both and-inheritance and or-inheritance.
[General programming languages, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Software and its engineering]
The design and implementation of Concurrent Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
ConcurrentSmalltalk is a programming language/system which incorporates the facilities of concurrent programming in Smalltalk-80<supscrpt>1</supscrpt>. Such facilities are realized by providing <italic>concurrent constructs</italic> and <italic>atomic objects</italic>. This paper first gives an outline of ConcurrentSmalltalk. Then, the design of ConcurrentSmalltalk is described. The implementation of ConcurrentSmalltalk is presented in detail.
[Cross-computing tools and techniques, Evaluation, Software creation and management, Computing methodologies, Language types, Software notations and tools, Software development techniques, Language resources, Metrics, General programming languages, Natural language processing, Artificial intelligence, General and reference, Software and its engineering]
Encapsulators: a new software paradigm in Smalltalk-80
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Certain situations arise in programming that lead to multiply polymorphic expressions, that is, expressions in which several terms may each be of variable type. In such situations, conventional object-oriented programming practice breaks down, leading to code which is not properly modular. This paper describes a simple approach to such problems which preserves all the benefits of good object-oriented programming style in the face of any degree of polymorphism. An example is given in Smalltalk-80 syntax, but the technique is relevant to all object-oriented languages.
[Software creation and management, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Development frameworks and environments, Software development techniques, Integrated and visual development environments, General programming languages, Interaction paradigms, Graphical user interfaces, Software and its engineering]
A simple technique for handling multiple polymorphism
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Certain situations arise in programming that lead to multiply polymorphic expressions, that is, expressions in which several terms may each be of variable type. In such situations, conventional object-oriented programming practice breaks down, leading to code which is not properly modular. This paper describes a simple approach to such problems which preserves all the benefits of good object-oriented programming style in the face of any degree of polymorphism. An example is given in Smalltalk-80 syntax, but the technique is relevant to all object-oriented languages.
[Software creation and management, General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Mathematics of computing, Mathematical software, Concurrent computing methodologies, Software development techniques, Software and its engineering]
Pi: a case study in object-oriented programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Pi is a debugger written in C + +. This paper explains how object-oriented programming in C + + has influenced Pi's evolution. The motivation for object-oriented programming was to experiment with a browser-like graphical user interface. The first unforeseen benefit was in the symbol table: lazy construction of an abstract syntax-based tree gave a clean interface to the remainder of Pi, with an efficient and robust implementation. Next, though not in the original design, Pi was easily modified to control multiple processes simultaneously. Finally, Pi was extended to control processes executing across multiple heterogeneous target processors.
[Software design techniques, Software defect analysis, Management of computing and information systems, Software creation and management, Software verification and validation, Professional topics, Language types, Software notations and tools, Software development techniques, Software implementation planning, Designing software, Software development process management, Software testing and debugging, Software management, General programming languages, Social and professional topics, Software and its engineering]
A diagram for object-oriented programs
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We introduce a notation for diagramming the message sending dialogue that takes place between objects participating in an object-oriented computation. Our representation takes a global point of view which emphasizes the collaboration between objects implementing the behavior of individuals. We illustrate the diagram's usage with examples drawn from the Smalltalk-80&trade; virtual image. We also describe a mechanism for automatic construction of diagrams from Smalltalk code.
[Communication hardware, interfaces and storage, Networks, Software creation and management, Embedded and cyber-physical systems, Dependable and fault-tolerant systems and networks, Software notations and tools, Embedded software, Statistical paradigms, Computer systems organization, Hardware, Probability and statistics, Mathematics of computing, Network performance evaluation, Software organization and properties, Software and its engineering, Real-time systems software, Cross-computing tools and techniques, Language types, Software development techniques, Software system structures, Embedded systems, General programming languages, Performance, General and reference, Queueing theory]
An object-oriented approach to a large scientific application
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We used an object-oriented design to build a large scientific application: simulation of radiation therapy treatments for cancer. We provide features familiar in the graphics workstation world, including graphic editing of the proposed treatment, multiple views of the treatment in different windows, and computations which proceed concurrently as the input data are being edited. To make our system practical for the typical clinic we used a popular minicomputer and the vendor's operating system and compiler. This paper describes how we implemented objects, inheritance, message passing, windows, and concurrency in (almost) standard Pascal on a VAX under VMS.
[Applied computing, Software creation and management, Life and medical sciences, Software development techniques, Software and its engineering]
Language support for changeable large real time systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
A set of concepts for modeling large real time systems is discussed informally. The concepts support the design of centralized as well as distributed systems. They are object oriented in that they correspond to entities of the 'real world', and they are 'change oriented' in that they support not only the first development stage of a system but also its continuous change and evolution. In particularly, the concepts give a promising solution to 'on the fly' changes of existing, active entities.
[Communication hardware, interfaces and storage, Networks, Project and people management, Software creation and management, Embedded and cyber-physical systems, Professional topics, Dependable and fault-tolerant systems and networks, Software notations and tools, Software configuration management and version control systems, Computer systems organization, Software development process management, Metrics, Modeling and simulation, Hardware, Real-time systems, Social and professional topics, Model development and analysis, Network performance evaluation, Software and its engineering, Modeling methodologies, Cross-computing tools and techniques, Management of computing and information systems, Computing methodologies, Software management, General programming languages, Performance, General and reference]
Object-oriented spreadsheets: the analytic spreadsheet package
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
The ASP package, a spreadsheet implemented in Smalltalk-80, is discussed. A description of the unique data manipulation features of ASP is given. A discussion of how these features arise from the Smalltalk-80 environment is included, with emphasis on features not common to all object oriented languages.
[Networks, Cross-computing tools and techniques, Automation, Software creation and management, Enterprise information systems, Information systems applications, Professional topics, Language types, Dependable and fault-tolerant systems and networks, Software notations and tools, Software development techniques, Information systems, Computing and business, Computer systems organization, Applied computing, Enterprise computing, Enterprise applications, General programming languages, Performance, Social and professional topics, General and reference, Network performance evaluation, Software and its engineering]
Genericity versus inheritance
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Genericity, as in Ada or ML, and inheritance, as in object-oriented languages, are two alternative techniques for ensuring better extendibility, reusability and compatibility of software components. This article is a comparative analysis of these two methods. It studies their similarities and differences and assesses to what extent each may be simulated in a language offering only the other. It shows what features are needed to successfully combine the two approaches in a statically typed language and presents the main features of the programming language Eiffel, whose design, resulting in part from this study, includes multiple inheritance and limited form of genericity under full static typing.
[Language types, Software notations and tools, Business process management, Formal languages and automata theory, Program constructs, Theory of computation, Applied computing, Enterprise computing, Semantics and reasoning, General programming languages, Formal language definitions, Type structures, Software and its engineering]
Object identity
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
<italic>Identity is that property of an object which distinguishes each object from all others. Identity has been investigated almost independently in general-purpose programming languages and database languages. Its importance is growing as these two environments evolve and merge.</italic><italic>We describe a continuum between weak and strong support of identity, and argue for the incorporation of the strong notion of identity at the conceptual level in languages for general purpose programming, database systems and their hybrids. We define a data model that can directly describe complex objects, and show that identity can easily be incorporated in it. Finally, we compare different implementation schemes for identity and argue that a surrogate-based implementation scheme is needed to support the strong notion of identity.</italic>
[Cluster analysis, Computer vision, Computer vision tasks, Learning paradigms, Computing methodologies, Language types, Software notations and tools, Formal languages and automata theory, Unsupervised learning, Theory of computation, Scene understanding, General programming languages, Machine learning, Formal language definitions, Artificial intelligence, Software and its engineering]
Boolean classes
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We extend the notion of class so that any Boolean combinations of classes is also a class. Boolean classes allow greater precision and conciseness in naming the class of objects governed a particular method. A class can be viewed as a predicate which is either true or false of any given object. Unlike predicates however classes have an inheritance hierarchy which is known at compile time. Boolean classes extend the notion of class, making classes more like predicates, while preserving the compile time computable inheritance hierarchy.
[Theory of computation, General programming languages, Language types, Formal language definitions, Software notations and tools, Computational complexity and cryptography, Formal languages and automata theory, Randomness, geometry and discrete structures, Software and its engineering, Complexity classes]
An alternative to subclassing
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Smalltalk-80 obtains some of its expressive power from arranging classes in a hierarchy. Inheritance is an important aspect of this hierarchy. An alternative organization of classes is proposed that emphasizes description instead of inheritance. This alternative can be used with compile-time type checking and retains the important characteristics of Smalltalk's hierarchy.
[Management of computing and information systems, Software creation and management, Professional topics, Language types, Software notations and tools, Formal languages and automata theory, Complexity classes, Theory of computation, Software management, General programming languages, Formal language definitions, Computational complexity and cryptography, Social and professional topics, Software and its engineering]
Augmentation of object-oriented programming by concepts of abstract data type theory: the ModPascal experience
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Object-oriented programming and abstract data type (ADT) theory have emerged from the same origin of computer science: the inability to deal efficiently with 'programming in the large' during the early seventies. Each of the approaches has led to significant practical and theoretical results resp. Nevertheless it is still unsatisfactory that up to now the mutual influence seems to be limited to more or less syntactical issues (e.g. the provision of packages, clusters, forms). In this paper we report on the object-oriented language ModPascal that was developed as part of the Integrated Software Development and Verification (ISDV) Project. We show how the essence of concepts of ADT theory as algebraic specifications, enrichments, parameterized specifications or signature morphisms as well as their semantics can be consistently integrated in an imperative object-oriented language. Furthermore, as the experience of using ModPascal as target language of the ISDV System has shown, we claim that without similar support of theoretical concepts techniques like formal specification of programs or algebraic verification loose their power and even applicability.
[Decision support systems, Software creation and management, Language features, Information systems applications, Language types, Software notations and tools, Software development techniques, Information systems, General programming languages, Abstract data types, Expert systems, Software and its engineering]
Design of a distributed object manager for the Smalltalk-80 system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
This paper describes the design of a distributed object manager which allows several Smalltalk-80 systems to share objects over a local-area network. This object manager is based on the following principles: location transparency and uniform object naming, unique object representation and use of symbolic links for remote access, possibility of object migration and distributed garbage collection. A version of the object manager has been implemented and is currently being integrated on a two nodes configuration.
[Communication hardware, interfaces and storage, Network properties, Wide area networks, Networks, General programming languages, Language types, Network range, Software notations and tools, Hardware, Local area networks, Software and its engineering]
A distributed repository for immutable persistent objects
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
Jasmine is an object-oriented system for programming-in-the-large. Jasmine describes software using <italic>system model objects</italic>. These objects are persistent (they have lifetimes of days or decades) and immutable (since system models act as historical records). This paper describes JStore, a distributed, replicated repository for system model objects. JStore provides <italic>robust, transactional, write-once</italic> storage.Designs are presented for the serialization, location, and replication of objects. <italic>Description procedures</italic> serialize objects for network transmission and permanent storage. An <italic>expanding ring multicast</italic> search algorithm locates saved objects. JStore replicates objects using a <italic>lazy replication</italic> algorithm built on top of the location mechanism. <italic>Decision procedures</italic> determine the replication policy used at each storage site.
[Probabilistic computation, Networks, Cross-computing tools and techniques, Software creation and management, Dependable and fault-tolerant systems and networks, Software development techniques, Physical sciences and engineering, Theory of computation, Models of computation, Applied computing, Engineering, Computer systems organization, Performance, General and reference, Network performance evaluation, Software and its engineering]
Moving structures between Smalltalk images
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
There are a number of reasons why a user might want to move data structures between Smalltalk images. Unfortunately, the facilities for doing this in the standard Smalltalk image are inadequate: they do not handle circular structures properly, for example. We have implemented a collection of Smalltalk methods that handles circular structures; in addition, these methods have a number of other advantages over those provided in the standard image. This paper is largely a discussion of the issues that arose during their design, implementation, and use.
[Type theory, Language features, Software notations and tools, Probabilistic reasoning, Information systems, Theory of computation, Theory and algorithms for application domains, Vagueness and fuzzy logic, Data types and structures, Data management systems, Mathematics of computing, Logic, Database theory, Software and its engineering, Computing methodologies, Language types, Data structures, Record storage systems, Mathematical software, Knowledge representation and reasoning, Information storage systems, Data structures and algorithms for data management, General programming languages, Data structures design and analysis, Artificial intelligence, Design and analysis of algorithms]
Development of an object-oriented DBMS
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We describe the results of developing the GemStone object-oriented database server, which supports a model of objects similar to that of Smalltalk-80. We begin with a summary of the goals and requirements for the system: an extensible data model that captures behavioral semantics, no artificial bounds on the number or size of database objects, database amenities (concurrency, transactions, recovery, associative access, authorization) and an interactive development environment. Object-oriented languages, Smalltalk in particular, answer some of these requirements. We discuss satisfying the remaining requirements in an object oriented context, and report briefly on the status of the development efforts. This paper is directed at an audience familiar with object-oriented languages and their implementation, but perhaps unacquainted with the difficulties and techniques of database system development. It updates the original report on the project [CM], and expands upon a more recent article [MDP].
[Networks, Cross-computing tools and techniques, Software creation and management, Information systems applications, Dependable and fault-tolerant systems and networks, Parallel architectures, Software development techniques, Information systems, Computer systems organization, Numerical analysis, Mathematical analysis, Computations on matrices, Data management systems, Multiple instruction, multiple data, Mathematics of computing, Performance, Database design and models, General and reference, Network performance evaluation, Architectures, Software and its engineering]
The management of changing types in an object-oriented database
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 21 ISSUE 11
1986
We examine the problem of type evolution in an object-oriented database environment. Type definitions are persistent objects in the database and as such may be modified and shared. The effects of changing a type extend to objects of the type and to programs that use objects of the type. We propose a solution to the problem through an extension of the semantic data model.A change in the interface defined by a type may result in errors when programs use new or old objects of the type. Through the use of an abstraction of the type over time, timestamping and error handling mechanisms provide support for the type designer in creating compatible versions of the type. The mechanisms are incorporated into the behavior defined by the type and are inherited via the type-lattice.
[Theory of computation, Software creation and management, Semantics and reasoning, Information systems applications, Social and professional topics, Program constructs, Type structures, Software development techniques, Information systems, Software and its engineering]
Use of object-oriented programming in a time series analysis system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
<italic>We describe the use of object-oriented programming (OOP) in the design and implementation of TSA, a system for interactive time series and spectral analysis. We show how such features of OOP as inheritance, generic messages, and decomposition of the programming problem in terms of objects have contributed to our goal of providing an extensible data analysis system. We discuss the strengths and limitations of both OOP and the particular implementation we used (Flavors on a Symbolics Lisp Machine) for our particular problem</italic>.
[Statistical graphics, Extensible languages, Language features, Language types, Software notations and tools, Development frameworks and environments, Statistical paradigms, General programming languages, Probability and statistics, Abstract data types, Mathematics of computing, Software and its engineering]
Teaching object-oriented programming with the KEE system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Successful learning of an object-oriented programming style is greatly facilitated by a flexible, window-oriented interface and a "step-by-step" instructional methodology. Specifically, students can benefit from a learning sequence moving from working with object hierarchies to working with objects with behavior to more complex problems (conditional or sequential message passing, automation of behavior). Within each area in turn, a step-by-step approach of learning by conceptualization, learning by analogy, learning by experience, and learning by reinforcement is suggested. This is demonstrated using examples from the training of the KEE&reg; Knowledge Engineering Environment&trade;.
[Software creation and management, Language features, Professional topics, Computing education, Computing methodologies, Language types, Software notations and tools, Knowledge representation and reasoning, Computing education programs, Development frameworks and environments, Theory of computation, Designing software, General programming languages, Abstract data types, Computer science education, Social and professional topics, Logic, Artificial intelligence, Software and its engineering]
Parallel programming in a virtual object space
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Sloop is a parallel language and environment that employs an object-oriented model for explicit parallel programming of MIMD multiprocessors. The Sloop runtime system transforms a network of processors into a <italic>virtual object space</italic>. A virtual object space contains a collection of objects that cooperate to solve a problem. Sloop encapsulates virtual object space semantics within the object type <italic>domain</italic>. This system-defined type provides an associative, asynchronous method by which one object gains access to another. It also provides an operation for specifying groups of objects that should, for efficiency, reside on the same physical processor, and supports exploitation of the topology of the underlying parallel machine. Domains also support the creation of <italic>indivisible</italic> objects, which provide implicit concurrency control. The encapsulation of these semantics within an object gives the programmer the power to construct an arbitrary hierarchy of virtual object spaces, facilitating debugging and program modularity. Sloop implementations are running on a bus-based multiprocessor, a hypercube multiprocessor, and on a heterogeneous network of workstations. The runtime system uses object relocation heuristics and coroutine scheduling to attain high performance.
[Computing methodologies, Language types, Software notations and tools, Parallel architectures, Runtime environments, Computer systems organization, General programming languages, Concurrent programming languages, Multiple instruction, multiple data, Concurrent computing methodologies, Software and its engineering, Architectures, Compilers]
Constraint hierarchies
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Constraints describe relations that must be maintained, and provide a useful tool for such applications as interactive simulations, algorithm animation, and graphical user interface construction. We describe a major overhaul and extension to the constraint satisfaction mechanism in ThingLab, a constraint-oriented simulation laboratory written in the Smalltalk-80 language. First, a specification is presented of <italic>constraint hierarchies</italic>. Such hierarchies include both required constraints and default constraints of differing strengths, thus adding considerable expressive power to the system. Second, an algorithm for satisfying constraint hierarchies is described. The new satisfier is substantially faster than the previous version, even though it also includes new functionality.
[Theory of computation, Software development process management, Software creation and management, Semantics and reasoning, Integrated and visual development environments, Software development methods, Software notations and tools, Program constructs, Type structures, Development frameworks and environments, Software and its engineering]
An object-oriented design system shell
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
We present a design system shell which can be used to experiment with principles of design and be used as a design tool where complex layers of information need to be specified about objects, such as in database design. The shell can be tailored to a variety of application areas. It is object-oriented in its implementation and structure. Objects and messages are used as the specification language. The basic ingredients of a rule-based production system are provided, with rules treated as objects and defined independently of the classes to which they are applied.
[Interconnect, Software creation and management, Software development methods, Language types, Software notations and tools, Computer-aided design, Information systems, Physical sciences and engineering, Integrated circuits, Applied computing, Engineering, Software development process management, Architecture (buildings), General programming languages, Data management systems, Hardware, Arts and humanities, Database design and models, Software and its engineering]
An object-oriented framework for interactive data graphics
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Ida is an object-oriented framework for interactive data graphics. It can be used for independent data examination or integrated into application user interfaces. Ida's model of graphics is composed of five basic elements: <italic>Presentations, Assemblies, Data Sources, Data Displays</italic>, and <italic>Scales</italic>. Presentations and assemblies address display layout. A sharp distinction is maintained between drawing and the management of already drawn images. Data sources are responsible for drawing while data displays are image managers. Data displays are complex structures consisting of multiple layers that may be larger than the visible regions they underlie. Scales represent coordinate transformations. An object-oriented architecture proves valuable in supporting taxonomic hierarchies with inheritance, part-whole structures for composition, message passing implementation of graphic operations and late attribute binding.
[Human-centered computing, Computing methodologies, Software notations and tools, Human computer interaction (HCI), Graphics systems and interfaces, Development frameworks and environments, Information systems, Interaction devices, Integrated and visual development environments, Graphics input devices, Computer graphics, Data management systems, Database design and models, Software and its engineering]
The Trellis programming environment
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
The Trellis programming environment supports programming in Trellis/Owl, an object-based language with multiple inheritance and compile-time type-checking. Trellis is composed of a number of integrated tools that share a common programming environment database. It is a highly interactive, easy-to-use programming environment, providing various programming aids, incremental compilation, and good debugging support. Trellis is both integrated and open-ended.Trellis was specifically designed to support the object-oriented programming methodology. Thus it provides tools to manage the use of types and inheritance. Trellis takes advantage of the strong-typing features of the Trellis/Owl language to provide more support for the programmer by keeping track of cross-references and inconsistencies in code.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Software notations and tools, Development frameworks and environments, Software and its engineering]
A pragmatic system for shared persistent objects
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
This paper describes a system for sharing information in the form of objects among users of the Smalltalk-80 programming environment. The system, called Coral3, is pragmatic in that it was developed to meet the needs of specific applications. This paper describes the expectations for the system, presents factors influencing the design, outlines the implementation of Coral3, and raises questions about object-oriented database systems in general.
[Collaborative and social computing systems and tools, Collaborative and social computing, Computing / technology policy, Human-centered computing, Language types, World Wide Web, Information retrieval, Software notations and tools, Development frameworks and environments, Information systems, Database management system engines, Search engine architectures and scalability, General programming languages, Web searching and information discovery, Data management systems, Social and professional topics, Government technology policy, Peer-to-peer retrieval, Software and its engineering]
Class modification in the GemStone object-oriented DBMS
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
We are currently designing a class modification methodology for GemStone. We describe the current status of the design. We choose from two basic approaches and then introduce those aspects of GemStone necessary for an understanding of the paper. After defining a set of invariants for GemStone databases, we discuss specific class modification operations in terms of maintaining these invariants. We next discuss several issues that impact class modification. These issues include concurrency and authorization, and lead to difficult choices.
[Data management systems, Information systems, Database management system engines]
Composite object support in an object-oriented database system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Many applications in such domains as computer-aided design require the capability to define, store and retrieve as a single unit a collection of related objects known as a composite object. A composite object explicitly captures and enforces the IS-PART-OF integrity constraint between child and parent pairs of objects in a hierarchical collection of objects. Further, it can be used as a unit of storage and retrieval to enhance the performance of a database system.This paper provides a formal definition of the semantics of composite objects within an object-oriented data model, and describes their use as units of integrity control, storage and retrieval, and concurrency control in a prototype object-oriented database system we have implemented.
[Theory of computation, Semantics and reasoning, Semantics, Program semantics, Data management systems, Formal language definitions, Software notations and tools, Database design and models, Information systems, Database management system engines, Software and its engineering]
An information system based on distributed objects
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
The <italic>Telesophy system</italic> is intended to provide transparent access to all of a community's online information. The scale of the system requires that it be distributed across many machines via a network; the multiple types and formats of the information require that it be a multimedia system. We describe a prototype that uses objects to represent, query, display, and edit information. A two-level storage system is used to store the objects on multiple servers; queries are processed by indexing servers layered on top of the storage system. New media types and new indexing schemes can be added simply by defining new classes within the existing framework.
[Integrated and visual development environments, Information storage systems, General programming languages, Language types, Information retrieval, Software notations and tools, Development frameworks and environments, Information systems, Software and its engineering]
Delegation is inheritance
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Inheritance and delegation are alternate methods for incremental definition and sharing. It has commonly been believed that delegation provides a more powerful model. This paper demonstrates that there is a "natural" model of inheritance which captures all of the properties of delegation. Independently, certain constraints on the ability of delegation to capture inheritance are demonstrated. Finally, a new framework which fully captures both delegation and inheritance is outlined, and some of the ramifications of this hybrid model are explored.
[Theory of computation, Models of computation, Data management systems, Formal language definitions, Software notations and tools, Formal languages and automata theory, Logic, Database design and models, Information systems, Software and its engineering]
Concepts and experiments in computational reflection
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
This paper brings some perspective to various concepts in computational reflection. A definition of computational reflection is presented, the importance of computational reflection is discussed and the architecture of languages that support reflection is studied. Further, this paper presents a survey of some experiments in reflection which have been performed. Examples of existing procedural, logic-based and rule-based languages with an architecture for reflection are briefly presented. The main part of the paper describes an original experiment to introduce a reflective architecture in an object-oriented language. It stresses the contributions of this language to the field of object-oriented programming and illustrates the new programming style made possible. The examples show that a lot of programming problems that were previously handled on an ad hoc basis, can in a reflective architecture be solved more elegantly.
[Theory of computation, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
Metaclasses are first class: The ObjVlisp Model
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
This paper shows how an attempt at a uniform and reflective definition resulted in an open-ended system supporting ObjVlisp, which we use to simulate object-oriented language extensions.We propose to unify Smalltalk classes and their terminal instances. This unification allows us to treat a class as a "first class citizen", to give a circular definition of the first metaclass, to access to the metaclass level and finally to control the instantiation link. Because each object is an instance of another one and because a metaclass is a real class inheriting from another one, the metaclass links can be created indefinitely.This uniformity allows us to define the class variables at the metalevel thus suppressing the Smalltalk-80 ambiguity between class variables and instance variables: in our model the instance variables of a class are the class variables of its instances.
[Computing methodologies, Language types, Software notations and tools, Formal languages and automata theory, Theory of computation, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Natural language processing, Artificial intelligence, Software and its engineering]
Dimensions of object-based language design
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
The design space of object-based languages is characterized in terms of objects, classes, inheritance, data abstraction, strong typing, concurrency, and persistence. Language classes (paradigms) associated with interesting subsets of these features are identified and language design issues for selected paradigms are examined. Orthogonal dimensions that span the object-oriented design space are related to non-orthogonal features of real languages. The self-referential application of object-oriented methodology to the development of object-based language paradigms is demonstrated.Delegation is defined as a generalization of inheritance and design alternatives such as non-strict, multiple, and abstract inheritance are considered. Actors and prototypes are presented as examples of classless (delegation based) languages. Processes are classified by their degree of internal concurrency. The potential inconsistency of object-oriented sharing and distributed autonomy is discussed, suggesting that compromises between sharing and autonomy will be necessary in designing strongly typed object-oriented distributed database languages.
[Theory of computation, Designing software, Software creation and management, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
Object-oriented development in an industrial environment
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Object-oriented programming is a promising approach to the industrialization of the software development process. However, it has not yet been incorporated in a development method for large systems. The approaches taken are merely extensions of well-known techniques when 'programming in the small' and do not stand on the firm experience of existing developments methods for large systems. One such technique called block design has been used within the telecommunication industry and relies on a similar paradigm as object-oriented programming. The two techniques together with a third technique, conceptual modeling used for requirement modeling of information systems, have been unified into a method for the development of large systems.
[Management of computing and information systems, Operations research, Software creation and management, Professional topics, Computer-aided design, Industry and manufacturing, Physical sciences and engineering, Applied computing, Engineering, Designing software, Architecture (buildings), Software management, Command and control, Arts and humanities, Social and professional topics, Software and its engineering]
Using objects to design and build radar ESM systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
This paper describes the application of object-oriented programming to the design of a multiprocessor ESM testbed. The ESM testbed uses an object-oriented development environment which integrates Smalltalk and C language tools with the Harmony real-time operating system in a shared memory multiprocessor. All development for an application is done using personal computers which are themselves processors in the real-time testbed. We first discuss two aspects of the ESM testbed: a framework for investigating ESM signal processing algorithms based on an object-oriented emitter database and blackboard objects which implement probabilistic reasoning; and an object-oriented ESM simulation environment which illustrates the use of object-oriented techniques for the development of complex real-time systems. In the second part of the paper we describe our software engineering approach and tools. Throughout the paper, the role played by object-oriented programming in the design of hybrid multiprocessors is highlighted.
[Communication hardware, interfaces and storage, Personal computers and PC applications, Software creation and management, Special purpose systems, Computing methodologies, Microcomputers, Computers in other domains, Graphics systems and interfaces, Designing software, Applied computing, Computer systems organization, Computer graphics, Hardware, Signal processing systems, Other architectures, Software and its engineering, Architectures]
Object-oriented programming in Smalltalk and ADA
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Though Ada and Modula-2 are not object-oriented languages, an object-oriented viewpoint is crucial for effective use of their module facilities. It is therefore instructive to compare the capabilities of a modular language such as Ada with an archetypal object-oriented language such as Smalltalk. The comparison in this paper is in terms of the basic properties of encapsulation, inheritance and binding, with examples given in both languages. This comparison highlights the strengths and weaknesses of both types of languages from an object-oriented perspective. It also provides a basis for the application of experience from Smalltalk and other object-oriented languages to increasingly widely used modular languages such as Ada and Modula-2.
[General programming languages, Language types, Software notations and tools, Software and its engineering]
Experience with CommonLoops
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
CommonLoops is an object-oriented language embedded in Common Lisp. It is one of two such languages selected as starting points for the Common Lisp Object System (CLOS) which is currently being designed as a standard object-oriented extension to Common Lisp. This paper reports on experiences using the existing Portable CommonLoops (PCL) implementation of CommonLoops. The paper is divided into two parts: a report on the development of a window system application using the CommonLoops programming language, and a description of the implementation of another object-oriented language (CommonObjects) on top of the CommonLoops metaclass kernel, paralleling the two aspects of CommonLoops: the programming language and the metaclass kernel. Usage of the novel features in CommonLoops is measured quantitatively, and performance figures comparing CommonLoops, CommonObjects on CommonLoops, and the native Lisp implementation of CommonObjects are presented. The paper concludes with a discussion about the importance of quantitative assessment for programming language development.
[Procedures, functions and subroutines, General programming languages, Language features, Language types, Software notations and tools, Software and its engineering]
Self: The power of simplicity
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Self is a new object-oriented language for exploratory programming based on a small number of simple and concrete ideas: prototypes, slots, and behavior. Prototypes combine inheritance and instantiation to provide a framework that is simpler and more flexible than most object-oriented languages. Slots unite variables and procedures into a single construct. This permits the inheritance hierarchy to take over the function of lexical scoping in conventional languages. Finally, because Self does not distinguish state from behavior, it narrows the gaps between ordinary objects, procedures, and closures. Self's simplicity and expressiveness offer new insights into object-oriented computation.
[Communications management, Operating systems, Message passing, General programming languages, Language features, Data types and structures, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
Active objects in hybrid
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Most object-oriented languages are strong on reusability or on strong-typing, but weak on concurrency. In response to this gap, we are developing <italic>Hybrid</italic>, an object-oriented language in which objects are the active entities. Objects in Hybrid are organized into <italic>domains</italic>, and concurrent executions into <italic>activities</italic>. All object communications are based on remote procedure-calls. Unstructured <italic>sends</italic> and <italic>accepts</italic> are forbidden. To this the mechanisms of <italic>delegation</italic> and <italic>delay queues</italic> are added to enable switching and triggering of activities. Concurrent subactivities and atomic actions provided for compactness and simplicity. We show how solutions to many important concurrent problems, such a pipelining, constraint management and "administration" can be compactly expressed using these mechanisms.
[Computing methodologies, Language types, Software notations and tools, Concurrency control, Contextual software domains, Operating systems, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software organization and properties, Software and its engineering, Process management]
MELDing data flow and object-oriented programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
MELD combines concepts from data flow and object-oriented programming languages in a unique approach to tool reusability. MELD provides three units of abstraction - equations, classes and features - that together allow sufficient options for granularity and encapsulation to support the implementation of reusable tools and the composition of existing tools in parallel (<italic>i.e.</italic>, interleaved) as well as in series.
[Software design techniques, Software creation and management, Data flow languages, Reusability, Language features, Language types, Software notations and tools, Software development techniques, Software implementation planning, Designing software, Software development process management, General programming languages, Software and its engineering]
Modules and type checking in PL/LL
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
The type system of a programming language system PL/LL is described. PL is a simple object oriented programming language and LL is a language for composing PL modules into programs. The goals of the PL/LL system are to enable the programming of efficient object-oriented computations and to provide the powerful linking language LL for facilitating the construction of large programs. The goal of the type system is to ensure efficient and secure object handling through a combination of static and dynamic type checking, and to preserve this property across module boundaries. The solution is based on (i) the module and linking concepts of LL, (ii) a language construct in PL for the safe creation of linked data structures, and (iii) a limited form of type polymorphism and type unification.
[General programming languages, Language features, Language types, Software notations and tools, Software and its engineering]
CLAM- an open system for graphical user interfaces
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
CLAM is an object-oriented system designed to support the building of extensible graphical user interfaces. CLAM provides a basic windowing environment with the ability to extend its functions using dynamically loaded C++ classes. The dynamically loaded classes allow for performance tuning (by transparently loading the class in either the client or the CLAM server) and for sharing of new functions.In addition to the traditionally layering of output abstractions, CLAM allows the programmer to easily layer input abstractions. The input functions include providing distributed upward calls through the layers, an light weight processes to support asynchronous input.CLAM is currently running under 4.3BSD UNIX on a MicroVax-II workstation.
[Extensible languages, Language features, Special purpose systems, Computing methodologies, Language types, Software notations and tools, Graphics systems and interfaces, Development frameworks and environments, Computer systems organization, Integrated and visual development environments, General programming languages, Computer graphics, Abstract data types, Other architectures, Software and its engineering, Architectures]
Painless panes for Smalltalk windows
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Current windowing systems (i.e., Macintosh, Smalltalk) give the user flexibility in the layout of their computer display, but tend to discourage construction of new window types. Glazier is a knowledge-based tool that allows users to construct and test novel or special purpose windows for Smalltalk applications.The use of Glazier does not require understanding Smalltalk's windowing framework (Goldberg, 1984; Goldberg &amp; Robson, 1983). As a new window is specified, Glazier automatically constructs the necessary Smalltalk class, and methods (programs). Windows are interactively specified in a Glazier window - the user specifies type and location of panes through mouse motions. Panes can contain text, bit-maps, lists, dials, gauges, or tables. The behavior of a pane is initially determined by Glazier as a function of the pane type and related defaults. These default behaviors allow the window to operate, but do not always display the application information desired. In that case, the user can fix the window's behavior by further specification. Such alterations require only knowledge of the application, not of the windowing system.Glazier allows the prototyping and development of full-fledged Smalltalk windows, and allows a flexibility that will change window usage in two ways. First, it will allow end users to construct special purpose windows for viewing data from an application in manners unanticipated by the system designers. Second, system developers will be encouraged to prototype and evaluate many window configurations before settling on a final choice. Both alternatives will result in windows that are more satisfying to the end-user.The makeup of Smalltalk or Macintosh-style windows is typically viewed as a fixed component of the computer interface. Windows are provided to the end user by the system designer and cannot be customized. Sadly, users are not allowed the flexibility of their window contents that windows allow for display contents. Thus, the user is forced to use windows that may not precisely fit the needs for his or her use of the application.Of course, the option of adding new windows is available to some users. A <italic>skilled</italic> Smalltalk user can construct a special-purpose window in an afternoon. Completion of such a task requires detailed knowledge of Smalltalk's model-view-controller (MVC) paradigm (Goldberg, 1984; Goldberg &amp; Robson, 1983). This is perceived as an inconvenient, tedious task and is hardly something a novice Smalltalk programmer can or should attempt.This paper discusses Glazier, a tool that encapsulates knowledge about building Smalltalk windows, and assists a user in developing new Smalltalk windows. Glazier works as an assistant, relieving the user from the burden of thinking about windowing details. Instead, the user needs only to understand how to operate the data structures for the application being displayed by the window. Window development now becomes a symbiotic process, Glazier provides the knowledge on how to build the window and the user provides knowledge about how the application is used and how the window should behave.There are a numerous other systems to support interface development in a like manner. Bass (1985) describes a system for developing VT100 style interfaces on top of base-level applications. The system supports a wide range of user needs, but cannot be configured dynamically by the user. The Trillium System (Henderson, 1986) supports prototyping of copying machine interfaces and allows designers to build and test control panels. Other user interface management systems support construction of front ends for applications (Hayes, Szekely, &amp; Lerner, 1985). None of these systems, however, has provided the user or developer with a dynamic environment for building generic windows. Glazier allows a user to build a wide range of window types, and use them as they are being built.This paper will discuss the operation of the Glazier, the method for constructing windows, and finally the implications of this new window construction technique.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Integrated and visual development environments, General programming languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Logical composition of object-oriented interfaces
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
This paper describes an approach to object-oriented interface design that goes beyond mere object decomposition. In our user interface management system we use logic and filters to declaratively specify and control a space of ways that objects may be composed to create interfaces. A filter is a package of constraints and associated typed objects that express the relationship of data and representation objects.Conceptually our system is completely based on constraints. Filters provide the high bandwidth constraints to maintain the components of the direct-manipulation interface while the logic forms the low bandwidth constraints to combine and provide communication between these components. The use of Horn-clause logic to compose separate interface objects facilitates both the distribution of computation onto multiple processors and the generation of multiple views of data. Intelligent backtracking implemented in the logic allows for user- and system-initiated <italic>undo</italic> operations to correct errors and/or try alternative approaches to a problem. We illustrate the power and flexibility of this approach by describing a floor layout and design system.
[Software design techniques, Management of computing and information systems, Project and people management, Software creation and management, Language features, Professional topics, Software notations and tools, Program constructs, Theory of computation, Software implementation planning, Designing software, Software development process management, Semantics and reasoning, General programming languages, Project management techniques, Programming logic, Program reasoning, Social and professional topics, Logic, Software and its engineering]
Maniplicons in ThinkerToy
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
ThinkerToy is a graphical environment for modeling decision support problems. It provides a tableau on which such problems as landscape planning, service scheduling, and statistical analysis can be modeled and analyzed. Normally, complex mathematical and statistical modeling techniques are needed to perform meaningful analysis. ThinkerToy uses graphical icons with concrete physical properties to replace mathematical relationships and properties. The key construct in this methodology is the ManiplIcon: an icon which is not just a pictorial representation, but also a semantic tool for building models which homorphically represent semi-structured problems.
[Decision support systems, Operations research, Special purpose systems, Information systems applications, Computing methodologies, Decision analysis, Graphics systems and interfaces, Information systems, Applied computing, Computer systems organization, Computer graphics, Other architectures, Architectures]
The design and implementation of distributed Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Distributed Smalltalk (DS) is an implementation of Smalltalk that allows objects on different machines to send and respond to messages. It also provides some capability for sharing objects among users. The distributed aspects of the system are largely user transparent and preserve the reactive quality of Smalltalk objects. Distributed Smalltalk is currently operational on a network of Sun workstations. The implementation includes an incremental distributed garbage collector and support for remote debugging, access control, and object mobility. This paper concentrates on the important design issues encountered and some of the more interesting implementation details. Performance measurements of the current implementation are included.
[Communications management, Language types, Software notations and tools, Contextual software domains, Distributed systems organizing principles, Software system structures, Organizing principles for web applications, Operating systems, Message passing, General programming languages, Software organization and properties, Software and its engineering]
Transparent forwarding: First steps
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Traditional object-oriented systems tend to be single-user. As we move from personal to interpersonal computing, we must look for ways to extend our programming paradigms. This research extends the Smalltalk-80 system to send messages transparently to objects residing on remote machines. We discuss two models for remote message sends, describe our current implementation, and suggest areas for future research.
[Communications management, Operating systems, Message passing, General programming languages, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
Retrofitting objects
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
<italic>I present the results of an experiment in retrofitting objects into an existing system. I describe a technology, based on automatic redefinition of existing functions, that allowed alternative implementations of the fundamental data types of the KEE&trade; knowledge-based system building tool. This technology is applicable in environments where the system's procedures can be subject to programmatic manipulation. It allows the retrofitting of objects into the implementations of other existing systems. The experience of retrofitting objects into KEE provides insight into the issues of the interaction of semantic classes and data representation and granularity in object-based systems.</italic><supscrpt>1</supscrpt>
[Communications management, Language features, Computing methodologies, Software notations and tools, Knowledge representation and reasoning, Contextual software domains, Theory of computation, Operating systems, Message passing, General programming languages, Data types and structures, Abstract data types, Logic, Artificial intelligence, Software organization and properties, Software and its engineering]
BrouHaHa- A portable Smalltalk interpreter
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
BrouHaHa is a portable implementation of the Smalltalk-80 virtual machine interpreter. It is a more efficient redesign of the standard Smalltalk specification, and is tailored to suit conventional 32 bit microprocessors. This paper presents the major design changes and optimization techniques used in the BrouHaHa interpreter. The interpreter runs at 30% of the speed of the Dorado on a Sun 3/160 workstation. The implementation is portable because it is written in C.
[Software creation and management, Reusability, General programming languages, Interpreters, Language types, Software notations and tools, Software development techniques, Software and its engineering, Compilers]
INSIST: Interactive Simulation in Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
A functional simulator/editor for VLSI design has been implemented in the Smalltalk-80<supscrpt>1</supscrpt> system. Users can explore their designs in an highly interactive and graphical manner with "close-to-reality" tools. The traditional sequence of editing, compiling and simulating the circuit is avoided. During editing, functional Modules can immediately respond to new connections. The simulator, called INSIST, strongly supports hierarchical simulation and design up to gate level. Hardware descriptions of the design can be generated for other CAD systems. From these descriptions layout has been generated. A RISC chip was entered and simulated at three hierarchical levels containing more than 50 Modules.
[Language types, Software notations and tools, Simulation and emulation, Parallel architectures, Very large scale integration design, Development frameworks and environments, Functional verification, Computer systems organization, Very long instruction word, Reduced instruction set computing, General programming languages, Complex instruction set computing, Serial architectures, Hardware validation, Hardware, Software and its engineering, Architectures]
Opus: A Smalltalk production system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Opus is a tool for rule-based programming which integrates a production system paradigm with the Smalltalk-80 environment. Opus currently provides a data-driven production system that allows the programmer considerable freedom, including access to the full functionality of the Smalltalk-80 language, and the ability to match rules with arbitrary objects in the environment. We present the goals for the design, a description of the system and its implementation, and discuss issues raised by this approach.
[Theory of computation, General programming languages, Context specific languages, Computing methodologies, Language types, Software notations and tools, Logic, Knowledge representation and reasoning, Artificial intelligence, Development frameworks and environments, Software and its engineering]
OTM: Applying objects to tasks
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
OTM is a concurrent object language presently being implemented at the University of Toronto. It provides a novel, simple and powerful way of structuring <italic>tasks</italic> or collections of operations. This paper describes the concurrency control features of OTM, which include external termination of tasks. An example demonstrates how the language can be used to cleanly and concisely control cooperating objects.
[Procedures, functions and subroutines, Language features, Enterprise information systems, Professional topics, Software notations and tools, Contextual software domains, Information systems, Enterprise computing, Operating systems, Enterprise applications, Concurrent programming languages, Social and professional topics, Software organization and properties, Software and its engineering, Automation, Computing methodologies, Language types, Information systems applications, Concurrency control, Computing and business, Applied computing, General programming languages, Concurrent computing methodologies, Process management]
Some experiments in object-oriented simulation
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Discrete event simulation has been a constant source of inspiration for language designers. The present interest in Object-Oriented Programming (O.O.P.) can be traced back to the Simula 67 language. In return, simulation languages are currently getting back many advantages from the ongoing research in O.O.P. One of the main present research trends is the possibility of concurrently executing a simulation program composed of a set of interacting and communicating objects. Conditions which will make this possible are discussed together with some induced problems. More precisely this paper presents some experiments in object-oriented simulation that reveal the great flexibility of the Smalltalk-80<supscrpt>1</supscrpt> programming system for building evaluation environments.
[Modeling and simulation, Simulation types and techniques, Simulation support systems, Computing methodologies, Simulation languages]
Experience and evolution of concurrent Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
ConcurrentSmalltalk is an object-oriented concurrent programming language/system which has been running since late 1985. ConcurrentSmalltalk has the following features:<list><item>Upper-compatibility with Smalltalk-80.</item><item>Asynchronous method calls and <italic>CBox</italic> objects yield concurrency.</item><item>Atomic objects have the property of running one at a time so that it can serialize the many requests sent to it.</item></list>Through experience in writing programs, some disadvantages have become apparent related to concurrency control and the behavior of a block context. In this paper, these issues are re-examined in detail, and then the evolution of the solutions for overcoming these shortcomings is described along with the model of computation in ConcurrentSmalltalk. New features are explained with an example program. The implementation of the ConcurrentSmalltalk virtual machine is also presented along with the evaluation of it.
[Operating systems, General programming languages, Language types, Software notations and tools, Concurrency control, Contextual software domains, Software organization and properties, Software and its engineering, Process management]
RAPID: Prototyping control panel interfaces
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
RAPID is a design environment to support human factors specialists in designing user interfaces for small control panels. RAPID permits modeling of both the appearance and behavior of operator interfaces. Its main goal is to allow exploration of a greater number of design alternatives by decreasing the time and effort required to generate and evaluate those alternatives. It is a graphically-based system intended to be used by non-programmers. RAPID is implemented in Smalltalk-80.
[Software prototyping, Software creation and management, Operations research, Software development methods, Human-centered computing, Computing methodologies, Computers in other domains, Software notations and tools, Human computer interaction (HCI), Computer-aided design, Industry and manufacturing, Software development techniques, Development frameworks and environments, Physical sciences and engineering, Software development process management, Applied computing, Engineering, Architecture (buildings), Command and control, Computer graphics, Arts and humanities, Rapid application development, Software and its engineering]
Producer: A tool for translating Smalltalk-80 to Objective-C
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Source to source translation tools provide a way of integrating the strengths of production programming environments like C/UNIX&trade; with rapid prototyping environments like Smalltalk-80&trade; into a comprehensive hybrid environment that spans more of the software development life-spiral than ever before. This paper describes a tool-assisted process for translating Smalltalk-80 programs into Objective-C&trade;, and shows how the tool, called Producer, is used in practice. To assist others in using this translation tool, we have made Producer publicly available without charge on USENET.
[Software design techniques, Software creation and management, Language types, Software notations and tools, Development frameworks and environments, Software implementation planning, Designing software, Software development process management, Translator writing systems and compiler generators, General programming languages, Software and its engineering, Compilers]
Combining language and database advances in an object-oriented development environment
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
Object-oriented languages generally lack support for persistent objects-that is objects that survive the process or programming session. On the other hand, database systems lack the expressibility of object-oriented languages. Both persistence and expressibility are necessary for production application development.This paper presents a brief overview of VBASE, an object-oriented development environment that combines a procedural object language and persistent objects into one integrated system. Language aspects of VBASE include strong datatyping, a block structured schema definition language, and parameterization, or the ability to type members of aggregate objects. Database aspects include system support for one-to-one, one-to-many, and many-to-many relationships between objects, an inverse mechanism, user control of object clustering in storage for space and retrieval efficiency, and support for trigger methods.Unique aspects of the system are its mechanisms for custom implementations of storage allocation and access methods of properties and types, and free operations, that is operations that are not dispatched according to any defined type.During the last several years, both languages and database systems have begun to incorporate object features. There are now many object-oriented programming languages. [Gol1983, Tes1985, Mey 1987, Cox 1986, Str 1986]. Object-oriented database management systems are not as prevalent yet, and sometimes tend to use different terms (Entity-Relationship, Semantic Data Model), but they are beginning to appear on the horizon [Cat1983, Cop1984, Ston1986, Mylo1980]. However, we are not aware of any system which combines both language and database features in a single object-oriented development platform. This is essential since a system must provide both complex data management and advanced programming language features if it is to be used to develop significant production software systems. Providing only one or the other is somewhat akin to providing half a bridge: it might be made structurally sound, perhaps, but it is not particularly useful to one interested in getting across the river safely.Object-oriented languages have been available for many years. The productivity increases achievable through the use of such languages are well recognized. However, few serious applications have been developed using them. One reason has been performance, though this drawback is being eliminated through the development of compiled object languages. The remaining major negative factor, in our view, is the lack of support for persistence; the lack of objects that survive the processing session and provide object sharing among multiple users of an application.Database management systems, in contrast, suffer from precisely the opposite problem. While having excellent facilities for managing large amounts of data stored on mass media, they generally support only limited expression capabilities, and no structuring facilities.Both language and database systems usually solve this problem by providing bridges between the systems. Thus the proliferation of 'embedded languages', allowing language systems to access database managers. These bridges are usually awkward, and still provide only restricted functionality. Both performance and safety can be enhanced through a tighter coupling between the data management and programming language facilities.It is this lack of a truly integrated system which provided our inspiration at Ontologic, Inc. This paper reviews Ontologic's VBASE Integrated Object System and describes how it combines language and database functionality.
[Language features, Language types, Software notations and tools, Development frameworks and environments, Information systems, Database query languages (principles), Theory of computation, Theory and algorithms for application domains, General programming languages, Data management systems, Database design and models, Database theory, Query languages, Software and its engineering]
Issues in the design of object-oriented database programming languages
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
We see a trend toward extending object-oriented languages in the direction of databases, and, at the same time, toward extending database systems with object-oriented ideas. On the surface, these two activities seem to be moving in a consistent direction. However, at a deeper level, we see difficulties that may inhibit their ending up at the same point. We feel that many of these difficulties are a result of the underlying assumptions that are inherent in the fields of programming language and database systems research. Many of these assumptions are historical and contribute to a set of cultural biases that often prevent the two communities from interacting as effectively as possible.The purpose of this paper is to try to uncover some of the cultural presuppositions that have inhibited development of a fully integrated database programming language. We have identified database and language features that seem to be difficult to reconcile. We try to uncover the basic problems in these two areas that these features were intended to solve. In order to resolve these problems, we attempt to distinguish fundamental differences from historical artifacts.
[Language features, Language types, Software notations and tools, Program constructs, Information systems, Database query languages (principles), Theory of computation, Theory and algorithms for application domains, Semantics and reasoning, General programming languages, Data types and structures, Data management systems, Abstract data types, Database theory, Query languages, Software and its engineering]
Intermedia: A case study of the differences between relational and object-oriented database systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
<italic>This paper compares two approaches to meeting the data handling requirements of Intermedia, a hypermedia system developed at the Institute for Research in Information and Scholarship at Brown University. Intermedia, though written using an object-oriented programming language, relies on a traditional relational database management system for data storage and retrieval. We examine the ramifications of replacing the relational database with an object-oriented database. We begin by describing the important characteristics each database system. We then describe Intermedia and give an overview of its architecture and its data handling requirements. We explain why and how we used a relational database management system and the problems that we encountered with this system. We then present the design of an object-oriented database schema for Intermedia and compare the relational and object-oriented database management system approaches</italic>.
[Data management systems, Database design and models, Information systems]
Relations as semantic constructs in an object-oriented language
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
The relation as a semantic construct in an object-oriented language clearly expresses associations and constraints among objects which would otherwise be buried in implementation code. The externalization of references between objects permits a symmetric, non-redundant conceptual model which merits its own special notation and predefined operations. The object-relation model, which combines the object-oriented model with the entity-relationship model from data base theory, is particularly useful for designing and partitioning systems of interrelated objects. Relations can be implemented efficiently using hash tables. The model proposed here has been fully implemented in an object-oriented language written by the author which has been used to implement several production applications.
[Language features, Software notations and tools, Program constructs, Information systems, Theory of computation, Semantics and reasoning, General programming languages, Program semantics, Data management systems, Abstract data types, Database design and models, Software and its engineering]
A law-based approach to object-oriented programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 22 ISSUE 12
1987
The central idea behind this paper is that the discipline governing the exchange of messages between objects should be specifiable by the programmer in the form of an explicit <italic>law of the system</italic>. We show how, starting from a very primitive foundation, which presumes neither encapsulation nor inheritance, one can establish various forms of both, as well as other useful disciplines, simply by means of appropriate laws.
[Communications management, Language features, Software notations and tools, Formal languages and automata theory, Contextual software domains, Program constructs, Theory of computation, Semantics and reasoning, Operating systems, Message passing, General programming languages, Formal language definitions, Abstract data types, Software organization and properties, Software and its engineering]
TS: an optimizing compiler for smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
TS (Typed Smalltalk) is a portable optimizing compiler that produces native machine code for a typed variant of Smalltalk, making Smalltalk programs much faster. This paper describes the structure of TS, the kinds of optimizations that it performs, the constraints that it places upon Smalltalk, the constraints placed upon it by an interactive programming environment, and its performance.
[General programming languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Fast dispatch mechanisms for stock hardware
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
None
[Procedures, functions and subroutines, General programming languages, Language features, Language types, Software notations and tools, Software and its engineering]
A user interface toolkit based on graphical objects and constraints
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
One of the most difficult aspects of creating graphical, direct manipulation user interfaces is managing the relationships between the graphical objects on the screen and the application data structures that they represent. Coral (Constraint-based Object-oriented Relations And Language) is a new user interface toolkit under development that uses efficiently-implemented constraints to support these relationships. Using Coral, user interface designers can construct interaction techniques such as menus and scroll bars. More importantly, Coral makes it easy to construct direct-manipulation user interfaces specialized to particular applications. Unlike previous constraint-based toolkits, Coral supports defining constraints in the abstract, and then applying them to different object instances. In addition, it provides iteration constructs where lists of items (such as those used in menus) can be constrained as a group. Coral has two interfaces: a declarative interface that provides a convenient way to specify the desired constraints, and a procedural interface that will allow a graphical user interface management system (UIMS) to automatically create Coral calls.
[Integrated and visual development environments, General programming languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
ET++-an object oriented application framework in C++
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
ET++ is an object-oriented application framework implemented in C++ for a UNIX&dagger; environment and a conventional window system. The architecture of ET++ is based on MacApp and integrates a rich collection of user interface building blocks as well as basic data structures to form a homogeneous and extensible system. The paper describes the graphic model and its underlying abstract window system interface, shows composite objects as a substrate for declarative layout specification of complex dialogs, and presents a model for editable text allowing the integration of arbitrary interaction objects.
[Software design techniques, Software creation and management, Language types, Software notations and tools, Contextual software domains, Software implementation planning, Designing software, Software development process management, Operating systems, General programming languages, Software organization and properties, Software and its engineering]
Transportable applications environment (TAE) plus experiences in "Object"-ively modernizing a user interface environment
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
This paper describes the evolution of the Transportable Applications Executive (TAE) (developed at NASA/Goddard Space Flight Center) from a traditional procedural menu and command-oriented system to an object-oriented, modeless user interface management system, known as TAE Plus. The impetus for developing this environment and early experiments which led to its current implementation are addressed. The current version of TAE Plus provides design and prototyping functions, working in tandem with a mature application management system. The main components are (1) a user interface designers' WorkBench that allows an application developer to interactively layout an application screen and define the static and/or dynamic areas of the screen; (2) an application programmer subroutine package that provides runtime services used to display and control WorkBench-designed "interaction objects" on the screen; and (3) an extension to the existing TAE command language that provides commands for displaying and manipulating interaction objects, thus providing a means to quickly prototype an application's user interface. During TAE Plus development, many design and implementation decisions were based on the state-of-the-art within graphics workstations, windowing systems and object-oriented programming languages, and this paper shares some of the problems and issues experienced during implementation. Some of the topics discussed include: lessons learned in using the Smalltalk&trade; language to prototype the initial WorkBench; why C++ was selected (over other languages) to build the WorkBench; and experiences in using X Window System&trade; and Stanford's InterViews object library. The paper concludes with open issues and a description of the next steps involved in implementing the "totally modern" TAE.
[Integrated and visual development environments, Software notations and tools, Development frameworks and environments, Software and its engineering]
An integrated color smalltalk-80 system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
The Smalltalk-80&trade; user interface and graphics model are based on monochromatic graphics. One natural step in the evolution of the Smalltalk-80 system is the addition of color. This paper describes an implementation of color Smalltalk. Classes have been defined to manipulate visual color models and colored graphics objects. The extensive collaboration between classes which describe color, classes which perform basic graphics operations, and classes in the user interface is explored. Issues in the design and implementation are examined. Potential future directions for object-oriented color systems are discussed.
[Special purpose systems, Language types, Computing methodologies, Software notations and tools, Graphics systems and interfaces, Development frameworks and environments, Computer systems organization, Integrated and visual development environments, General programming languages, Computer graphics, Other architectures, Software and its engineering, Architectures]
A smalltalk window system based on constraints
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
We describe the design of a constraint-based window system for Smalltalk. This window system uses constraints to specify attributes of windows and relationships between them. Three classes of constraints are supported, one of which is implicit and not available for general use. The system extends the current Smalltalk system, providing support for both fixed-size and fixed-scale windows. It also provides the capability to dynamically reorganize the layout of a window. A goal of the design is to produce a system with real-time response that is fast enough to be substituted for the existing system. A prototype with response times of approximately 1/4 second has been implemented to demonstrate the feasibility of the design as well as to point out several important optimizations.
[Integrated and visual development environments, General programming languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Configuring stand-alone smalltalk-80 applications
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
The Smalltalk-80&trade; programming environment, though powerful for prototyping applications, does not have any mechanisms for constructing a stand-alone version of an application. Traditionally, the application is bundled with an image including the entire development environment. Production applications frequently require that the only interface visible to the end user be that of the application. A common misperception among Smalltalk-80 application developers is that it is impossible to:<list><item>develop and deliver applications containing proprietary algorithms,</item><item>prevent inspection and modification of the application,</item><item>separate the development environment from the delivered application,</item><item>provide annotation of the application classes and methods without actually revealing the source code to the end user.</item></list>In this paper, we introduce various techniques and mechanisms for meeting these requirements.
[Access protection, Software functional properties, Language types, Software and application security, Software notations and tools, Correctness, Development frameworks and environments, Integrated and visual development environments, Security and privacy, General programming languages, Software security engineering, Software organization and properties, Software and its engineering]
Building a backtracking facility in smalltalk without kernel support
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
Languages like Snobol, Prolog, and Icon were designed with backtracking facilities from the outset and these facilities are deeply intertwined with the implementation. Retrofitting a backtracking facility in a language that wasn't designed for it has never been achieved. We report on an experiment to retrofit Smalltalk with a backtracking facility. The facility is provided through a small number of primitives written in the language (no modifications to the kernel were made). The ability to do this is a direct result of the power provided by the objectification of contexts.
[Theory of computation, Backtracking, General programming languages, Language types, Software notations and tools, Algorithm design techniques, Design and analysis of algorithms, Software libraries and repositories, Software and its engineering]
A overview of modular smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
This paper introduces the programming language Modular Smalltalk, a descendant of the Smalltalk-80 programming language. Modular Smalltalk was designed to support teams of software engineers developing production application programs that can run independently of the environment in which they are developed. We first discuss our motivation for designing Modular Smalltalk. Specifically, we examine the properties of Smalltalk-80 that make it inappropriate for our purposes. We then present an overview of the design of Modular Smalltalk, with an emphasis on how it overcomes these weaknesses.
[Management of computing and information systems, Software creation and management, General programming languages, Software management, Language features, Language types, Professional topics, Software notations and tools, Social and professional topics, Modules / packages, Software and its engineering]
Orwell-a configuration management system for team programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
In this paper, we describe the design and implementation of Orwell, a configuration management tool for multiperson Smalltalk projects. Although the system described has been implemented for Smalltalk, the design is applicable to other languages such as C++, Objective-C or ADA. Smalltalk is well recognized as a productive programming environment for an individual programmer, but its lack of team support is currently a major obstacle in using Smalltalk for a large software project. To support multiperson Smalltalk programming, Orwell provides both source and object code sharing as well as version control on a network of personal workstations. Class ownership is used as the primary means for dividing work among programmers during the lifecycle of a project. Orwell also supports groups of programmers not physically connected to a common file server. We describe our implementation which preserves the productive exploratory environment of Smalltalk. Seamless integration and performance are essential for Orwell to be accepted and used by Smalltalk programmers.
[Software configuration management and version control systems, Software creation and management, Collaboration in software development, General programming languages, Programming teams, Language types, Software notations and tools, Software and its engineering]
Integrating an object-oriented programming system with a database system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
There are two major issues to address to achieve integration of an object-oriented programming system with a database system. One is the language issue: an object-oriented programming language must be augmented with semantic data modeling concepts to provide a robust set of data modeling concepts to allow modeling of entities for important real-world applications. Another is the computational-model issue: application programmers should be able to access and manipulate objects as though the objects are in an infinite virtual memory; in other words, they should not have to be aware of the existence of a database system in their computations with the data structures the programming language allows. This paper discusses these issues and presents the solutions which we have incorporated into the ORION object-oriented database system at MCC.
[Information storage systems, Data management systems, Software notations and tools, Information retrieval, Database design and models, Development frameworks and environments, Software and its engineering, Information systems]
A performance comparison of object and relational databases using the Sun Benchmark
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
A general concern about object-oriented systems has been whether or not they are able to meet the performance demands required to be useful for the development of significant production software systems. Attempts to evaluate this assertion have been hampered by a lack of meaningful performance benchmarks that compare database operations across different kinds of databases.In this paper, we utilize the Sun Benchmark [Rube87] as a means for assessing the performance of an object database and comparing it with existing relational systems. We discuss the benchmark, and many of the implementation issues involved in introducing a relationally oriented benchmark into an object-oriented paradigm. We demonstrate the performance of an object database using Ontologic's Vbase object database platform as an example of a commercially available object database, and we compare these benchmark results against those of existing relational database systems. The results offer strong evidence that object databases are capable of performing as well as, or better than, existing relational database systems.
[Cross-computing tools and techniques, Evaluation, Management of computing and information systems, Software creation and management, Professional topics, Information systems, Metrics, Software management, Data management systems, Social and professional topics, General and reference, Software and its engineering]
Intensional concepts in an object database model
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
There is a requirement for a stronger treatment of intentional concepts and more general inferential ability within database systems. A framework for achieving this will be described in terms of extensions to an object data model.The type Concept is introduced into the model as a subtype of Action. Intentional concepts may then be defined as filters or generators, depending on the nature of the defining formula. In either case, the dual action should be available-provided automatically by the system or explicitly by the user.Finally, sets and types are treated as special cases of extensional concepts, leading to a novel structure of the hierarchy of system types.
[Management of computing and information systems, Project and people management, Professional topics, Language types, Software notations and tools, Information systems, Database query languages (principles), Theory of computation, Theory and algorithms for application domains, General programming languages, Data management systems, Social and professional topics, Database design and models, Systems development, Database theory, Query languages, Software and its engineering]
Fabrik: a visual programming environment
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
Fabrik is a visual programming environment - a kit of computational and user-interface components that can be "wired" together to build new components and useful applications. Fabrik diagrams utilize bidirectional dataflow connections as a shorthand for multiple paths of flow. Built on object-oriented foundations. Fabrik components can compute arbitrary objects as outputs. Music and animation can be programmed in this way and the user interface can even be extended by generating graphical structures that depend on other data. An interactive type system guards against meaningless connections. As with simple dataflow, each Fabrik component can be compiled into an object with access methods corresponding to each of the possible paths of data propagation.
[Integrated and visual development environments, Software notations and tools, Development frameworks and environments, Software libraries and repositories, Software and its engineering]
GraphTrace-understanding object-oriented systems using concurrently animated views
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
Object-Oriented programming is a powerful means of developing large complex systems. In this paper we address the need to understand the behavior of objects in order to facilitate code sharing and reusability. We describe <italic>GraphTrace</italic>, a tool we have developed that has allowed us to experiment with new ways of visualizing the dynamic behavior of object-oriented programs. Based on our experience with the GraphTrace tool we suggest that being able to present many different views of an object-oriented system and then animating these views concurrently represents a powerful means for understanding such systems.
[Software defect analysis, Software design techniques, Software creation and management, Software verification and validation, Computing methodologies, Software implementation planning, Designing software, Software development process management, Software testing and debugging, Computer graphics, Animation, Software and its engineering]
AVANCE: an object management system
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
AVANCE<supscrpt>1</supscrpt> is an integrated application development and run-time system. It provides facilities for programming with shared and persistent objects, transactions and processes. The architecture is designed with decentralization in mind by having a large object identifier space and a remote procedure call interface to objects. Emphasis in this paper is on the programming language PAL and its relation with the underlying virtual machine.
[Computing methodologies, Language types, Software notations and tools, Runtime environments, Information systems, Theory of computation, Computational geometry, General programming languages, Computer graphics, Data management systems, Shape modeling, Database design and models, Randomness, geometry and discrete structures, Software and its engineering, Compilers]
An interactive environment for object-oriented music composition and sound synthesis
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
<italic>Kyma is an object-oriented environment for music composition written in Smalltalk-80, which, in conjunction with a microprogrammable digital signal processor called the Platypus, provides the composer with a means for creating and manipulating Sound objects graphically with real-time sonic feedback via software synthesis. Kyma draws no distinctions between the materials and the structure of a composition; both are Sound objects. When a Sound object receives a message to play, it transforms itself into a microSound object, i.e. an object representation of itself in the microcode of the Platypus. Thus an object paradigm is used not only in the representation of Sound objects in Smalltalk-80 but also in the microcode representation of those Sound objects on the Platypus</italic>.
[Applied computing, Sound and music computing, General programming languages, Language types, Software notations and tools, Arts and humanities, Development frameworks and environments, Software and its engineering]
A smalltalk implementation of an intelligent operator's associate
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
This paper describes the use of Smalltalk in the design and implementation of OFMspert. OFMspert is an architecture for an intelligent operator's associate. In order to verify the architecture, an OFMspert was implemented to act as an assistant to an operator of a NASA satellite ground control system. OFMspert is a large system that utilizes a Smalltalk implementation of a knowledge-based problem solving method known as the blackboard architecture. The entire system was designed and implemented in Smalltalk/V&trade; and later ported to the Smalltalk-80&trade; system. The object-oriented paradigm in general, and Smalltalk&Dagger; in particular, greatly facilitated the rapid design and implementation of this system. This paper summarizes the OFMspert architecture, emphasizing its implementation in an object-oriented paradigm.
[Decision support systems, Integrated and visual development environments, General programming languages, Information systems applications, Language types, Software notations and tools, Expert systems, Development frameworks and environments, Information systems, Software and its engineering]
Process management and exception handling in multiprocessor operating systems using object-oriented design techniques
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
The programming of the interrupt handling mechanisms, process switching primitives, scheduling mechanisms, and synchronization primitives of an operating system for a multiprocessor require both efficient code in order to support the needs of high-performance or real-time applications and careful organization to facilitate maintenance. Although many advantages have been claimed for object-oriented class hierarchical languages and their corresponding design methodologies, the application of these techniques to the design of the primitives within an operating system has not been widely demonstrated.To investigate the role of class hierarchical design in systems programming, the authors have constructed the <italic>Choices</italic> multiprocessor operating system architecture using the C++ programming language. During the implementation, it was found that many operating system design concerns can be represented advantageously using a class hierarchical approach, including: the separation of mechanism and policy; the organization of an operating system into layers, each of which represents an abstract machine; and the notions of process and exception management. In this paper, we discuss an implementation of the low-level primitives of this system and outline the strategy by which we developed our solution.
[Language types, Software notations and tools, Parallel architectures, Contextual software domains, Computer systems organization, Operating systems, General programming languages, Multiple instruction, multiple data, Software organization and properties, Software and its engineering, Process management, Architectures]
An object-oriented framework of pattern recognition systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
In this paper, we describe a purely object-oriented framework of pattern recognition systems. Its aim is in dealing with knowledge representation issues in pattern recognition. In our approach, everything works in an entirely autonomous and decentralized manner. Even a search procedure for sample-concept matching is distributed onto every concept object itself by being implemented in what we introduced as the recursive agent-blackboard model. We developed an experimental prototype of character recognition systems in Smalltalk-80, which proved the ability of the object-oriented framework and the cooperative search procedure.
[Interactive systems and tools, General programming languages, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Software and its engineering]
Data abstraction mechanisms in SINA/ST
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
This paper describes a new data abstraction mechanism in an object-oriented model of computing. The data abstraction mechanism described here has been devised in the context of the design of Sina/st language. In Sina/st no language constructs have been adopted for specifying inheritance or delegation, but rather, we introduce simpler mechanisms that can support a wide range of code sharing strategies without selecting one among them as a language feature. Sina/st also provides a stronger data encapsulation than most of the existing object-oriented languages. This language has been implemented on the SUN 3 workstation using Smalltalk.
[General programming languages, Language features, Language types, Software notations and tools, Abstract data types, Software and its engineering]
Using tuple space communication in distributed object-oriented languages
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
When Object-Oriented languages are applied to distributed problem solving, the form of communication restricted to direct message sending is not flexible enough to naturally express complex interactions among the objects. We transformed the <italic>Tuple Space Communication Model</italic>[29] for better affinity with Object-Oriented computation, and integrated it as an alternative method of communication among the distributed objects. To avoid the danger of potential bottleneck, we formulated an algorithm that makes concurrent pattern matching activities within the Tuple Space possible.
[Software system structures, Communications management, Operating systems, General programming languages, Language features, Concurrent programming structures, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Distributed systems organizing principles]
Controlling propagation of operations using attributes on relations
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
Controlling the propagation of operations through a collection of objects connected by various relationships has been a problem both for the object-oriented and the data base communities. Operations such as copy, destroy, print, and save must propagate to some, but not all, of the objects in a collection. Such operations can be implemented using ad hoc methods on objects, at the cost of extra work and loss of clarity. The use of propagation attributes on the relationships between objects permits a concise, intuitive specification of the manner in which operations should propagate from one object to another. These concepts have been implemented in the object-oriented language DSM and have been used to write applications.
[Theory of computation, Control structures, Semantics and reasoning, Semantics, General programming languages, Language features, Program semantics, Formal language definitions, Software notations and tools, Software and its engineering]
How to invent distributed implementation schemes of an object-based concurrent language: a transformational approach
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
A design and verification technique for implementation schemes of distributed software is presented. In this technique, first, the specification is modelled by a concurrent object system, that is, one which is constituted of computational agents with capability of concurrent execution and message passing. Then, such a concurrent object system is transformed into another concurrent object system, which models a sophisticated implementation scheme.Our transformation technique is mainly based on fusing and splitting concurrent objects. The correctness of transformation rules can be proven formally.
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
Reflection in an object-oriented concurrent language
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
Our work is along the line of the work of B. Smith and P. Maes. We first discuss our notion of <italic>reflection</italic> in object-oriented <italic>concurrent</italic> computation and then present a reflective object-oriented concurrent language ABCL/R. We give several illustrative examples of reflective programming such as (1) dynamic concurrent acquisition of "methods" from other objects, (2) monitoring the behavior of concurrently running objects, and (3) augmentation of the time warp mechanism to a concurrent system. Also the definition of a meta-circular interpreter of this language is given as the definition of a meta-object. The language ABCL/R has been implemented. All the examples given in this paper are running on our ABCL/R system.
[Theory of computation, Models of computation, General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Logic, Concurrent computing methodologies, Software and its engineering]
An execution model for distributed object-oriented computation
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
This paper describes an execution model being developed for distributed object-oriented in a message-passing multiple-instruction/multiple-data-stream (MIMD) environment. The objective is to execute an object-oriented program as concurrently as possible. Some opportunities for concurrency can be identified explicitly by the programmer. Others can be identified at compile time. There are some opportunities for concurrency, however, that can only be discovered at runtime because they are data-dependent. The model of execution we describe attempts to discover and exploit the data-dependent concurrency that exists in a given program execution.
[Computing methodologies, Language types, Software notations and tools, Parallel architectures, Theory of computation, Models of computation, Computer systems organization, General programming languages, Concurrent programming languages, Multiple instruction, multiple data, Concurrent computing methodologies, Software and its engineering, Architectures]
Object-oriented programming: an objective sense of style
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
We introduce a simple, programming language independent rule (known in-house as the Law of Demeter&trade;) which encodes the ideas of encapsulation and modularity in an easy to follow form for the object-oriented programmer. You tend to get the following related benefits when you follow the Law of Demeter while minimizing simultaneously code duplication, the number of method arguments and the number of methods per class: Easier software maintenance, less coupling between your methods, better information hiding, narrower interfaces, methods which are easier to reuse, and easier correctness proofs using structural induction. We discuss two important interpretations of the Law (strong and weak) and we prove that any object-oriented program can be transformed to satisfy the Law. We express the Law in several languages which support object-oriented programming, including Flavors, Smalltalk-80, CLOS, C++ and Eiffel.
[Designing software, Software development process management, Software creation and management, Software development methods, General programming languages, Language features, Software notations and tools, Modules / packages, Software and its engineering]
Transformation of data flow analysis models to object oriented design
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 23 ISSUE 11
1988
This paper describes a strategy to transform Data Flow Analysis into Object Oriented Design. This transformation is performed by extracting information from the Data Flow Model, by enriching with Design decision and by finally producing an Object Oriented Design Model. Semiformal transformation rules are described. Also a special notation is introduced to describe the Object Oriented Design Model. The Model used to represent Data Flow Analysis is the one originally proposed by Yourdon, complemented with Ward-Mellor's Real Time extensions (the "Essential Model").
[Theory of computation, Models of computation, Designing software, Flowcharts, Software creation and management, Logic, Software development techniques, Software and its engineering]
A laboratory for teaching object oriented thinking
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
It is difficult to introduce both novice and experienced procedural programmers to the anthropomorphic perspective necessary for object-oriented design. We introduce CRC cards, which characterize objects by class name, responsibilities, and collaborators, as a way of giving learners a direct experience of objects. We have found this approach successful in teaching novice programmers the concepts of objects, and in introducing experienced programmers to complicated existing designs.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Software notations and tools, Development frameworks and environments, Software development techniques, Software and its engineering]
Problem-solution mapping in object-oriented design
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Six expert Smalltalk programmers and three expert procedural programmers were observed as they worked on a gourmet shopping design problem; they were asked to think aloud about what was going through their minds as they worked. These verbal protocols were recorded and examined for ways in which the programmers' understanding of the problem domain affected the design process; most of our examples are from the three Smalltalk programmers who focussed most on the mapping from problem to solution. We characterize the problem entities that did appear as solution objects, the active nature of the mapping process, and ways in which the resultant objects went beyond their problem analogs.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, General programming languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Contributions to teaching object-oriented design and programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
We provide a formal agenda for teaching the object-oriented paradigm in a programming language independent manner, and a tool which supports our teaching approach. Our proposal for a comprehensive study of the subject includes an ordered set of objectives designed to guide the uninitiated user from zero knowledge about object-oriented programming through class definitions, inheritance, subtyping, and the parameterization of classes. This set of graded objectives provides both a useful metric for gauging a student's progress, and a facility through which users can begin their studies at a level commensurate with their experience.
[Software design techniques, Software creation and management, Professional topics, Computing education, Computing education programs, Software development techniques, Software implementation planning, Designing software, Software development process management, Computer science education, Social and professional topics, Software and its engineering]
Incremental distribution of timestamp packets: a new approach to distributed garbage collection
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
A new algorithm for distributed garbage collection is presented. This algorithm collects distributed garbage incrementally and concurrently with user activity. It is the first incremental algorithm that is capable of collecting <italic>cyclic</italic> distributed garbage. Computational and network communication overhead are acceptable. Hosts may be temporarily inaccessible and synchronization between hosts is not necessary. The algorithm is based on asynchronous distribution of timestamp packets each containing a list of last-access times of some relevant remotely referenced objects. Finally, the correctness and time complexity of the algorithm are discussed.
[Software creation and management, Software notations and tools, Graph theory, Contextual software domains, Software development techniques, Distributed systems organizing principles, Software system structures, Operating systems, Memory management, Allocation / deallocation strategies, Discrete mathematics, Mathematics of computing, Graph algorithms, Software organization and properties, Software and its engineering, Compilers]
An efficient implementation of SELF a dynamically-typed object-oriented language based on prototypes
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our SELF implementation runs twice as fast as the fastest Smalltalk implementation, despite SELF's lack of classes and explicit variables.To compensate for the absence of classes, our system uses implementation-level <italic>maps</italic> to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles <italic>multiple versions</italic> of a source method, each <italic>customized</italic> according to its receiver's map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and <italic>inline</italic> all messages sent to self. <italic>Message splitting</italic> and <italic>type prediction</italic> extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +,==, and ifTrue:.Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the SELF programmer.
[Parsers, Software defect analysis, Software creation and management, Software verification and validation, Language types, Software notations and tools, Development frameworks and environments, Software development techniques, Software testing and debugging, General programming languages, Software and its engineering, Compilers]
Object-oriented design: a responsibility-driven approach
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Object-oriented programming languages support encapsulation, thereby improving the ability of software to be reused, refined, tested, maintained, and extended. The full benefit of this support can only be realized if encapsulation is maximized during the design process.We argue that design practices which take a data-driven approach fail to maximize encapsulation because they focus too quickly on the implementation of objects. We propose an alternative object-oriented design method which takes a responsibility-driven approach. We show how such an approach can increase the encapsulation by deferring implementation issues until a later stage.
[Designing software, Software creation and management, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Abstract data types, Software and its engineering]
Saving legacy with objects
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Developers of application software must often work with "legacy systems." These are systems that have evolved over many years and are considered irreplaceable, either because it is thought that duplicating their function would be too expensive, or because they are trusted by users. Because of their age, such systems are likely to have been implemented in a conventional language with limited use of data abstraction or encapsulation. The lack of abstraction complicates adding new applications to such systems and the lack of encapsulation impedes modifying the system because applications depend on system internals. We describe our experience providing and using an object-oriented interface to a legacy system.
[Volumetric models, General programming languages, Parametric curve and surface models, Computer graphics, Computing methodologies, Language types, Functional languages, Software notations and tools, Shape modeling, Software and its engineering]
Good news, bad news: experience building software development environment using the object-oriented paradigm
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper presents our experience building an extendible software development environment using the object-oriented paradigm. We have found that object instances provide a natural way to model program constructs, and to capture complex relationships between different aspects of a software system. The object-oriented paradigm can be efficiently implemented on standard hardware and software, and provides some degree of extendibility without requiring major modifications to the existing implementation.Unfortunately, we have also found that some natural extensions that we would like to make to the environment are not easily incorporated. We argue that the lack of extendibility is due to the object-oriented paradigm's lack of support for providing modifications and extensions to the object-oriented paradigm itself.
[Software creation and management, Extensible languages, Reusability, General programming languages, Language features, Language types, Software notations and tools, Software development techniques, Software and its engineering]
PROCOL: a parallel object language with protocols
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
PROCOL is a parallel C-based object-oriented language with communication based on one-way synchronous messages. Objects execute in parallel unless engaged in communication. Communication partners are defined by object instance identifiers, or by type. Therefore send-receive mappings may be 1-1, n-1, or 1-n, though only 1 message is transferred. PROCOL controls object access by a novel concept: an explicit per-object protocol. This protocol is a specification of the occurrence and sequencing of the communication between the object and its partners. Thus protocols support structured, safer and potentially verifiable information exchange between objects. Protocols also act as a composition rule over client objects, thereby offering a 'part-of' hierarchy of these cooperating objects.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Inheritance and synchronization with enabled-sets
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
We discuss several issues related to the integration of inheritance and concurrency in an object-oriented language to support fine-grain parallel algorithms. We present a reflective extension of the actor model to implement inheritance mechanisms within the actor model. We demonstrate that a particularly expressive and inheritable synchronization mechanism must support local reasoning, be composable, be first-class, and allow parameterization based on message content. We present such a mechanism based on the concept of <italic>enabled-sets</italic>, and illustrate each property. We have implemented enabled-sets in the Rosette prototyping testbed.
[Software creation and management, Language features, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Modules / packages, Parallel algorithms, Software development techniques, Theory of computation, General programming languages, Concurrent programming languages, Design and analysis of algorithms, Concurrent computing methodologies, Software and its engineering]
Extending the operating system to support an object-oriented environment
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Comandos is a project within the European Strategic Programme for Research on Information Technology - <italic>ESPRIT</italic> and it stems from the identified need of providing simpler and more integrated environments for application development in large distributed systems.The fundamental goal of the project is the definition of an integrated platform providing support for distributed and concurrent processing in a LAN environment, extensible and distributed data management and tools for monitoring and administrating the distributed environment.An object oriented approach was used as the ground level for the integration of the multidisciplinary concepts addressed in the project.This paper starts by describing the basic model and architecture of Comandos, which results from a common effort by all the partners in the project. We focus then on the description of a first prototype of the system, which implements a subset of the architecture and is currently running on a set of personal computers and workstations at INESC. The prototype is a testbed for the architecture, providing dynamic linking, access to persistent objects and transparent distribution. Special attention is given to the performance aspects of object invocation in virtual memory.
[Wide area networks, Networks, Language features, Computing / technology policy, Computing methodologies, Language types, Network range, Software notations and tools, Distributed systems organizing principles, Network properties, Software system structures, Computer systems organization, Distributed architectures, General programming languages, Concurrent programming languages, Social and professional topics, Concurrent computing methodologies, Software organization and properties, Local area networks, Software and its engineering, Architectures]
Playground: an object-oriented simulation system with agent rules for children of all ages
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Programming languages for children have been limited by primitive control and data structures, indirect user interfaces, and artificial syntax. Playground is a child-oriented programming language that uses objects to structure data and has a modular control structure, a direct-manipulation user interface, and an English-like syntax. Integrating Playground into the curriculum of a classroom of 9- to 10-year-olds has given us valuable insights from the programs intended users, and confirmed many of our design decisions.
[Personal computers and PC applications, Software creation and management, Language features, Language types, Software notations and tools, Computers in other domains, Modules / packages, Development frameworks and environments, Software development techniques, Applied computing, Integrated and visual development environments, General programming languages, Software and its engineering]
Neural agents - a frame of mind
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Several recent theories have been advanced to model complex heuristic behavior. From Minsky's <italic>Society of Mind</italic> to neural networks, these theories all share a common architecture consisting of many highly connected elements that together exhibit sophisticated macro behavior. This paper describes NeuralAgents, a framework developed in Smalltalk-80 that combines the high level interaction and collaboration of rule-based agents with the topological connectivity of neural nets. The Client-Facilitator-Consultant model for agencies will be presented, along with the object oriented design and implementation of the NeuralAgents system. PetWorld, an animated environment for the simulation of animal behavior is presented as an example application.
[Philosophical/theoretical foundations of artificial intelligence, Software creation and management, Computing methodologies, Language types, Software notations and tools, Software development techniques, Designing software, Requirements analysis, Modeling and simulation, General programming languages, Artificial intelligence, Software and its engineering]
An extended frame language
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper describes several extensions to the traditional frame based programming semantics. We generalize the treatment of slots to include frame-like semantics; in addition we allow slots to be referenced by complex terms, whereas previously described frame based systems typically allow only scalar slot references. The resulting frame system naturally accommodates complex data structures and provides an extremely powerful mechanism for specifying complex relationships between objects represented by frames.
[Software creation and management, Language types, Software notations and tools, Development frameworks and environments, Software development techniques, Theory of computation, Semantics and reasoning, Integrated and visual development environments, Semantics, General programming languages, Program semantics, Formal language definitions, Software and its engineering]
Strategies for scientific prototyping in Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper describes the design of a scientific prototyping environment in Smalltalk and discusses implementation strategies to achieve high performance interactive modeling of computationally intensive physical problems. Classes for scientific visualization, including contour plotting and 3D surface representations which incorporate the model-view-controller paradigm are presented. Techniques for inclusion of user primitives written in C to support computationally intense methods are described in detail in their current implementation on advanced Smalltalk workstations (SUN4, Ardent Titan, Tektronix 4317).
[Software creation and management, Software notations and tools, Development frameworks and environments, Software implementation planning, Software development process management, Volumetric models, Computer graphics, Graphics input devices, Rapid application development, Software and its engineering, Software design techniques, Software prototyping, Software development methods, Computing methodologies, Human-centered computing, Language types, Human computer interaction (HCI), Graphics systems and interfaces, Software development techniques, Interaction devices, Designing software, General programming languages, Parametric curve and surface models, Shape modeling]
Function minimization and automatic differentiation using C++
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Function minimization techniques often require values for the first partial derivatives of the function at a point. Certain techniques, such as Newton's method, require the values of the second partial derivatives as well. The methods commonly used to obtain these values have certain drawbacks which can be eliminated using a technique known as automatic differentiation. When this technique is implemented in an object oriented language with operator overloading capabilities, the problem of differentiation and minimization can be mapped into a code which fits well with the problem space.
[Software creation and management, Computing methodologies, Symbolic and algebraic manipulation, Language types, Software notations and tools, Software development techniques, Theory of computation, Numerical analysis, Mathematical analysis, General programming languages, Symbolic and algebraic algorithms, Mathematics of computing, Design and analysis of algorithms, Numerical differentiation, Software and its engineering]
Object-oriented programming for linear algebra
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Many numerical analysts and Lisp/Smalltalk programmers share the assumption that languages like Fortran are more appropriate for traditional, quantitative scientific programming than object-oriented languages. To show how straightforward application of object-oriented design to standard algorithms in numerical linear algebra improves clarity and expressiveness, without sacrificing speed or accuracy, I describe parts of Cactus, a system for numerical linear algebra and constrained optimization, implemented in Common Lisp and CLOS.
[Software creation and management, Language types, Computing methodologies, Symbolic and algebraic manipulation, Software notations and tools, Software development techniques, Numerical analysis, General programming languages, Mathematical analysis, Symbolic and algebraic algorithms, Mathematics of computing, Software and its engineering]
Vamp: the Aldus application framework
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
<italic>This paper describes an application framework, called Vamp, which supports Interactive Compound Documents and applications as collections of Interactive Objects. Aldus developed Vamp as a practical experiment in solving several software engineering and project management problems including software reusability, portability, and management of large program teams. Vamp is written in C ++ to run on the Macintosh and Microsoft Windows. This paper discusses the decisions that led to the architecture of Vamp and what Aldus stands to gain by its use.</italic>
[Management of computing and information systems, Project and people management, Software creation and management, Professional topics, Language types, Computers in other domains, Software notations and tools, Software development techniques, Software configuration management and version control systems, Applied computing, Software development process management, General programming languages, Document management and text processing, Social and professional topics, Software and its engineering]
DSM: an object-relationship modeling language
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
The Data Structure Manager (DSM) combines object-oriented programming with semantic data modeling concepts in the context of the C language. DSM is a full-featured object-oriented language which includes single and multiple inheritance, class descriptor objects, metaclasses, choice of method binding time, error handling, persistent objects, modularity, and an interactive interpreter in an efficient manner. In addition, DSM supports the association and aggregation relationships as part of the Object Modeling Technique (OMT) used for conceptual design. DSM has been used since 1986 to build a variety of research and production-quality software such as an advanced CAF/CAD system.
[Applied computing, Engineering, Architecture (buildings), General programming languages, Language types, Software notations and tools, Arts and humanities, Computer-aided design, Development frameworks and environments, Software and its engineering, Physical sciences and engineering]
Mandatory security in object-oriented database systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
A multilevel secure object-oriented data model (using the ORION data model) is proposed for which mandatory security issues in the context of a database system is discussed. In particular the following issues are dealt with: (1) the security policy for the system, (2) handling polyinstantiation, and (3) handling the inference problem.A set of security properties that has been established in this paper is more complete than those that have been proposed previously. Finally we describe how certain security constraints are handled by our model.
[Language features, Information retrieval, Software notations and tools, Information systems, Database management system engines, Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, Information storage systems, General programming languages, Data management systems, Database design and models, Database theory, Theory of database privacy and security, Software and its engineering]
A fast method dispatcher for compiled languages with multiple inheritance
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper addresses the problem of an efficient dispatch mechanism in an object-oriented system with multiple inheritance. The solution suggested is a direct table indexed branch such as is used in C++. The table slot assignments are made using a coloring algorithm. The method is applicable to strongly typed languages such as C++ (with multiple inheritance added) and Eiffel, and in a slightly slower form to less strongly typed languages like Objective C.
[Software creation and management, General programming languages, Language features, Language types, Software notations and tools, Software development techniques, Software and its engineering]
TICLOS: an implementation of CLOS for the explorer family
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
None
[Computer systems organization, High-level language architectures, General programming languages, Language types, Software notations and tools, Other architectures, Software and its engineering, Architectures]
PCLOS: a critical review
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper uses the persistent object system PCLOS to survey some problems and benefits of object persistence. The system is analyzed along several relevant dimensions. PCLOS provides object persistence for an object-oriented language. The insights gained on desirable and detrimental components of the system are presented. The intent is to outline some of the expected and unexpected problems encountered in the construction of support for object persistence.
[Software creation and management, General programming languages, Language types, Data management systems, Software notations and tools, Database design and models, Software development techniques, Software and its engineering, Information systems]
The use of multimethods and method combination in a CLOS based window interface
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Solo is a portable window interface written in the Common Lisp Object System (CLOS) object-oriented programming language. Solo provides a virtual window machine which is targeted to a host window system by implementing a set of host window system specific classes and methods for Solo's host window system driver protocol. The interface presented by Solo to an application insulates it from differences in the host window system, facilitating application portability. Solo distinguishes itself from other object-oriented window systems by exploiting certain features of CLOS. CLOS method combination simplifies initialization of windows while preserving easy extensibility of the basic classes. Generic dispatch on multiple arguments, a feature unique to CLOS, allows a simpler and more flexible input event dispatching protocol. A powerful event description language simplifies the specification of keyboard and mouse events. A prototype implementation runs on the server based XII and NeWS host systems, and on the frame buffer based Lucid Window Toolkit.
[Language features, Simulation support systems, Language types, Human-centered computing, Computing methodologies, Software notations and tools, Human computer interaction (HCI), Graphics systems and interfaces, Modules / packages, Interaction devices, Modeling and simulation, General programming languages, Graphics input devices, Computer graphics, Software and its engineering, Simulation languages]
Prototyping a real-time embedded system in Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper presents a case study of AMEP, a prototype ESM signal processor which has been implemented in Smalltalk using an actor-based design methodology, Arguments for choosing an OOPS for implementing such applications are reviewed. AMEP is a large system which includes both hard real-time and knowledge-based subsystems. Extensive software metrics are presented for each subsystem and used to compare the characteristics of code designed for different purposes. For example, analysis of this data suggests that knowledge-based applications may be more difficult to port to an object-based language such as Ada than hard real-time systems. Team programming, productivity, documentation standards and other software engineering issues are also addressed.
[Communication hardware, interfaces and storage, Software creation and management, Language types, Software notations and tools, Software development techniques, Software configuration management and version control systems, Collaboration in software development, General programming languages, Programming teams, Hardware, Signal processing systems, Software and its engineering]
Virtual memory and backing storage management in multiprocessor operating systems using object-oriented design techniques
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
The <italic>Choices</italic> operating system architecture [3, 4, 15] uses class hierarchies and object-oriented programming to facilitate the construction of customized operating systems for shared memory and networked multiprocessors. The software is being used in the Tapestry Parallel Computing Laboratory at the University of Illinois to study the performance of algorithms, mechanisms, and policies for parallel systems. This paper describes the architectural design and class hierarchy of the <italic>Choices</italic> memory and secondary storage management system.The mechanisms and policies of a virtual memory system implement a memory hierarchy that exploits the trade-offs between response times and storage capacities. In <italic>Choices</italic>, the notion of a memory hierarchy is represented by layers in which abstract classes define interfaces between and internal to the layers. Concrete subclasses implement new algorithms or data structures or specializations of existing ones. This paper describes the motivation for an object-oriented, class-hierarchical approach to virtual memory system design, and describes the overall architecture of such an approach, as it has been applied to the <italic>Choices</italic> system. Special attention is paid to the advantages in both design and implementation that have resulted from using object-oriented techniques.
[Communication hardware, interfaces and storage, External storage, Software creation and management, Language types, Software notations and tools, Dynamic memory, Contextual software domains, Software development techniques, Semiconductor memory, Integrated circuits, Operating systems, Non-volatile memory, General programming languages, Hardware, Software organization and properties, Software and its engineering]
An object addressing mechanism for statically typed languages with multiple inheritance
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
In this paper we are concerned with addressing techniques for statically typed languages with multiple inheritance. The addressing techniques are responsible for the efficient implementation of record field selection. In object-oriented languages, this record selection is equivalent to the access of methods. Thus, the efficiency of these techniques greatly affects the overall performance of an object-oriented language. We will demonstrate that addresses, in such systems, cannot always be calculated statically and show how symbol tables have been used as address maps at run time. The essence of the paper is a new addressing technique that can statically calculate either the address of a field or the address of the address of the field. This technique is powerful enough to support an efficient implementation of multiple inheritance with implicit subtyping as described by Cardelli.
[Software creation and management, General programming languages, Language features, Data types and structures, Software notations and tools, Software development techniques, Software and its engineering]
An object-oriented modelling enviornment
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Many tools and techniques exist for the modeling and analysis of computer and communication systems. These tools are often complex and tailored to a narrow range of problems. The system analysis task often requires coordinated use of multiple tools and techniques which is not supported by currently available systems. The Tangram project goal is to develop an environment which makes a large set of tools and techniques readily accessible and is easily tailored to specialized applications.This system has been prototyped in an object-oriented extension to Prolog. The impact that these two paradigms, logic and objects, have had on the design is discussed. Several example applications are presented to illustrate the extensibility of the system.
[Software design techniques, Software creation and management, Language types, Computing methodologies, Software notations and tools, Software development techniques, Software implementation planning, Designing software, Software development process management, Modeling and simulation, General programming languages, Software and its engineering]
OROS: toward a type model for software development environments
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Three important goals of next generation software development environments (SDEs) are extensibility, integration and broad scope. Our work on OROS is predicated on the hypothesis that a type model, incorporated into an environment's object manager, can contribute to achieving those goals. This paper reports on an attempt at applying object-oriented typing concepts in the domain of software development environments. We believe that the result is a type model that has properties of interest both to software environment builders and also to builders and users of object-oriented systems in general.
[Management of computing and information systems, Software creation and management, Reusability, Language features, Professional topics, Software notations and tools, Software development techniques, Development frameworks and environments, Software management, General programming languages, Data types and structures, Social and professional topics, Software and its engineering]
Metaclass compatibility
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Metaclasses provide control of object description, method compilation and more generally class behaviour. Consequently, they have been widely used in languages such as Smalltalk-80 or more recently CLOS by both users and implementers. Due to their powerful control of instances, careless inheritance of classes with different metaclasses can lead to unsound or inefficient implementations of instance methods. Using examples, we will pin-point these problems. Then we will introduce compatibility rules which need to be fulfilled by metaclasses of inherited classes in order to allow reasonable instance method description.
[General programming languages, Language features, Language types, Software notations and tools, Software and its engineering]
Computational reflection in class based object-oriented languages
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper describes various models of computational reflection in class based object oriented language. Two different approaches are covered: the meta-object approach which supposes that every object can have a meta-object describing and monitoring its behavior, and the message reification approach which describes a message as an object. The meta-object approach is discussed more fully showing that it is important to differentiate between structural reflection and computational reflection. We will see that, whereas classes and metaclasses are very important for the former, they cannot cope adequately with the later. Therefore we introduce a model of computational reflection where meta-objects are instances of a class META-OBJECT or of one of its subclasses.
[Software creation and management, General programming languages, Language features, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Reflective facilities in Smalltalk-80
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Computational reflection makes it easy to solve problems that are otherwise difficult to address in Smalltalk-80, such as the construction of monitors, distributed objects, and futures, and can allow experimentation with new inheritance, delegation, and protection schemes. Full reflection is expensive to implement. However, the ability to override method lookup can bring much of the power of reflection to languages like Smalltalk-80 at no cost in efficiency.
[Software creation and management, Reusability, General programming languages, Language features, Language types, Software notations and tools, Software development techniques, Software and its engineering]
An environment for literate Smalltalk programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
The programming environment described in this paper is an adaptation of Donald Knuth's concept of literate programming, applied to Smalltalk programs. The environment provides a multi-media document production system including media for Smalltalk class and method definitions.There are two outputs from the system. The first output is a document which contains general descriptions and discussions intermixed with precise definitions of program fragments, test inputs and test results. The second output consists of compiled Smalltalk programs installed and ready for execution.The main idea was to produce program documentation that was just as interesting and fascinating to read as ordinary literature. Our experience showed an added benefit, namely that the literate programming environment was an active aid in the problem solving process. The simultaneous programming and documentation lead to significantly improved quality of both programs and documentation.
[Software defect analysis, Software creation and management, Software verification and validation, Documentation, Language types, Software notations and tools, Software post-development issues, Development frameworks and environments, Software development techniques, Integrated and visual development environments, Software testing and debugging, General programming languages, Software and its engineering]
An event-driven model-view-controller framework for Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
The Smalltalk Model-View-Controller (MVC) user interface paradigm uses polling for its input control. The polling loops consume CPU cycles even when the user is not interacting with the interface. Applications using Smalltalk as their front-end often suffer unnecessary performance loss. This paper presents a prototype event-driven MVC framework to solve these problems. A solution to the compatibility problem is also provided to allow interface objects built under both polling and event-driven mechanisms to be used by each other with no modification and no performance penalty.
[Modeling and simulation, General programming languages, Computing methodologies, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Software and its engineering]
Three steps to views: extending the object-oriented paradigm
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
At the core of any sophisticated software development and maintenance environment is a large mass of complex data. The data (the central data of the environment) is composed of smaller sets of data that can be related in complicated and often subtle ways. The user or developer of the environment will be more effective if they are able to deal with conceptual slices, or <italic>views</italic>, of the large, complex structure. This paper presents an architectural building block for object-based software environments based on the views concept. The building block allows the construction of global abstractions that describe unified behavior of large sets of objects. The basis of the architecture relies on extending the object-oriented paradigm in three steps: (1) defining multiple interfaces in object classes; (2) controlling visibility of instance variables; and (3) allowing multiple copies of an instance variable to occur within an object instance. This paper focuses on the technical aspects of the views approach.
[Software design techniques, Management of computing and information systems, Software creation and management, Language features, Professional topics, Software notations and tools, Modules / packages, Software development techniques, Software implementation planning, Designing software, Software development process management, Software management, General programming languages, Data types and structures, Social and professional topics, Software and its engineering]
Rule-based delegation for prototypes
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Arguments have been given recently for providing the functionality of prototypes in object-oriented languages. Prototypes allow more flexible sharing of code and data by delegating messages to parent objects without the rigid structure of a class hierarchy. Prototypes can implement classes, and delegation can be used to model both single and multiple inheritance. However, one drawback with delegation is the difficulty in enforcing the semantics that delegation is used to model. This paper proposes a novel mechanism to control the delegation of messages with rules. In this system, the delegation of messages is governed by a set of rules possessed by each object. Rules can be used to implement classical single inheritance and can implement various solutions to multiple inheritance. In addition, rules can be created dynamically to model application-specific semantics. This paper describes how rule-based delegation works and illustrates various rules for rule-based delegation that have been implemented.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Language types, Software notations and tools, Programming logic, Program reasoning, Logic, Software and its engineering]
Controllable delegation: an exercise in law-governed systems
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
We believe that the regime governing the patterns of sharing between objects, and of exchange of messages between them, should not be "hard-wired" into a programming language, but should be specifiable by the builders of a system to fit its particular requirements. This thesis has been the primary motivation behind our general concept of <italic>law-governed system</italic>, which serves as the foundation for this paper.We show how the law can be used to impose a variety of useful constraints over the structure and behavior of delegation-based systems. Such a law may contain some very specific rules that apply only to small parts of a system; it may also impose some very general regimes, such as class inheritance, on the entire system. We also argue that the constraints established by the law can be easily adapted to the changing requirements of an evolving system. This should be very useful in managing the process of software development from its design stage, through prototyping, construction, and beyond.
[Software creation and management, General programming languages, Language features, Data management systems, Software notations and tools, Database design and models, Software development techniques, Software and its engineering, Information systems]
Constraint technology for user-interface construction in ThingLab II
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
ThingLab II is an object-oriented constraint programming system designed specifically for interactive user interface construction and implemented in Smalltalk-80 For constraints to be effective in building user interfaces, they must not impede the responsiveness of the user interface either at run time or during construction. The necessary speed is attained in ThingLab II by making judicious tradeoffs between compilation and interpretation, and by using a fast, incremental algorithm for constraint satisfaction. The resulting system allows user interface components to be assembled, tested, and modified expediently while maintaining interactive responsiveness.
[Software creation and management, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Software development techniques, Information systems, Database query languages (principles), Theory of computation, Theory and algorithms for application domains, General programming languages, Data management systems, Database theory, Query languages, Software and its engineering]
A module mechanism for constraints in Smalltalk
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
ThingLab II, a rewrite of ThingLab, provides two representations of objects: fully-exposed and interpreted Things, or hidden and compiled Modules. Both representations provide the full power of the ThingLab II constraint hierarchy (an ordering of constraint preferences), and both can be manipulated by the graphical user-interface. This paper briefly describes Modules and their environmental support in ThingLab II. It also describes the process by which the ModuleCompiler translates a collection of objects (a ThingLab II <italic>Thing</italic>) into a single object with compiled and optimized Smalltalk-80 methods (a <italic>Module</italic>).
[Software creation and management, General programming languages, Language features, Language types, Software notations and tools, Modules / packages, Software development techniques, Software and its engineering]
Virtual classes: a powerful mechanism in object-oriented programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
The notions of class, subclass and virtual procedure are fairly well understood and recognized as some of the key concepts in object-oriented programming. The possibility of modifying a virtual procedure in a subclass is a powerful technique for specializing the general properties of the superclass.In most object-oriented languages, the attributes of an object may be references to objects and (virtual) procedures. In Simula and BETA it is also possible to have class attributes. The power of class attributes has not yet been widely recognized. In BETA a class may also have <italic>virtual class attributes</italic>. This makes it possible to defer part of the specification of a class attribute to a subclass. In this sense virtual classes are analogous to virtual procedures. Virtual classes are mainly interesting within strongly typed languages where they provide a mechanism for defining general parameterized classes such as set, vector and list. In this sense they provide an alternative to generics.Although the notion of virtual class originates from BETA, it is presented as a general language mechanism.
[General programming languages, Language types, Software notations and tools, Software and its engineering]
Extending ordinary inheritance schemes to include generalization
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
The arrangement of classes in a specialization hierarchy has proved to be a useful abstraction mechanism in class-based object oriented programming languages. The success of the mechanism is based on the high degree of code reuse that is offered, along with simple type conformance rules.The opposite of specialization is generalization. We will argue that support of generalization in addition to specialization will improve class reusability. A language that only supports specialization requires the class hierarchy to be constructed in a top down fashion. Support for generalization will make it possible to create super-classes for already existing classes, hereby enabling exclusion of methods and creation of classes that describe commonalties among already existing ones.We will show how generalization can coexist with specialization in class-based object oriented programming languages. Furthermore, we will verify that this can be achieved without changing the simple conformance rules or introducing new problems with name conflicts.
[Software design techniques, Software creation and management, Reusability, Language features, Software notations and tools, Software development techniques, Software implementation planning, Designing software, Software development process management, General programming languages, Data types and structures, Abstract data types, Software and its engineering]
Programming with explicit metaclasses in Smalltalk-80
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper discusses the introduction of explicit metaclasses &aacute; la ObjVlisp into the Smalltalk-80 language. The rigidity of Smalltalk metaclass architecture motivated this work. We decided to implement the ObjVlisp model into the standard Smalltalk-80 system. The resulting combination defines the Classtalk platform. This platform provides a full-size environment to experiment with class-oriented programming by combining implicit metaclasses &aacute; la Smalltalk and explicit metaclasses &aacute; la ObjVlisp. Obviously, these experiments are not limited to the Smalltalk world and will be useful to understand and practice the metaclass concept advocated by modern object-oriented languages such as ObjVlisp and CLOS.
[Software creation and management, General programming languages, Language features, Data types and structures, Language types, Software notations and tools, Software development techniques, Software and its engineering]
A denotational semantics of inheritance and its correctness
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper presents a denotational model of inheritance. The model is based on an intuitive motivation of the purpose of inheritance. The correctness of the model is demonstrated by proving it equivalent to an operational semantics of inheritance based upon the method-lookup algorithm of object-oriented languages. Although it was originally developed to explain inheritance in object-oriented languages, the model shows that inheritance is a general mechanism that may be applied to any form of recursive definition.
[Theory of computation, Semantics and reasoning, Operational semantics, General programming languages, Denotational semantics, Language features, Program semantics, Language types, Software notations and tools, Software and its engineering]
Static type inference for parametric classes
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
Central features of object-oriented programming are <italic>method inheritance</italic> and <italic>data abstraction</italic> attained through hierarchical organization of classes. Recent studies show that method inheritance can be nicely supported by ML style type inference when extended to labeled records. This is based on the fact that a function that selects a field &fnof; of a record can be given a polymorphic type that enables it to be applied to any record which contains a field &fnof;. Several type systems also provide data abstraction through abstract type declarations. However, these two features have not yet been properly integrated in a statically checked polymorphic type system.This paper proposes a static type system that achieves this integration in an ML-like polymorphic language by adding a class construct that allows the programmer to build a hierarchy of classes connected by multiple inheritance declarations. Moreover, classes can be parameterized by types allowing "generic" definitions. The type correctness of class declarations is statically checked by the type system. The type system also infers a principal scheme for any type correct program containing methods and objects defined in classes.
[Software creation and management, General programming languages, Language features, Data types and structures, Language types, Software notations and tools, Abstract data types, Software development techniques, Software and its engineering]
Interfaces for strongly-typed object-oriented programming
Conference proceedings on Object-oriented programming systems, languages and applications
ACM SIGPLAN Notices VOLUME 24 ISSUE 10
1989
This paper develops a system of explicit interfaces for object-oriented programming. The system provides the benefits of module interfaces found in languages like Ada and Modula-2 while preserving the expressiveness that gives untyped object-oriented languages like Smalltalk their flexibility. Interfaces are interpreted as polymorphic types to make the system sufficiently powerful. We use interfaces to analyze the properties of inheritance, and identify three distinct kinds of inheritance in object-oriented programming, corresponding to objects, classes, and interfaces, respectively. Object interfaces clarify the distinction between interface containment and inheritance and give insight into limitations caused by equating the notions of type and class in many typed object-oriented programming languages. Interfaces also have practical consequences for design, specification, and maintenance of object-oriented systems.
[Software creation and management, General programming languages, Language features, Language types, Software notations and tools, Modules / packages, Software development techniques, Software and its engineering]
Making pure object-oriented languages practical
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering, Compilers]
Parallel generational garbage collection
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Object oriented languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Parallel architectures, Contextual software domains, Computer systems organization, Operating systems, General programming languages, Memory management, Allocation / deallocation strategies, Software organization and properties, Software and its engineering, Architectures, Compilers]
Using key object opportunism to collect old objects
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Operating systems, General programming languages, Memory management, Object oriented languages, Allocation / deallocation strategies, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
Integrating information retrieval and domain specific approaches for browsing and retrieval in object-oriented class libraries
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Retrieval models and ranking, Software creation and management, Reusability, Object oriented languages, Language types, Human-centered computing, Software notations and tools, Information retrieval, Human computer interaction (HCI), Software development techniques, Information systems, Document representation, Search engine architectures and scalability, General programming languages, Search engine indexing, Data management systems, Database design and models, Interaction paradigms, Software libraries and repositories, Software and its engineering]
Developing a GUIDE using object-oriented programming
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Integrated and visual development environments, General programming languages, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Building generic user interface tools: an experience with multiple inheritance
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Integrated and visual development environments, General programming languages, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Composite multimedia and active objects
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Multimedia and multimodal retrieval, Communication hardware, interfaces and storage, Speech / audio search, Computer vision problems, Software notations and tools, Information systems, Specialized information retrieval, Hardware, Signal processing systems, Software and its engineering, Computer vision, Object oriented languages, Computer vision tasks, Natural language interfaces, Language types, Human-centered computing, Computing methodologies, Information retrieval, Video summarization, Human computer interaction (HCI), Image and video acquisition, General programming languages, Video segmentation, Interaction paradigms, Artificial intelligence]
Static type checking of multi-methods
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Language features, Object oriented languages, Language types, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Data types and structures, Type structures, Functional constructs, Software and its engineering]
A static type system for message passing
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Procedures, functions and subroutines, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Data types and structures, Type structures, Software and its engineering]
Object-oriented type inference
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Theory of computation, Procedures, functions and subroutines, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering]
Issues in moving from C to C++
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Formal techniques for OO software development
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Software development methods, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Coherent models for object-oriented analysis
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Procedures, functions and subroutines, Software creation and management, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Theory of computation, Designing software, Semantics and reasoning, General programming languages, Functional constructs, Software and its engineering]
An empirical study of the object-oriented paradigm and software reuse
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Towards a metrics suite for object oriented design
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Cross-computing tools and techniques, Metrics, General programming languages, Object oriented languages, Language types, Software notations and tools, General and reference, Software and its engineering]
Communication as fair distribution of knowledge
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Parsers, Object oriented languages, Language types, Computing methodologies, Symbolic and algebraic manipulation, Software notations and tools, Theory of computation, Theorem proving algorithms, General programming languages, Symbolic and algebraic algorithms, Concurrent programming languages, Proof theory, Logic, Concurrent computing methodologies, Software and its engineering, Compilers]
The Kala basket: a semantic primitive unifying object transactions, access control, versions, and configurations
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[General programming languages, Object oriented languages, Data management systems, Language types, Database transaction processing, Software notations and tools, Database design and models, Information systems, Database management system engines, Software and its engineering]
An extensible kernel object management system
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Information storage systems, General programming languages, Object oriented languages, Language types, Data management systems, Software notations and tools, Record storage systems, Database design and models, Software and its engineering, Information systems, Database management system engines]
The economics of software reuse
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Management of computing and information systems, Software creation and management, Reusability, Object oriented languages, Professional topics, Language types, Software notations and tools, Software development techniques, Software management, General programming languages, Social and professional topics, Software and its engineering]
Islands: aliasing protection in object-oriented languages
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Theory of computation, Procedures, functions and subroutines, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Functional constructs, Software and its engineering]
Equate: an object-oriented constraint solver
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Procedures, functions and subroutines, Language features, Object oriented languages, Formalisms, Rewrite systems, Language types, Software notations and tools, Formal languages and automata theory, Theory of computation, Grammars and context-free languages, General programming languages, Software and its engineering]
Object-preserving class transformations
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[General programming languages, Object oriented languages, Language types, Data management systems, Software notations and tools, Database design and models, Software and its engineering, Information systems, Database management system engines]
Experiences in DBMS implementation using an object-oriented persistent programming language and a database toolkit
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Object oriented languages, Language types, Software notations and tools, Information systems, Database management system engines, Database query languages (principles), Theory of computation, Theory and algorithms for application domains, General programming languages, Data management systems, Database theory, Query languages, Software and its engineering]
Symbolic and spatial database for structural biology
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Applied computing, Life and medical sciences, Systems biology, Data management systems, Genetics, Database design and models, Computational biology, Information systems, Database management system engines]
Reengineering of old systems to an object-oriented architecture
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
OOP and AI
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Theory of computation, General programming languages, Object oriented languages, Language types, Computing methodologies, Software notations and tools, Logic, Knowledge representation and reasoning, Artificial intelligence, Software and its engineering]
Managing the transition to object-oriented technology
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Management of computing and information systems, Software creation and management, Object oriented languages, Language types, Professional topics, Software notations and tools, Collaboration in software development, General programming languages, Software management, Programming teams, Social and professional topics, Software and its engineering]
How to get your paper accepted at OOPSLA
Conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 26 ISSUE 11
1991
None
[Software creation and management, General programming languages, Object oriented languages, Documentation, Human-centered computing, Language types, Software notations and tools, Software post-development issues, Human computer interaction (HCI), Software and its engineering]
The design of the C++ Booch Components
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
This paper describes design issues encountered developing a reusable component library. The design applied encapsulation, inheritance, composition and type parameterization. The implementation uses various C++ mechanisms, including: virtual and static member functions, templates, and exceptions.The resulting library contains about 500 components (mostly template classes and functions) and an optional utility for instantiating templates. The components provide variations of basic collection/container abstractions with various time and space complexities.A key insight gained from this project: the design process centered on developing a "template for the templates" - designing a component framework and orderly process for generating the template classes.
[Designing software, Software creation and management, Reusability, General programming languages, Language features, Concurrent programming structures, Language types, Software notations and tools, Software development techniques, Software libraries and repositories, Software and its engineering]
An iterative-design model for reusable object-oriented software
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
We present an iterative-design approach for reusable object-oriented software that augments existing design methods by incorporating iteration into the design methodology and focuses on the set of problems within the domain, encouraging reuse of existing design information. The model has five separate stages which are described, before an example design is outlined using the model with sample code constructs in C++. Our results have shown a high degree of code reuse when using the model, directly attributable to two distinct design stages. An analysis of these results is also presented.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Reusability, Software development techniques, Software and its engineering]
Graphical specification of object oriented systems
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
The graphical notation <italic>Objectcharts,</italic> introduced in this paper, allows a developer to precisely specify the behaviour of object classes and to reason about the behaviour of particular configurations of objects.Objectcharts combine object oriented analysis and design techniques and Harel's statecharts to give a diagrammatic specification technique for object oriented systems.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Software development techniques, Software and its engineering]
Viewing object as patterns of communicating agents
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Following our own experience developing a concurrent object-oriented language as well of that of other researchers, we have identified several key problems in the design of a concurrency model compatible with the mechanisms of object-oriented programming. We propose an approach to language design in which an executable notation describing the behaviour of communicating agents is extended by syntactic patterns that encapsulate language constructs. We indicate how various language models can be accommodated, and how mechanisms such as inheritance can be modeled. Finally, we introduce a new notion of types that characterizes concurrent objects in terms of their externally visible behaviour.
[Software creation and management, Reusability, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Software development techniques, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Actors as a special case of concurrent constraint (logic) programming
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Saraswat recently introduced the framework of concurrent constraint programming [14]. The essence of the framework is that computations consist of concurrent agents interacting by communicating constraints. Several concurrent constraint programming languages have been defined. They differ in the kinds of constraints that can be used as well as the kinds of operations on constraints which are available. In this paper we introduce a very simple concurrent constraint language we call Lucy, designed to closely mimic the actor model of computation. Agents can communicate only by the posting of constraints upon bags (un-ordered collections possibly with duplicate elements). This very impoverished concurrent constraint language is a syntactic subset of Janus, a concurrent constraint language which closely resembles concurrent logic programming languages such as Guarded Horn Clauses [21], Strand [5], Parlog [2] and Flat Concurrent Prolog [13]. By identifying the subset of Janus which is an actor language, we elucidate the relationship between actors and concurrent logic programming (and its generalization as concurrent constraint programming). Lucy is best not thought of as a unification of logic and constraint programming with actor and object-oriented programming, but as the <italic>missing link</italic> between these programming language genera.
[Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Theory of computation, Models of computation, General programming languages, Concurrency, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering, Parallel computing models]
Beyond schema evolution to database reorganization
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
While the contents of databases can be easily changed, their organization is typically extremely rigid. Some databases relax the rigidity of database organization somewhat by supporting simple changes to individual schemas. As described in this paper, OTGen supports not only more complex schema changes, but also database reorganization. A database administrator uses a declarative notation to describe mappings between objects created with old versions of schemas and their corresponding representations using new versions. OTGen generates a transformer that applies the mappings to update the database to the new definitions, thus facilitating improvements in performance, functionality, and usability of the database.<supscrpt>1</supscrpt>
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Data management systems, Database administration, Database design and models, Information systems, Database management system engines, Software and its engineering]
Kaleidoscope: mixing objects, constraints, and imperative programming
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Kaleidoscope is an object-oriented language being designed to integrate the traditional <italic>imperative</italic> object-oriented paradigm with the less traditional <italic>declarative</italic> constraint paradigm. Imperative state changes provide sequencing while declarative constraints provide object relations. A <italic>variables as streams</italic> semantics enables the declarative-imperative integration. A running example is used to illustrate the language concepts-a reimplementation of the MacDraw II dashed-lines dialog box. The example is in three parts: the input channel, using imperative code to sequence through modes; the output channel, using constraints to update the display; and the internal relations, using constraints to maintain the data objects' consistency requirements. The last sections of the paper discuss <italic>views</italic> as a natural result of combining objects with constraints, as well as related and future work.
[Software creation and management, Language features, Language types, Software notations and tools, Software development techniques, Theory of computation, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Software and its engineering]
What tracers are made of
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
None
1990
None
[Software defect analysis, Software creation and management, Software verification and validation, Language features, Object oriented languages, Language types, Software notations and tools, Traceability, Software testing and debugging, General programming languages, Process validation, Software and its engineering]
A logical theory of concurrent objects
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
A new theory of concurrent objects is presented. The theory has the important advantage of being based directly on a logic called <italic>rewriting logic</italic> in which concurrent object-oriented computation exactly corresponds to logical deduction. This deduction is performed by <italic>concurrent rewriting</italic> modulo structural axioms of associativity, commutativity and identity that capture abstractly the essential aspects of communication in a distributed object-oriented configuration made up of concurrent objects and messages. Thanks to this axiomatization, it becomes possible to study the behavior of concurrent objects by formal methods in a logic intrinsic to their computation. The relationship with Actors and with other models of concurrent computation is also discussed. A direct fruit of this theory is a new language, called Maude, to program concurrent object-oriented modules in an entirely declarative way using rewriting logic; modules written in this language are used to illustrate the main ideas with examples. Maude contains OBJ3 as a functional sublanguage and provides a simple and semantically rigorous integration of functional programming and concurrent object-oriented programming.
[Language features, Concurrent programming structures, Formalisms, Rewrite systems, Language types, Software notations and tools, Formal languages and automata theory, Modules / packages, Theory of computation, Semantics and reasoning, Grammars and context-free languages, General programming languages, Programming logic, Program reasoning, Logic, Software and its engineering]
Message pattern specifications: a new technique for handling errors in parallel object oriented systems
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
As object oriented techniques enable the fabrication of ever more sophisticated systems, the need grows for a mechanism to ensure the consistent and 'correct' behaviour of each object at run-time. We describe a new, in-source specification mechanism, Message Pattern Specifications (MPS), to directly satisfy this need in a succinct, orthogonal and disciplined manner. Targeted for use in parallel object oriented systems, MPS allows programmers to enunciate the 'legal' patterns of run-time behaviour in which their objects may engage. Furthermore, it supports the definition of methods for object recovery or graceful failure in case these specifications are violated during execution.
[Cross-computing tools and techniques, Software creation and management, Computing methodologies, Language types, Extra-functional properties, Software notations and tools, Software reliability, Specification languages, Software development techniques, System description languages, General programming languages, Concurrent programming languages, Reliability, General and reference, Concurrent computing methodologies, Software organization and properties, Software and its engineering]
Garbage collection of actors
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
<italic>This paper considers the garbage collection of concurrent objects for which it is necessary to know not only "reachability," the usual criterion for reclaiming data, but also the "state" (active or blocked) of the object. For the actor model, a more comprehensive definition than previously available is given for reclaimable actors. Two garbage collection algorithms, implementing a set of "coloring" rules, are presented and their computational complexity is analyzed. Extensions are briefly described to allow incremental, concurrent, distributed and real-time collection. It is argued that the techniques used for the actor model applies to other object-based concurrent models</italic>.
[Software creation and management, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Software development techniques, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering, Compilers]
Structured analysis and object oriented analysis
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
The object-oriented paradigm still faces an open challenge: Delivering huge software systems routinely and cost effectively. To quote Ed Yourdon: "A system composed of 100,000 lines of C++ is not be sneezed at, but we don't have that much trouble developing 100,000 lines of COBOL today. The real test of OOP will come when systems of 1 to 10 million lines of code are developed."Although the object-oriented community has an opening flirtation with exploratory programming and rapid prototyping by exploiting reuse via inheritance, there is for now, in my opinion, no hope that huge systems can be developed without giving due attention to what a target system is supposed to do. Which should produce an (electronic) (graphical) (Pseudo-formal) document, the requirements, that a customer can initially sign off. We believe as well that for huge systems a programming language independent design activity, that bridges the requirements and the actual programming effort, is mandatory. It goes without saying that we do not suggest that these activities constitute a waterfall sequence.Consequently, the object-oriented community needs to address the question whether well established analysis techniques, like Structured Analysis, Jackson's JSD, etc. can be reused for object-oriented system development or whether a dedicated object-oriented analysis (and design) method is called for.The panel members have been asked to consider the following of question: What is the relationship between Structured Analysis (SA) and Object Oriented Analysis (OOA)?More specifically:<list><item>Can SA be used effectively to produce the requirements for a system that will be designed and implemented in an OO fashion?</item><item>If not, is it possible to adjust SA, what needs to be added? If SA cannot be used at all, what is the key obstacle?</item><item>In case SA and OOA have different applicability ranges, how do we circumscribe - positively and negatively - these ranges? Any overlap?</item></list>We appreciate that the organizing committee of this conference has selected this crucial topic.
[Designing software, Software creation and management, Reusability, Software notations and tools, Software development techniques, Software and its engineering]
Strong typing of object-oriented languages revisited
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
This paper is concerned with the relation between <italic>subtyping</italic> and <italic>subclassing</italic> and their influence on programming language design. Traditionally subclassing as introduced by Simula has also been used for defining a hierarchical type system. The type system of a language can be characterized as <italic>strong</italic> or <italic>weak</italic> and the type checking mechanism as <italic>static</italic> or <italic>dynamic</italic>. Parameterized classes in combination with a hierarchical type-system is an example of a language construct that is known to create complicated type checking situations. In this paper these situations are analyzed and several different solutions are found. It is argued that an approach with a combination of static and dynamic type checking gives a reasonable balance also here. It is also concluded that this approach makes it possible to base the type system on the class/subclass mechanism.
[Theory of computation, Software creation and management, Semantics and reasoning, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software development techniques, Program constructs, Type structures, Software and its engineering]
Type substitution for object-oriented programming
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Genericity allows the substitution of types in a class. This is usually obtained through parameterized classes, although they are inflexible since any class can be inherited but is not in itself parameterized. We suggest a new genericity mechanism, <italic>type substitution</italic>, which is a subclassing concept that complements inheritance: any class is generic, can be "instantiated" gradually without planning, and has all of its generic instances as subclasses.
[Procedures, functions and subroutines, Software creation and management, Reusability, Language features, Language types, Software notations and tools, Program constructs, Software development techniques, Theory of computation, Semantics and reasoning, General programming languages, Type structures, Software and its engineering, Compilers]
A parallel object-oriented language with inheritance and subtyping
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
This paper shows that inheritance and subtyping can be introduced advantageously into a parallel object-oriented language, POOL-I. These concepts are clearly distinguished, because they deal with different aspects of programming. In this way several problems traditionally adhering to inheritance can be solved. The language POOL-I is a parallel object-oriented language with a strong typing scheme which includes genericity and dynamic binding. A novel and particularly powerful mechanism offers the possibility to manipulate and analyse types dynamically.
[Software creation and management, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Program constructs, Software development techniques, Theory of computation, Semantics and reasoning, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Type structures, Software and its engineering]
Contracts: specifying behavioral compositions in object-oriented systems
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Behavioral compositions, groups of interdependent objects cooperating to accomplish tasks, are an important feature of object-oriented systems. This paper introduces <italic>Contracts</italic>, a new technique for specifying behavioral compositions and the obligations on participating objects. Refinement and composition of contracts allows for the creation of large grain abstractions based on behavior, orthogonal to those provided by existing class constructs. Using contracts thus provides a basis and vocabulary for <italic>Interaction-Oriented</italic> design which greatly facilitates the early identification, abstraction and reuse of patterns of behavior in programs. Contracts differ from previous work in that they capture explicitly and abstractly the behavioral dependencies amongst cooperating objects. By explicitly stating these dependencies, contract also provide an effective aid for program understanding and reuse.
[Theory of computation, Software creation and management, Semantics and reasoning, Reusability, General programming languages, Language features, Software notations and tools, Software development techniques, Program constructs, Software and its engineering]
When objects collide experiences with reusing multiple class hierarchies
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Well-designed reusable class libraries are often incompatible due to architectural mismatches such as error-handling and composition conventions. We identify five <italic>pragmatic dimensions</italic> along which combinations of subsystems must match, and present detailed examples of conflicts resulting from mismatches. Examples are drawn from our experiences of integrating five subsystem-level class hierarchies into an object-oriented hypertext platform. We submit that effective reuse will require that these pragmatic decisions be explicitly identified in descriptions of reusable software. Such descriptions will enable developers to identify and combine subsystems whose architectures are compatible.
[Software creation and management, Reusability, General programming languages, Language features, Software notations and tools, Error handling and recovery, Modules / packages, Software development techniques, Software libraries and repositories, Software and its engineering]
PCLOS: stress testing CLOS experiencing the metaobject protocol
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
This paper demonstrates that the CLOS <italic>metaobject protocol</italic> approach to defining and implementing an object model is very powerful. CLOS is an object-oriented language that is based on Common Lisp and is in the process of being standardized. Implementations of CLOS are themselves object-oriented with all major building blocks of the language being instances of system classes. A metaobject protocol provides a framework for CLOS implementations by specifying the hierarchy of these classes and the order and contents of the communication among their instances. This design has made CLOS both flexible and portable, two design goals that traditionally conflict. In support of this suggestion we present a detailed account of how we added object persistence to CLOS without modifying any of the language's implementation code.
[Software creation and management, Reusability, General programming languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Reasoning about object-oriented programs that use subtypes
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Programmers informally reason about object-oriented programs by using subtype relationships to classify the behavior of objects of different types and by letting supertypes stand for all their subtypes. We describe formal specification and verification techniques for such programs that mimic these informal ideas. Our techniques are modular and extend standard techniques for reasoning about programs that use abstract data types. Semantic restrictions on subtype relationships guarantee the soundness of these techniques.
[Software creation and management, Software functional properties, Language features, Language types, Software notations and tools, Correctness, Modules / packages, Software development techniques, Theory of computation, General programming languages, Data types and structures, Functional languages, Proof theory, Logic, Software organization and properties, Software and its engineering]
Type consistency of queries in an object-oriented database system
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Queries in object-oriented databases can return non-homogeneous sets of objects when no type restrictions are placed on the inputs to the query. The tradition has been to force homogeneity on the result by restricting the types of the inputs. This restricts the range of permissible, and possibly useful, queries. We propose a type consistency theory for queries in object-oriented databases which supports the existence of multiple types in the query result. The technique is illustrated by developing type inference rules for an object algebra. The main result is that the loss of type information associated with a query operation is reduced in most cases. We also show how type information is increased when queries are qualified by conjunctive predicates.
[Software creation and management, Software development techniques, Program constructs, Information systems, Database management system engines, Database query languages (principles), Theory of computation, Database query processing, Theory and algorithms for application domains, Semantics and reasoning, Database query processing and optimization (theory), Data management systems, Database theory, Type structures, Query languages, Software and its engineering]
Issues in object database management
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
While the availability of commercial systems from several vendors indicates maturity in object database management technology, there are numerous issues which remain. This panel will attempt to expose and discuss several of these issues.Part of the performance advantage realized by object database management systems comes from linking application programs with the database management system, and the use of large virtual memory caches. This is acceptable in engineering applications where previously large amounts of data were read from the file system into an application program's data space. However, the potential impact on database integrity of giving application programs direct access to very large database management system caches will be of great concern in commercial applications. How can these concerns be addressed with minimal impact on the performance advantage of object database management?There appear to be two distinct approaches to object query languages: extensions to SQL and programming language extensions. SQL extensions might provide a fast path to a standard, but would have the traditional impedance mismatch problems associated with embedded query languages. Language extensions are elegant in that they use the same syntax as the programming language and do not suffer from impedance mismatch problems. However, language extensions would probably make standards more difficult to arrive at as it would require the coordination of extensions to multiple languages. Which of the approaches is most appropriate? In which order should these two approaches be addressed by the object database vendors and standards bodies?One might argue that a good deal of research in relational theory has had little or no impact on commercial relational systems (e.g., relational dependence theory). From a vendor's perspective, what are the hard, interesting research issues whose resolution would allow you to build better systems?
[Software creation and management, Language types, Software notations and tools, Software development techniques, Information systems, Database management system engines, Database query languages (principles), Theory of computation, Theory and algorithms for application domains, General programming languages, Data management systems, Database design and models, Database theory, Query languages, Software and its engineering]
A framework for visualizing object-oriented systems
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
This paper describes a new approach to visualizing program systems within the object-oriented paradigm. This approach is based on a TEX-like notation which has been extended and generalized for specifying graphical layout of arbitrary objects. The CLOS meta-level architecture is used to associate visualization and application objects. We propose several useful techniques such as indirect values, slot and method demons, and instance-specific meta-objects. Our techniques require no modifications to the systems which are selected for visualization. We demonstrate the feasibility of our approach using application domains such as CLOS debugging and constraint systems.
[Software creation and management, Integrated and visual development environments, General programming languages, Language types, Software notations and tools, Software development techniques, Development frameworks and environments, Software and its engineering]
Painting multiple views of complex objects
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
This paper reviews and illustrates a direct manipulation approach to visualization of complex objects called <italic>painting multiple views</italic>. We describe a programming model for direct manipulation in general and for painting in particular, based on simple constraints between entities in an the underlying scientific database and the components of displays used to examine the data. With this model, the original notion of "brushing scatterplots" is easily extended.
[Human-centered computing, Computing methodologies, Language types, Software notations and tools, Human computer interaction (HCI), Graphics systems and interfaces, Development frameworks and environments, Interaction devices, Integrated and visual development environments, General programming languages, Graphics input devices, Computer graphics, Software and its engineering]
MoDE: a UIMS for Smalltalk
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
While the Model-View-Controller (MVC) framework has contributed to many aspects of user interface development in Smalltalk, interfaces produced with MVC often have highly coupled model, view, and controller classes. This coupling and the effort required to use MVC make user interface creation a less effective aspect of Smalltalk.The Mode Development Environment (MoDE) is a user interface management system (UIMS) which addresses the above issues. MoDE is composed of two major components: the Mode framework and the Mode Composer. The Mode framework accommodates an orthogonal design which decouples the user interface components and increases their reusability. The Mode Composer reduces the effort of using MoDE by providing a direct-manipulation user interface to its users. This paper discusses the importance of orthogonality and illustrates its incorporation into the design of MoDE. A comparison of the Mode framework and the MVC framework is included.
[Designing software, Software creation and management, Integrated and visual development environments, General programming languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
COOL: kernel support for object-oriented environments
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
The Chorus Object-Oriented Layer (COOL) is an extension of the facilities provided by the Chorus distributed operating system with additional functionality for the support of object-oriented environments. This functionality is realized by a layer built on top of the Chorus V3 Nucleus, which extends the Chorus interface with generic functions for object management: creation, deletion, storage, remote invocation and migration. One major goal of this approach was to explore the feasibility of general object management at the kernel level, with support of multiple object models at a higher level. We present the implementation of COOL and a first evaluation of this approach with a C++ environment using the COOL mechanisms.
[Software system structures, Designing software, Software creation and management, General programming languages, Language features, Language types, Software notations and tools, Software development techniques, Software organization and properties, Software and its engineering, Distributed systems organizing principles]
The performance of an object-oriented threads package
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Presto is an object-oriented threads package for writing parallel programs on a shared-memory multiprocessor. The system adds thread objects and synchronization objects to C++ to allow programmers to create and control parallelism. Presto's object-oriented structure, along with its user-level thread implementation, simplifies customization of thread management primitives to meet application-specific needs.The performance of thread primitives is crucial for parallel programs with fine-grained structure; therefore, the principal objective of this effort was to substantially improve Presto's performance under heavy loads without sacrificing the benefits of its object-oriented interface. We discuss design and implementation issues for shared-memory multiprocessors, and the performance impact of various designs is shown through measurements on a 20-processor Sequent Symmetry multiprocessor.
[Software creation and management, General programming languages, Language features, Concurrent programming structures, Language types, Computing methodologies, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software development techniques, Software and its engineering]
Object-oriented real-time language design: constructs for timing constraints
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
We propose a new object-oriented programming language called RTC++ for programming real-time applications. RTC++ is an extension of C++ and its features are to specify i) a real-time object which is an active entity, ii) timing constraints in an operation as well as in statements, and iii) a periodic task with rigid timing constraints.In this paper, we first discuss real-time programming issues and what language support should be provided for building real-time applications. Then, the key features of RTC++ are described. Some programming examples are shown to demonstrate RTC++'s expressive power. A comparison to other programming languages are also discussed.
[Computer systems organization, Software creation and management, General programming languages, Embedded and cyber-physical systems, Language types, Software notations and tools, Real-time systems, Software development techniques, Software and its engineering]
OOP in the real world
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
Some advocates of OOP have promised that it will make all code reusable, shorten development cycles, remove the applications backlog, cure the common cold and plug the hole in the ozone layer.How well does actual experience bear this out?Success stories are published much more often than failures and false starts. This is very unfortunate since the former two are often much more instructive.This panel will attempt to bring the less successful experiences to light, and hopefully, will provide lessons on how to do better.
[Designing software, Software creation and management, Reusability, General programming languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Mixin-based inheritance
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
The diverse inheritance mechanisms provided by Smalltalk, Beta, and CLOS are interpreted as different uses of a single underlying construct. Smalltalk and Beta differ primarily in the direction of class hierarchy growth. These inheritance mechanisms are subsumed in a new inheritance model based on composition of <italic>mixins,</italic> or abstract subclasses. This form of inheritance can also encode a CLOS multiple-inheritance hierarchy, although changes to the encoded hierarchy that would violate encapsulation are difficult. Practical application of mixin-based inheritance is illustrated in a sketch of an extension to Modula-3.
[Software creation and management, General programming languages, Language features, Language types, Software notations and tools, Software development techniques, Software and its engineering]
The point of view notion for multiple inheritance
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
We examine several problems related to the preservation of the Independence Principle inheritance. This principle states that all the characteristics of independent superclasses must be inherited by subclasses, even if there are name conflicts. In this context, a conventional approach is to use explicit class selection. We show that this mechanism suffers from serious limitations, and leads to inhibition of refinement and genericity. Our experimental object-oriented language ROME introduces the "Point of View" notion (using an "as-expressions" mechanism) which solves these problems.
[Designing software, Software creation and management, General programming languages, Language features, Language types, Software notations and tools, Modules / packages, Software development techniques, Software and its engineering]
Exception handling and object-oriented programming: towards a synthesis
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
The paper presents a discussion and a specification of an exception handling system dedicated to object-oriented programming. We show how a full object-oriented representation of exceptions and of protocols to handle them, using meta-classes, makes the system powerful as well as extendible and solves many classical exception handling issues. We explain the interest for object-oriented programming of handlers attached to classes and to expressions. We propose an original algorithm for propagating exceptions along the invocation chain which takes into account, at each stack level, both kind of handlers. Any class can control which exceptions will be propagated out of its methods; any method can provide context-dependant answers to exceptional events. The whole specification and some keys of our <italic>Smalltalk</italic> implementation are presented in the paper.
[Control structures, Software defect analysis, Software creation and management, Reusability, Software testing and debugging, General programming languages, Language features, Software verification and validation, Software notations and tools, Software development techniques, Software and its engineering]
OOPSLA distributed object management
Proceedings of the European conference on object-oriented programming on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 25 ISSUE 10
1990
None
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, General programming languages, Language features, Software notations and tools, Software development techniques, Software and its engineering]
Regular types for active objects
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Procedures, functions and subroutines, Object oriented languages, Language features, Language types, Software notations and tools, Calculus, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Mathematical analysis, Lambda calculus, Continuous mathematics, Data types and structures, Mathematics of computing, Type structures, Software and its engineering]
Specifications and their use in defining subtypes
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software creation and management, Software development methods, Object oriented languages, Language types, Software notations and tools, Program constructs, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Type structures, Software and its engineering]
Safe and decidable type checking in an object-oriented language
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Object oriented languages, Language types, Software notations and tools, Calculus, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Mathematical analysis, Lambda calculus, Continuous mathematics, Mathematics of computing, Type structures, Software and its engineering]
Tools for the development of application-specific virtual memory management
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software defect analysis, Software creation and management, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Contextual software domains, Development frameworks and environments, Information systems, Database management system engines, Integrated and visual development environments, Software testing and debugging, Operating systems, General programming languages, Memory management, Virtual memory, Data management systems, Software organization and properties, Software and its engineering]
Experiences developing and using an object-oriented library for program manipulation
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software defect analysis, Software creation and management, Software testing and debugging, General programming languages, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Software libraries and repositories, Software and its engineering]
Status of object-oriented COBOL (panel)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[General programming languages, Object oriented languages, Document types, Language types, Software notations and tools, General and reference, Computing standards, RFCs and guidelines, Software and its engineering]
CHARM++: a portable concurrent object oriented system based on C++
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Computing methodologies, Parallel computing methodologies, Software notations and tools, Parallel programming languages, Software development techniques, Software and its engineering]
Highly efficient and encapsulated re-use of synchronization code in concurrent object-oriented languages
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Procedures, functions and subroutines, Software creation and management, Reusability, Object oriented languages, Language features, Language types, Software notations and tools, Parallel programming languages, Software development techniques, Distributed programming languages, General programming languages, Concurrent programming languages, Software and its engineering]
Ada 9X: from abstraction-oriented to object-oriented
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Abstract data types, Program constructs, Type structures, Software and its engineering]
Developing software for large-scale reuse (panel)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Management of computing and information systems, Software creation and management, Reusability, Object oriented languages, Language types, Professional topics, Software notations and tools, Software development techniques, Pricing and resource allocation, General programming languages, Software management, Implementation management, Social and professional topics, Software and its engineering]
The Amadeus GRT: generic runtime support for distributed persistent programming
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Distributed programming languages, General programming languages, Object oriented languages, Language features, Data types and structures, Language types, Computing methodologies, Software notations and tools, Distributed computing methodologies, Software libraries and repositories, Software and its engineering]
Object distribution in Orca using Compile-Time and Run-Time techniques
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Language features, Software performance, Professional topics, Paths and connectivity problems, Software notations and tools, Extra-functional properties, Data types and structures, Discrete mathematics, Mathematics of computing, Social and professional topics, Software organization and properties, Software and its engineering, Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Language types, Computing methodologies, Parallel computing methodologies, Graph theory, Parallel programming languages, General programming languages, Software management, Performance, General and reference, Compilers]
Object-oriented execution of OPS5 production systems
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software creation and management, Software development methods, Object oriented languages, Language types, Computing methodologies, Context specific languages, Software notations and tools, Software development process management, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
IRIS Inventor, a 3D graphics toolkit
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software design techniques, Software creation and management, Object oriented languages, Language types, Human-centered computing, Computing methodologies, Software notations and tools, Human computer interaction (HCI), Graphics systems and interfaces, Software implementation planning, Interaction devices, Designing software, Software development process management, General programming languages, Graphics input devices, Computer graphics, Animation, Software and its engineering]
Typing the specialization interface
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software creation and management, Reusability, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Development frameworks and environments, Software development techniques, Theory of computation, Semantics and reasoning, Integrated and visual development environments, General programming languages, Data types and structures, Type structures, Software and its engineering]
Strongtalk: typechecking Smalltalk in a production environment
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Procedures, functions and subroutines, Language features, Object oriented languages, Language types, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Functional constructs, Type structures, Software and its engineering]
Inheritance modeled with explicit bindings: an approach to typed inheritance
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering]
On the purpose of object-oriented analysis
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Validation, Cross-computing tools and techniques, Management of computing and information systems, System management, Software creation and management, Empirical software validation, Object oriented languages, Software verification and validation, Language types, Professional topics, Software notations and tools, Quality assurance, General programming languages, Software management, Process validation, Social and professional topics, General and reference, Software and its engineering]
A discussion of On the Purpose of Object-Oriented Analysis
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Designing software, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Selector table indexing &amp; sparse arrays
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Procedures, functions and subroutines, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Functional constructs, Software and its engineering, Compilers]
Efficient handling of multiple inheritance hierarchies
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Trees, Object oriented languages, Software functional properties, Language features, Language types, Software notations and tools, Graph theory, Correctness, Theory of computation, General programming languages, Discrete mathematics, Mathematics of computing, Proof theory, Logic, Software organization and properties, Software and its engineering]
Object fault handling for persistent programming languages: a performance evaluation
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Object oriented languages, Software performance, Language types, Professional topics, Software notations and tools, Extra-functional properties, General programming languages, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
Integrating object-oriented technology and security technology
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Object oriented languages, Information systems applications, Language types, Software notations and tools, Information systems, Database management system engines, Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, General programming languages, Data management systems, Database theory, Theory of database privacy and security, Software and its engineering]
Modeling security requirements for applications
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Human and societal aspects of security and privacy, Computing / technology policy, Privacy policies, Information systems, Database management system engines, Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, Data management systems, Social and professional topics, Database design and models, Database theory, Theory of database privacy and security]
Object oriented approach to MLS database application design
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, Data management systems, Information systems applications, Database theory, Theory of database privacy and security, Information systems, Database management system engines]
Security for OODBMS (or systems)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, Data management systems, Database design and models, Database theory, Theory of database privacy and security, Information systems, Database management system engines]
Reconciling objects and multilevel security
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, Data management systems, Database design and models, Database theory, Theory of database privacy and security, Information systems, Database management system engines]
GROOP: an object-oriented toolkit for animated 3D graphics
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Simulation types and techniques, Object oriented languages, Language types, Computing methodologies, Software notations and tools, Graphics systems and interfaces, Program constructs, Development frameworks and environments, Theory of computation, Semantics and reasoning, Modeling and simulation, Integrated and visual development environments, General programming languages, Computer graphics, Animation, Functional constructs, Software and its engineering]
Visualizing the behavior of object-oriented systems
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Visual languages, Object oriented languages, Language types, Context specific languages, Software notations and tools, Program constructs, Development frameworks and environments, Theory of computation, Semantics and reasoning, Integrated and visual development environments, General programming languages, Type structures, Software and its engineering]
Structural active object systems for simulation
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Visual languages, Simulation types and techniques, Object oriented languages, Language types, Computing methodologies, Context specific languages, Software notations and tools, Simulation and emulation, Development frameworks and environments, Functional verification, Modeling and simulation, Integrated and visual development environments, General programming languages, Hardware validation, Hardware, Software and its engineering]
Software architecture: the next step for object technology (panel)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Management of computing and information systems, Project and people management, Software creation and management, Object oriented languages, Language types, Professional topics, Software notations and tools, Software configuration management and version control systems, Software development process management, General programming languages, Software management, Social and professional topics, Software and its engineering]
Is multiple inheritance essential to OOP? (panel)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Software and its engineering]
Impacts of object-oriented technologies: seven years of SEL studies
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Management of computing and information systems, Project and people management, Software creation and management, Reusability, Object oriented languages, Language types, Professional topics, Software notations and tools, Software development techniques, Physical sciences and engineering, Software configuration management and version control systems, Applied computing, Software development process management, General programming languages, Software management, Aerospace, Social and professional topics, Software and its engineering]
Evolving toward object-oriented technology in large organizations (panel)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Management of computing and information systems, Software creation and management, General programming languages, Object oriented languages, Software management, Language types, Professional topics, Software notations and tools, Social and professional topics, Software and its engineering]
Roles for composite objects in object-oriented analysis and design
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Object oriented languages, Language types, Software notations and tools, Computers in other domains, Formal languages and automata theory, Theory of computation, Applied computing, Computer systems organization, Semantics and reasoning, General programming languages, Formal language definitions, Real-time systems, Program reasoning, Logic, Software and its engineering]
Building and maintaining analysis-level class hierarchies using Galois Lattices
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Software creation and management, Reusability, Object oriented languages, Language types, Software notations and tools, Graph theory, Software development techniques, Theory of computation, Designing software, General programming languages, Discrete mathematics, Mathematics of computing, Design and analysis of algorithms, Software and its engineering]
Subject-oriented programming: a critique of pure objects
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Trees, Procedures, functions and subroutines, Object oriented languages, Language features, Language types, Software notations and tools, Graph theory, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Discrete mathematics, Mathematics of computing, Functional constructs, Software and its engineering]
How to get a paper accepted at OOPSLA (panel)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[General conference proceedings, General programming languages, Object oriented languages, Document types, Language types, Software notations and tools, General and reference, Software and its engineering]
Strategies for object-oriented technology transfer (panel)
Proceedings of the eighth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 28 ISSUE 10
1993
None
[Management of computing and information systems, Project and people management, Software creation and management, Object oriented languages, Language types, Professional topics, Software notations and tools, Computing and business, Software configuration management and version control systems, Software development process management, Computer and information systems training, General programming languages, Software management, Social and professional topics, Software and its engineering]
Interfaces and specifications for the Smalltalk-80 collection classes
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Integrated and visual development environments, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Monotonic conflict resolution mechanisms for inheritance
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Combination of inheritance hierarchies
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Reuse (panel): truth or fiction
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Software notations and tools, Software development techniques, Software libraries and repositories, Software and its engineering]
The process of object-oriented design
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Designing software, Software creation and management, General programming languages, Object oriented languages, Language features, Data types and structures, Language types, Software notations and tools, Software and its engineering]
Documenting frameworks using patterns
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software creation and management, Reusability, Human-centered computing, Computing methodologies, Human computer interaction (HCI), Graphics systems and interfaces, Software development techniques, Interaction devices, Designing software, Graphics input devices, Computer graphics, Software and its engineering]
OOP in languages providing strong, static typing (panel session)
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Position paper for OOPSLA '92 panel on oop for manguages based on strong, static typing
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Ensuring strong typing in an object-oriented language (abstract)
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Trellis: what we have learned from a strongly typed language
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
A comparative performance evaluation of write barrier implementation
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Operating systems, General programming languages, Memory management, Language features, Allocation / deallocation strategies, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Optimizing method search with lookup caches and incremental coloring
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language features, Language types, Discrete mathematics, Software notations and tools, Graph theory, Mathematics of computing, Software and its engineering]
Object-oriented concurrent reflective languages can be implemented efficiently
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Distributed programming languages, General programming languages, Object oriented languages, Language types, Software notations and tools, Concurrent programming languages, Parallel programming languages, Software and its engineering]
Visualizing objects: methods for exploring human computer interaction concepts
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Management of computing and information systems, Software creation and management, Object oriented languages, Human-centered computing, Professional topics, Language types, Software notations and tools, Human computer interaction (HCI), Software management, General programming languages, Social and professional topics, Software and its engineering]
The object-oriented implementation of a document editor
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Applied computing, General programming languages, Document management and text processing, Format and notation, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Interaction paradigms, Document preparation, Software and its engineering]
ET++SwapsManager: using object technology in the financial engineering domain
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software creation and management, Reusability, Object oriented languages, Language types, Human-centered computing, Software notations and tools, Human computer interaction (HCI), Software development techniques, Applied computing, Enterprise computing, General programming languages, Interaction paradigms, Software and its engineering]
Preliminary defect data from the iterative development of a large C++ program (experience report)
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software design techniques, Software creation and management, Software development methods, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Software implementation planning, Designing software, Software development process management, General programming languages, Software and its engineering]
Declarative programming in a prototype-instance system: object-oriented programming without writing methods
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Integrated and visual development environments, General programming languages, Object oriented languages, Interactive systems and tools, Language types, Human-centered computing, User interface management systems, Software notations and tools, Human computer interaction (HCI), Development frameworks and environments, Software and its engineering]
Prototype-based languages: from a new taxonomy to constructive proposals and their validation
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Constraint patterns as a basis for object oriented programming
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Object oriented languages, Language types, Formalisms, Rewrite systems, Software notations and tools, Formal languages and automata theory, Program constructs, Theory of computation, Semantics and reasoning, Grammars and context-free languages, General programming languages, Functional constructs, Software and its engineering]
Experimental classification facilities for Smalltalk
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Rule learning, General programming languages, Object oriented languages, Machine learning, Language types, Computing methodologies, Machine learning approaches, Software notations and tools, Knowledge representation and reasoning, Artificial intelligence, Software and its engineering]
Distributed shared memory with versioned objects
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software creation and management, Object oriented languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Software post-development issues, Parallel programming languages, Contextual software domains, Distributed memory, Software configuration management and version control systems, Software version control, Operating systems, General programming languages, Memory management, Software organization and properties, Software and its engineering]
CACL: efficient fine-grained protection for objects
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Access control, Object oriented languages, Language types, Systems security, Software notations and tools, Operating systems security, Information systems, Database management system engines, Security and privacy, General programming languages, Data management systems, Security services, Software and its engineering]
DROL: an object-oriented programming language for distributed real-time systems
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Object oriented languages, Language types, Computing methodologies, Software notations and tools, Distributed computing methodologies, Program constructs, Theory of computation, Semantics and reasoning, Distributed programming languages, General programming languages, Functional constructs, Software and its engineering]
From events to objects (panel): the heresy of event-orientation in a world of objects
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Modeling and simulation, General programming languages, Object oriented languages, Language types, Computing methodologies, Software notations and tools, Software and its engineering]
Ensuring semantic integrity of reusable objects (panel)
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software defect analysis, Software creation and management, Reusability, Software testing and debugging, General programming languages, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Communication mechanism on autonomous objects
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Control methods, Object oriented languages, Embedded and cyber-physical systems, Language types, Computing methodologies, Software notations and tools, Planning and scheduling, Robotics, Computer systems organization, General programming languages, Robotic planning, Concurrent programming languages, Artificial intelligence, Concurrent computing methodologies, Software and its engineering]
A formalism for real-time concurrent object-oriented computing
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Operational semantics, Object oriented languages, Language types, Computing methodologies, Software notations and tools, Formal languages and automata theory, Theory of computation, Semantics and reasoning, General programming languages, Program semantics, Formal language definitions, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Concurrency annotations
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software creation and management, Reusability, Object oriented languages, Computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software development techniques, Distributed programming languages, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering, Compilers]
Obstacles in object-oriented software development
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Management of computing and information systems, Software creation and management, Reusability, Object oriented languages, Language types, Professional topics, Software notations and tools, Software development techniques, Information systems, Database management system engines, General programming languages, Software management, Data management systems, Social and professional topics, Software and its engineering]
Object-oriented system modeling with OMT
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Management of computing and information systems, Software creation and management, Object oriented languages, Professional topics, Computing education, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Computing education programs, Collaboration in software development, Software management, General programming languages, Programming teams, Computer science education, Social and professional topics, Software and its engineering]
Case study of object-oriented software development
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Validation, Cross-computing tools and techniques, Management of computing and information systems, Software creation and management, Empirical software validation, Object oriented languages, Software verification and validation, Language types, Professional topics, Software notations and tools, Collaboration in software development, General programming languages, Software management, Process validation, Programming teams, Social and professional topics, General and reference, Software and its engineering]
Object-oriented megaprogramming (panel)
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Distributed programming languages, General programming languages, Object oriented languages, Language types, Computing methodologies, Software notations and tools, Distributed computing methodologies, Software and its engineering]
Lightweight shared objects in a 64-bit operating system
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software system structures, Operating systems, Memory management, Virtual memory, General programming languages, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Distributed systems organizing principles]
The Apertos reflective operating system: the concept and its implementation
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Object oriented languages, Language types, Software notations and tools, Contextual software domains, Distributed systems organizing principles, Software system structures, Operating systems, General programming languages, Memory management, Virtual memory, Software organization and properties, Software and its engineering, Process management]
Issues in the design and specification of class libraries
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Turnable formalism in object-oriented systems analysis: meeting the needs of both theoreticians and practitioners
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Theory of computation, Models of computation, General programming languages, Object oriented languages, Language types, Software notations and tools, Logic, Computability, Software and its engineering]
Architectures with pictures
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Visual languages, Designing software, Software creation and management, General programming languages, Object oriented languages, Language types, Context specific languages, Software notations and tools, Software and its engineering]
The OO software development process (panel)
conference proceedings on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 27 ISSUE 10
1992
None
[Software implementation planning, Software design techniques, Software development process management, Designing software, Software creation and management, Software development methods, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Typechecking and modules for multi-methods
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Two major obstacles hindering the wider acceptance of multi-methods are concerns over the lack of encapsulation and modularity and the absence of static typechecking in existing multi-method-based languages. This paper addresses both of these problems. We present a polynomial-time static typechecking algorithm that checks the conformance, completeness, and consistency of a group of method implementations with respect to declared message signatures. This algorithm improves on previous algorithms by handling separate type and inheritance hierarchies, abstract classes, and graph-based method lookup semantics. We also present a module system that enables independently-developed code to be fully encapsulated and statically typechecked on a per-module basis. To guarantee that potential conflicts between independently-developed modules have been resolved, a simple well-formedness condition on the modules comprising a program is checked at link-time. The typechecking algorithm and module system are applicable to a range of multi-method-based languages, but the paper uses the Cecil language as a concrete example of how they can be applied.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Modules / packages, Program constructs, Type structures, Software and its engineering]
Type-theoretic foundations for concurrent object-oriented programing
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
A number of attempts have been made to obtain type systems for object-oriented programming. The view that lies common is "<italic>object-oriented programming = &lgr;-calculus + record</italic>." Based on an analogous view "<italic>concurrent object-oriented programming = concurrent calculus + record</italic>," we develop a static type system for concurrent object-oriented programming. We choose our own Higher-Order ACL as a basic concurrent calculus, and show that a concurrent object-oriented language can be easily encoded in the Higher-Order ACL extended with record operations. Since Higher-Order ACL has a strong type system with a polymorphic type inference mechanism, programs of the concurrent object-oriented language can be automatically type-checked by the encoding in Higher-Order ACL. Our approach can give clear accounts for complex mechanisms such as inheritance and method overriding within a simple framework.
[Object oriented languages, Language types, Computing methodologies, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Concurrent programming languages, Type structures, Concurrent computing methodologies, Software and its engineering]
Training professionals in object technology (panel): training professionals in object technology
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
None
[Management of computing and information systems, Project and people management, Computer and information systems training, Professional topics, Social and professional topics]
Ode: a self-guided, scenario-based learning environment for object-oriented design principles
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
None
[Management of computing and information systems, Project and people management, Object oriented languages, Language types, Professional topics, Computing education, Software notations and tools, Computing education programs, General programming languages, Computer science education, Social and professional topics, Software and its engineering]
Virtual images: interactive visualization of distributed object-oriented systems
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
In spite of growing needs in many areas, there is a lack of powerful graphical interfaces for interacting with large and complex sets of objects. Debugging, management and monitoring tools for object-oriented distributed systems or databases, for instance, need new interfaces that allow high quality visualization and interaction.We propose to use 3D interactive animations for representing large numbers of objects, complex relationships, and dynamic execution of concurrent activities. These innovative graphical representations, that we call <italic>virtual images</italic>, provide a consistent and intuitive solution for integrating various functionalities, considerably increasing the amount of information processed by the user. This technique has been successfully applied without specific hardware, demonstrating the feasibility of such interfaces on non specialized workstations.
[Parallel and distributed DBMSs, Object oriented languages, Computing methodologies, Language types, Software notations and tools, Development frameworks and environments, Information systems, Database management system engines, Integrated and visual development environments, General programming languages, Computer graphics, Data management systems, Animation, Software and its engineering]
Building tailorable hypermedia systems: the embedded-interpreter approach
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
This paper discusses an approach for developing dynamically tailorable hypermedia systems in an object-oriented environment. The approach is aimed at making applications developed in compiled languages like Beta and C++ tailorable at run-time. The approach is based on use of: 1) a hypermedia application framework (DEVISE Hyper-media), and 2) an embeddable interpreter for the framework language. A specific hypermedia system is instantiated from the framework with the interpreter embedded in the executable. The specific hypermedia system has a number of "open points" which can be filled via the interpreter at run-time. These open points and the interpreter provide sufficient support to allow tailoring at run-time as well as compile-time. Among the types of tailoring supported are: 1) adding new media-types, 2) alternating editors for supported media-types, and 3) removing a supported media-type. The paper describes the framework and illustrates how the interpreter is integrated. It describes steps involved in tailoring a specific hypermedia system with a new drawing media-type, where graphical objects can be endpoints for links. Since the hypermedia framework uses a persistent object-store, a solution for handling persistent interpreted objects is presented. Finally, the approach is compared with other environments supporting tailoring.
[Visualization, Object oriented languages, Hypertext / hypermedia, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Visualization techniques, General programming languages, Interpreters, Interaction paradigms, Software and its engineering, Compilers]
Prototype-based languages (panel): object lessons from class-free programming
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
A distributed garbage collector for active objects
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
This paper presents an algorithm that performs garbage collection in distributed systems of active objects (i.e., objects having their own threads of control). Our proposition extends the basic marking algorithm proposed by Kafura in [1] to a distributed environment. The proposed garbage collector is made up of a set of local garbage collectors, one per site, loosely coupled to a (logically centralized) global garbage collector that maintains a global snapshot of the system state relevant to garbage collection. The specific features of the proposed garbage collector are that local garbage collectors need not be synchronized with each other for detecting garbage objects, and that faulty sites and communication channels are tolerated. The paper describes the proposed garbage collector, together with its implementation and performance for a concurrent object-oriented language running on a local area network of workstations.
[Operating systems, Memory management, General programming languages, Object oriented languages, Allocation / deallocation strategies, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Persistent shared object support in the Guide system: evaluation &amp; related work
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
The purpose of the Guide project is to explore the use of shared objects for communication in a distributed system, especially for applications that require cooperative work. Since 1986, two prototypes have been implemented respectively on top of Unix (Guide-1) and Mach 3.0 (Guide-2). They have been used for the development of distributed cooperative applications, allowing us to validate or reject many design choices in the system.This paper gathers the lessons learned from our experience and compares the basic design choices with those in other distributed object-oriented systems. The lessons may be summarized as follows. This system layer must provide a generic interface for the support of several object-oriented languages. It must manage fine grained objects and enforce protection between objects and processes. These requirements can be achieved with an acceptable trade-off between protection and efficiency.
[Software implementation planning, Software design techniques, Software system structures, Designing software, Software development process management, Software creation and management, Software organization and properties, Software and its engineering, Distributed systems organizing principles]
Smalltalk in the business world (panel): the good, the bad, and the future
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
None
[General programming languages, Language types, Software notations and tools, Software and its engineering]
Genericity versus inheritance reconsidered: self-reference using generics
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
As shown by the work of Bertrand Meyer, it is possible to simulate genericity using inheritance, but not vice-versa. This is because genericity is a parameterization mechanism with no way to deal with the polymorphic typing introduced using inheritance. Nevertheless, if we focus on the use of inheritance as an implementation technique, its key feature is the dynamic binding of self-referential operation calls. This turns out to be basically a parameterization mechanism that can in fact be simulated using generics and static binding. And for some applications this approach may actually be of more than academic interest.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Proposal for a monotonic multiple inheritance linearization
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Previous studies concerning multiple inheritance convinced us that a better analysis of conflict resolution mechanisms was necessary. In [DHHM92], we stated properties that a sound mechanism has to respect. Among them, a monotonicity principle plays a critical role, ensuring that the inheritance mechanism behaves "naturally" relative to the incremental design of the inheritance hierarchy. We focus here on linearizations and present an intrinsically monotonic linearization, whereas currently used linearizations are not. This paper describes the algorithm in detail, explains the design choices, and compares it to other linearizations, with LOOPS and CLOS taken as references. In particular, this new linearization extends CLOS and LOOPS linearizations, producing the same results when these linearizations are sound.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Interfaces, protocols, and the semi-automatic construction of software adaptors
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
In this paper we show how to augment object-oriented application interfaces with enhanced specifications that include sequencing constraints called <italic>protocols</italic>. Protocols make explicit the relationship between messages (methods) supported by the application. These relationships are usually only given implicitly, either in the code or in textual comments. We define notions of interface compatibility based upon protocols and show how compatibility can be checked, discovering a class of errors that cannot be discovered via the type system alone. We then define <italic>software adaptors</italic> that can be used to bridge the difference between object-oriented applications that have functionally compatible but type incompatible interfaces. We discuss what it means for an adaptor to be <italic>well-formed</italic>. Leveraging the information provided by protocols, we show how adaptors can be automatically generated from a high-level description, called an <italic>interface mapping</italic>.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Modules / packages, Software and its engineering]
Extensible file system (ELFS): an object-oriented approach to high performance file I/O
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Scientific applications often manipulate very large sets of persistent data. Over the past decade, advances in disk storage device performance have consistently been outpaced by advances in the performance of the rest of the computer system. As a result, many scientific applications have become I/O-bound, i.e. their run-times are dominated by the time spent performing I/O operations. Consequently, the performance of I/O operations has become critical for high performance in these applications. The ELFS approach is designed to address the issue of high performance I/O by treating files as typed objects. Typed file objects can exploit knowledge about the file structure and type of data. Typed file objects can selectively apply techniques such as prefetching, parallel asynchronous file access, and caching to improve performance. Also, by typing objects, the interface to the user can be improved in two ways. First, the interface can be made easier to use by presenting file operations in a more natural manner to the user. Second, the interface can allow the user to provide an "oracle" about access patterns, that can allow the file object to improve performance. By combining these concepts with the object-oriented paradigm, the goal of the ELFS methodology is to create flexible, extensible file classes that are easy to use while achieving high performance. In this paper we present the ELFS approach and our experiences with the design and implementation of two file classes: a two dimensional dense matrix file class and a multidimensional range searching file class.
[File systems management, Operating systems, General programming languages, Object oriented languages, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
Development of an OO infrastructure for mainframe database applications
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Large mainframe installations need and want to exploit the advantages of Object Technology (OT), but without totally abandoning their legacy environments. Implementing Object Orientation in such a COBOL/CICS/DB2 environment is a challenge: there is neither language support, nor development tools, nor execution infrastructure, nor testing utilities. Yet Object Orientation can be fully implemented, and a project can still meet rigorous performance requirements and tough delivery time scales. The key is to develop an infrastructure. This paper relates the lessons learned in designing and implementing such an OO infrastructure at British Telecom.
[General programming languages, Object oriented languages, Data management systems, Language types, Software notations and tools, Information systems, Database management system engines, Software and its engineering]
MI-an object oriented environment for integration of scientific applications
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Scientific and engineering software is often produced by integration of existing software components of the size of a whole program. However, on the average, scientific software was not developed for reusability and is quite distant from the user model of the application problem; integration and retrofitting is as such a costly process. An architecture, methodology and several C++ class libraries for supporting integration are introduced. The architecture separates a software component layer, and an integration layer. The latter in based on the concept of software model, that is an abstraction of components and a representation of the system differing from its actual physical structure. The methodology is based on matching needs with existing models. The C++ class libraries are explained in some detail. The application to two major systems is analysed and the ideas behind seven other systems are briefly outlined. Some lessons learned are summarised in the conclusions.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Methodology standards: help or hindrance?
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
None
[Designing software, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
A third-generation SELF implementation: reconciling responsiveness with performance
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Programming systems should be both responsive (to support rapid development) and efficient (to complete computations quickly). Pure object-oriented languages are harder to implement efficiently since they need optimization to achieve good performance. Unfortunately, optimization conflicts with interactive responsiveness because it tends to produce long compilation pauses, leading to unresponsive programming environments. Therefore, to achieve good responsiveness, existing exploratory programming environments such as the Smalltalk-80 environment rely on interpretation or non-optimizing dynamic compilation. But such systems pay a price for their interactiveness, since they may execute programs several times slower than an optimizing system.SELF-93 reconciles high performance with responsiveness by combining a fast, non-optimizing compiler with a slower, optimizing compiler. The resulting system achieves both excellent performance (two or three times faster than existing Smalltalk systems) and good responsiveness. Except for situations requiring large applications to be (re)compiled from scratch, the system allows for pleasant interactive use with few perceptible compilation pauses. To our knowledge, SELF-93 is the first implementation of a pure object-oriented language achieving both good performance and good responsiveness.When measuring interactive pauses, it is imperative to treat multiple short pauses as one longer pause if the pauses occur in short succession, since they are perceived as one pause by the user. We propose a definition of <italic>pause clustering</italic> and show that clustering can make an order-of-magnitude difference in the pause time distribution.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Optimizing multi-method dispatch using compressed dispatch tables
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Optimizing method dispatch is a central issue in object-oriented language implementation. The <italic>dispatch table</italic> scheme, used for example by C++, is the only implementation of method dispatch that offers <italic>constant time</italic> performance. This property is the main asset of dispatch tables and a major requirement for some languages. However, the major drawback of dispatch tables is the space they require. Reducing the size of dispatch tables has been studied in the case of mono-methods with techniques such as <italic>coloring</italic>. In the case of multi-methods, dispatch tables are practically unusable as they grow as a power of the number of arguments. In this paper, we propose an algorithm to compress the dispatch tables of multi-methods by analyzing their signatures.
[Software notations and tools, Software and its engineering, Compilers]
Implementing constraint imperative programming languages: the Kaleidoscope'93 virtual machine
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Constraint Imperative Programming (CIP) languages integrate declarative constraints with imperative state and destructive assignment, yielding a powerful new programming paradigm. However, CIP languages are difficult to implement efficiently due to complex interactions between the two donor paradigms. Neither the virtual machines for classical object-oriented languages, nor those for existing constraint languages, are suitable for implementing CIP languages, as each assumes a purely imperative or a purely declarative computation model. We have developed a new virtual machine for CIP languages, the K-machine, an imperative machine with an incremental constraint solver and a constraint-based, rather than value-based, data store. This virtual machine allows user-defined constraints to be defined using constraint constructor definitions which are the CIP analog to method definitions. Similar to methods, these constructors are able to reference variables indirectly through many levels of pointers. The K-machine maintains relations between objects in the presence of state change to these indirectly referenced objects. The K-machine is capable of supporting a wide variety of CIP languages, including our most recent: Kaleidoscope'93.
[General programming languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Complex associations: abstractions in object-oriented modeling
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Objects model phenomena and a phenomenon is usually a component. Information characterizing a component is encapsulated and accessible only by its methods. The <italic>relations</italic> between components are modeled explicitly by means of associations or references. A relation is also a phenomenon and objects can model this type of phenomena too. Components are usually related conceptually in diverse and subtle ways: Some relations are implicitly given and some are local to other more basic relations. Such kinds of relations are important for understanding the organization and cooperation of objects and may be supported in object-oriented analysis, design, and programming: An <italic>implicit association</italic> describes a relation between an object and objects <italic>local</italic> to this <italic>enclosing</italic> object, and a <italic>complex association</italic> describes an explicit relation between <italic>local</italic> objects in different enclosing objects. Such associations are described by classes and the objects have the usual properties including methods and attributes.
[General programming languages, Object oriented languages, Language types, Data management systems, Software notations and tools, Database design and models, Software and its engineering, Information systems]
Streamlining the project cycle with object-oriented requirements
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
We have succeeded in streamlining the product development cycle by incorporating object-oriented technology into the requirements definition phase. We have developed a general format, supporting tools and a methodology for describing requirements in an object-oriented fashion. We have validated our approach by incorporating it into the new object-oriented methods being applied to our current project and observing the benefits that resulted. We describe the problems with our earlier requirements specifications which make them unsuitable for developing good object-oriented systems and then explain our approach which eliminates these pitfalls.
[Management of computing and information systems, Project and people management, Software creation and management, Object oriented languages, Professional topics, Language types, Software notations and tools, Software configuration management and version control systems, Software development process management, Designing software, Requirements analysis, General programming languages, Social and professional topics, Systems development, Software and its engineering]
Timethread-role maps for object-oriented design of real-time-and-distributed systems
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Object-oriented design methods and notations do not adequately address the concerns of real-time-and-distributed (RTD) systems. Issues critical to such systems, like performance, robustness, and concurrency are not seriously considered until detailed design. We propose an object-oriented approach that allows RTD design issues to be considered before detailed design. The approach revolves around <italic>timethread-role maps</italic> that present composite pictures of concurrent, interacting, end-to-end responsibility paths through a system. It is related to responsibility-driven design approaches, but extended for RTD systems. The paper illustrates by example how timethread-role maps can be used to explore, compare and explain different organizations for achieving the paths. The paper also illustrates how timethread-role maps may be used to represent dynamic structure.
[Software design techniques, Software creation and management, Object oriented languages, Embedded and cyber-physical systems, Language types, Software notations and tools, Distributed systems organizing principles, Software implementation planning, Designing software, Software development process management, Computer systems organization, Software system structures, Distributed architectures, General programming languages, Real-time systems, Software organization and properties, Software and its engineering, Architectures]
Development of distributed and client/server object-oriented applications: industry solutions
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
The panel will discuss emerging "industrial" solutions that help programmers to develop distributed and client/server applications based on objects supporting so-called openness and heterogeneity.The goal of the panel is to help answer the question whether there can be one single solution or whether various (integrated) approaches are needed. The panel will also compare industrial solutions such as COM, DSOM, CORBA and OODCE with results that came out of academia. Finally, a set of questions will be answered by each panelist according to the approach he will propose.
[Object oriented languages, Computing methodologies, Language types, Software notations and tools, Distributed computing methodologies, Distributed systems organizing principles, Computer systems organization, Software system structures, Distributed architectures, Distributed programming languages, General programming languages, Software organization and properties, Software and its engineering, Architectures]
Precise concrete type inference for object-oriented languages
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Concrete type information is invaluable for program optimization. The determination of concrete types in object-oriented languages is a flow sensitive global data flow problem. It is made difficult by dynamic dispatch (virtual function invocation) and first class functions (and selectors)-the very program structures for whose optimization its results are most critical. Previous work has shown that constraint-based type inference systems can be used to safely approximate concrete types [15], but their use can be expensive and their results imprecise.We present an incremental constraint-based type inference which produces precise concrete type information for a much larger class of programs at lower cost. Our algorithm extends the analysis in response to discovered imprecisions, guiding the analysis' effort to where it is most productive. This produces precise information at a cost proportional to the type complexity of the program. Many programs untypable by previous approaches or practically untypable due to computational expense, can be precisely analyzed by our new algorithm. Performance results, precision, and running time, are reported for a number of concurrent object-oriented programs. These results confirm the algorithm's precision and efficiency.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering]
Reducing cross domain call overhead using batched futures
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
In many systems such as operating systems and databases it is important to run client code in a separate protection domain so that it cannot interfere with correct operation of the system. Clients communicate with the server by making cross domain calls, but these are expensive, often costing substantially more than running the call itself. This paper describes a new mechanism called batched futures that transparently batches possibly interrelated client calls. Batching makes domain crossings happen less often, thus substantially reducing the cost. We describe how the mechanism is implemented for the Thor object-oriented database system, and presents performance results showing the benefit of the mechanism on various benchmarks.
[Cross-computing tools and techniques, Software performance, Systems security, Extra-functional properties, Operating systems security, Information systems, Database management system engines, Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, Data management systems, Performance, General and reference, Database theory, Theory of database privacy and security, Software organization and properties, Software and its engineering]
Sifting out the gold: delivering compact applications from an exploratory object-oriented programming environment
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Integrated, dynamically-typed object-oriented programming environments offer many advantages, but have trouble producing small, self-contained applications. Recent advances in type inference have made it possible to build an application extractor for Self. The extractor was able to extract a medium-sized application in a few minutes. The extracted application runs in a tenth the space of the original environment. Except for extracting reflection and sends with computed selectors, the extractor runs without human intervention and fully preserves the behavior of the application.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Objects and databases (panel)
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
None
[General programming languages, Object oriented languages, Data management systems, Language types, Software notations and tools, Information systems, Database management system engines, Software and its engineering]
Persistent storage for a workflow tool implemented in Smalltalk
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
This paper describes a new workflow model and its implementation in Smalltalk. The paper also details problems with using a RDBMS as the persistent store for the workflow tool and the subsequent experiences in using an ODBMS for this purpose. The final solution was a <italic>coexistence approach</italic>, using the RDBMS for legacy corporate data and the ODBMS for the process description and workflow status data.
[Software design techniques, Management of computing and information systems, Project and people management, Software creation and management, Professional topics, Information systems, Database management system engines, Software implementation planning, Designing software, Software development process management, Data management systems, Project management techniques, Social and professional topics, Software and its engineering]
Semantic locking in object-oriented database systems
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Object-oriented databases are being increasingly used to model non-standard applications that emphasize modularity, composition, and rapid prototyping. A semantic locking protocol is presented for transaction management for such object-oriented databases. In particular, the protocol incorporates the semantics of complex objects, nested executions and dynamic conflicts resulting from referentially shared objects.
[General programming languages, Object oriented languages, Data management systems, Language types, Database transaction processing, Software notations and tools, Database design and models, Information systems, Software and its engineering, Database management system engines]
Experience with representing C++ program information in an object-oriented database
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
Two major issues related to storing program information in an OODB are sharing and clustering. The former is important since it prevents the database from consuming excessive disk space, while the latter is crucial, since it keeps clients running without thrashing. In our database, objects are shared across multiple programs' translation units, and are clustered by combining three techniques, namely, birth-order, death-order, and sharing-oriented clusterings. An initial experiment shows that, for a medium-size application, the database consumes 3.5 times less disk space than in a conventional environment, and that the invocation of a client is almost instantaneous.
[Software design techniques, Software creation and management, Retrieval tasks and goals, Information systems applications, Information retrieval, Clustering and classification, Data mining, Clustering, Information systems, Software implementation planning, Designing software, Software development process management, Data management systems, Database design and models, Software and its engineering]
A status report on the OO7 OODBMS benchmarking effort
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
The OO7 Benchmark was first published in 1993, and has since found a home in the marketing literature of various object-oriented database management system (OODBMS) vendors. The OO7 Benchmark (as published) was the initial result of an ongoing OODBMS performance evaluation effort at the University of Wisconsin. This paper provides an update on the status of the effort on two fronts: single-user and multi-user. On the single-user front, we review and critique the design of the initial OO7 Benchmark. We discuss some of its faults, the reasons for those faults, and things that might be done to correct them. On the multi-user front, we describe our current work on the development of a multi-user benchmark for OODBMSs. This effort includes changes and extensions to the OO7 database and the design of a family of interesting multi-user workloads.
[Cross-computing tools and techniques, Object oriented languages, Software performance, Language types, Extra-functional properties, Software notations and tools, Information systems, Database management system engines, General programming languages, Data management systems, Performance, General and reference, Software organization and properties, Software and its engineering]
Composition of before/after metaclasses in SOM
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
In SOM, the IBM System Object Model, a class is a run-time object that defines the behavior of its instances by creating an instance method table. Because classes are objects, their behavior is defined by other classes (called metaclasses). For example, a "Before/After Metaclass" can be used to define the implementation of classes that, by suitable construction of their instance method tables, arrange for each invocation of a method to be preceded by execution of a "before method" and followed by execution of an "after method". This paper introduces and solves the problem of composing different Before/After Metaclasses in the context of SOM. An enabling element in the solution is SOM's concept of <italic>derived metaclasses</italic>, i.e., at run-time a SOM system derives the appropriate metaclass of a class based on the classes of its parents and an optional metaclass constraint.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Reflections on metaclass programming in SOM
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
This paper reports on the evolution of metaclass programming in SOM (the IBM System Object Model). Initially, SOM's use of explicit metaclasses introduced metaclass incompatibilities. This was cured by having SOM dynamically derive an appropriate metaclass by interpreting the "metaclass declaration" as a constraint. In effect, inheritance is given a new dimension, because the constraint is also inherited. The derived metaclass is the least solution to all these constraints. Subsequently, this cure led to the possibility of metaclasses conflicting over the need to assign meaning to a method. The cure for this problem is a framework that facilitates the programming of metaclasses that cooperate on the assignment of meaning to methods.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Combining contracts and exemplar-based programming for class hiding and customization
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
For performance reasons, client applications often need to influence the implementation strategies of libraries whose services they use. If an object-oriented library contains multiple service classes customized for different usage patterns, applications can influence service implementations by instantiating the customized classes that match their needs. However, with many similar service classes, it can be difficult for applications to determine which classes to instantiate. Choosing the wrong class can result in very subtle errors since a customized class might use optimizations that work only over a restricted domain. In this paper, we show how client-side software contracts and exemplar-based class factories can be used to construct customized server objects. By expressing priorities and requirements in contracts, clients can delegate service class selection to the library and thereby avoid implicit dependencies on the library implementation. We have used this approach in the implementation of a real-time database system.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
How do teams shape objects?-How do objects shape teams?
Proceedings of the ninth annual conference on Object-oriented programming systems, language, and applications
ACM SIGPLAN Notices VOLUME 29 ISSUE 10
1994
None
[Management of computing and information systems, Project and people management, Software creation and management, Object oriented languages, Language types, Professional topics, Software notations and tools, Software configuration management and version control systems, Software development process management, General programming languages, Social and professional topics, Software and its engineering]
Extending the statechart formalism: event scheduling &amp; disposition
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Statecharts are extended to deal with events when no applicable transition is available, and to resolve conflicts relative to event scheduling and response that can arise whenever multiple states can be active simultaneously. "Event closure" and event scheduling are achieved without having to clutter up a basic statechart. The extensions are effected by means of declarative event disposition rules. These rules, together with the statechart topology, determine the contents of one or more disposition matrices. These matrices are combined with the statechart state to determine the response of the event dispatcher to incoming events. The operation of the event dispatcher is also described. A detailed example illustrates these concepts, which are further characterized, for the benefit of working programmers, in the form of a behavioral design pattern. A tool called StateCraft embodies these notions.
[Software design techniques, Software creation and management, Machine learning theory, Online learning algorithms, Reinforcement learning, Theory of computation, Theory and algorithms for application domains, Software implementation planning, Online algorithms, Designing software, Software development process management, Scheduling algorithms, Sequential decision making, Approximation algorithms analysis, Design and analysis of algorithms, Software and its engineering]
Object-oriented state machines: subclassing, composition, delegation, and genericity
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Software specification and implementation techniques based on state machines simplify design, coding, and validation. However, large systems require complex state machines. Incremental construction techniques can control this complexity. In this paper, we present a construction technique that permits derivation of complex state machines from simpler state machines. The technique uses subclassing, composition, delegation, and genericity to incrementally modify and combine simpler machines.In addition, we present a novel implementation technique that uses exactly one table-lookup and one addition to dispatch events on derived state machines, no matter the depth of the derivation. As an example, we describe the derivation of a complicated distributed virtual memory scheme from a simple paging virtual memory scheme.
[Theory of computation, Models of computation, Automata extensions, Formal language definitions, Software notations and tools, Formal languages and automata theory, Logic, Quantitative automata, Software and its engineering]
The Self-4.0 user interface: manifesting a system-wide vision of concreteness, uniformity, and flexibility
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Manipulating programs is hard, while manipulating objects in the physical world is often easy. Several attributes of the physical world help make it comprehensible and manipulable: concreteness, uniformity, and flexibility. The Self programming system attempts to apply these attributes to the world within the computer. The semantics of the language, the efficiency and fidelity of its implementation, and the architecture of its user interface conspire to make the experience of constructing programs in Self immediate and tangible. We describe the mechanisms used to achieve this goal, and illustrate those mechanisms within the context of an extended programming task.
[Object oriented languages, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Development frameworks and environments, Theory of computation, Semantics and reasoning, Integrated and visual development environments, General programming languages, Semantics, Program semantics, Formal language definitions, Software and its engineering]
Using a prototype-based language for user interface: the Newton project's experience
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Object-oriented user interface frameworks are usually implemented in a class-based language. We chose instead to develop a prototype-based language, NewtonScript, for this purpose. We found that prototype inheritance has compelling advantages over classes in the domain of user interface programming, and can help overcome the memory constraints of a small machine.
[Software prototyping, Software creation and management, Software development methods, Language features, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software development techniques, Software development process management, Integrated and visual development environments, General programming languages, Functional languages, Rapid application development, Software and its engineering]
Annotating objects for transport to other worlds
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
In Self 4.0, people write programs by directly constructing webs of objects in a larger world of objects. But in order to save or share these programs, the objects must be moved to other worlds. However, a concrete, directly constructed program is incomplete, in particular missing five items of information: which module to use, whether to transport an actual value or a counterfactuaI initial value, whether to create a new object in the new world or to refer to an existing one, whether an object is immutable with respect to transportation, and whether an object should be created by a low-level, concrete expression or an abstract, type-specific expression. In Self 4.0, the programmer records this extra information in annotations and attributes. Any system that saves directly constructed programs will have to supply this missing information somehow.
[Data flow languages, General programming languages, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Managing object oriented projects (panel session)
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Projects using Object Oriented technology typically fall into one of two categories: either they are run with traditional project management techniques, or they are run by "technology experts" who don't use any project management techniques. This panel will attempt to give out some hints as to how to be more successful managing OO projects.Questions to be addressed include:&amp;bull; How is Object Oriented Project Management different? Is a "paradigm shift" required for project management?&amp;bull; What aspects of Object Oriented project management should be stressed? What are some tips, tricks or gotchas experienced by the panel members?&amp;bull; Does a project manager need to be more technical to lead an Object Oriented project? Should he/she have had previous experience with Object Oriented development?&amp;bull; What are some alternate organizational structures which would better support Object Oriented projects?&amp;bull; What is the nature of an Object Oriented life cycle and how is it different?&amp;bull; Is there a difference in techniques between different languages or between different domainsAudience members with relevant experience will be invited to sit on the panel in two "guest" seats.
[Management of computing and information systems, Project and people management, General programming languages, Object oriented languages, Professional topics, Language types, Software notations and tools, Social and professional topics, Software and its engineering]
Type feedback vs. concrete type inference: a comparison of optimization techniques for object-oriented languages
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Two promising optimization techniques for object-oriented languages are type feedback (profile-based receiver class prediction) and concrete type inference (static analysis). We directly compare the two techniques, evaluating their effectiveness on a suite of 23 S<sc>ELF</sc> programs while keeping other factors constant.Our results show that both systems inline over 95% of all sends and deliver similar overall performance with one exception: S<sc>ELF</sc>'s automatic coercion of machine integers to arbitrary-precision integers upon overflow confounds type inference and slows down arithmetic-intensive benchmarks.We discuss several other issues which, given the comparable run-time performance, may influence the choice between type feedback and type inference.
[Cross-computing tools and techniques, Evaluation, Metrics, General programming languages, Object oriented languages, Language types, Software notations and tools, General and reference, Software and its engineering, Compilers]
Profile-guided receiver class prediction
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
The use of dynamically-dispatched procedure calls is a key mechanism for writing extensible and flexible code in object-oriented languages. Unfortunately, dynamic dispatching imposes a runtime performance penalty. Some recent implementations of pure object-oriented languages have utilized profile-guided receiver class prediction to reduce this performance penalty, and some researchers have argued for applying receiver class prediction in hybrid languages like C++. We performed a detailed examination of the dynamic profiles of eight large object-oriented applications written in C++ and Cecil, determining that the receiver class distributions are strongly peaked and stable across both inputs and program versions through time. We describe techniques for gathering and manipulating profile information at varying degrees of precision, particularly in the presence of optimizations such as inlining. Our implementation of profile-guided receiver class prediction improves the performance of large Cecil applications by more than a factor of two over solely static optimizations.
[Procedures, functions and subroutines, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Bidirectional object layout for separate compilation
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Existing schemes for object layout and dispatch in the presence of multiple inheritance and separate compilation waste space and are slower than systems with single inheritance. This paper describes the bidirectional object layout, a new scheme for object layout that produces smaller objects and faster method invocations than existing schemes by automatically optimizing particular uses of multiple inheritance. The bidirectional object layout is used for the programming language Theta, and is applicable to languages like C++. This paper also demonstrates how to efficiently implement method dispatch when method signatures are allowed to change in subclasses. Most current statically compiled languages require identical signatures for efficiency.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
OO testing in the real world (panel): lessons for all
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
None
[Software defect analysis, Software creation and management, Software testing and debugging, General programming languages, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Software and its engineering]
Minimizing row displacement dispatch tables
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Row displacement dispatch tables implement message dispatching for dynamically-typed languages with a run time overhead of one memory indirection plus an equality test. The technique is similar to virtual function table lookup, which is, however, restricted to statically typed languages like C++. We show how to reduce the space requirements of dispatch tables to approximately the same size as virtual function tables. The scheme is then generalized for multiple inheritance. Experiments on a number of class libraries from five different languages demonstrate that the technique is effective for a broad range of programs. Finally, we discuss optimizations of the row displacement algorithm that allow dispatch table construction of these large samples to take place in a few seconds.
[Communications management, Input / output, Software notations and tools, Mathematical foundations of cryptography, Runtime environments, Contextual software domains, Theory of computation, Dynamic compilers, Operating systems, Security and privacy, Memory management, Computational complexity and cryptography, Communication complexity, Cryptography, Software organization and properties, Software and its engineering, Compilers]
Subtypes vs. where clauses: constraining parametric polymorphism
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
All object-oriented languages provide support for subtype polymorphism, which allows the writing of generic code that works for families of related types. There is also a need, however, to write code that is generic across types that have no real family relationship. To satisfy this need a programming language must provide a mechanism for parametric polymorphism, allowing for types as parameters to routines and types. We show that to support modular programming and separate compilation there must be a mechanism for constraining the actual parameters of the routine or type. We describe a simple and powerful constraint mechanism and compare it with constraint mechanisms in other languages in terms of both ease of use and semantic expressiveness. We also discuss the interaction between subtype and parametric polymorphism: we discuss the subtype relations that can exist between instantiations of parameterized types, and which of those relations are useful and can be implemented efficiently. We illustrate our points using examples in Theta, a new object-oriented language, and we describe the time- and space-efficient implementation of parametric polymorphism used in Theta.
[Procedures, functions and subroutines, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Specification languages, Modules / packages, System description languages, Software and its engineering]
Sound polymorphic type inference for objects
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
A polymorphic, constraint-based type inference algorithm for an object-oriented language is defined. A generalized form of type, polymorphic recursively constrained types, are inferred. These types are expressive enough for typing objects, since they generalize recursive types and F-bounded polymorphism. The well-known tradeoff between inheritance and subtyping is mitigated by the type inference mechanism. Soundness and completeness of type inference are established.
[Control structures, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Tailoring OO analysis and design methods (panel)
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
None
[Designing software, Management of computing and information systems, Project and people management, Software creation and management, General programming languages, Object oriented languages, Professional topics, Language types, Software notations and tools, Social and professional topics, Software and its engineering]
An algebraic semantics of subobjects
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Existing formalisms of inheritance are not sufficient to model the complexities of the kind of multiple inheritance exemplified in C++. Any satisfactory formalism must model the complicating effects of virtual and non-virtual base classes as well as virtual and non-virtual methods. By abstracting the implementational notion of a subobject and formalizing subobject selection, we develop a formalism to model this combination of features. Not intended as a formal semantics of C++, the resulting model should nevertheless provide an essential level of understanding for language theorists and implementors in their dealings with C++ and related languages.
[Object oriented languages, Language types, Software notations and tools, Contextual software domains, Theory of computation, Dynamic compilers, Semantics and reasoning, Operating systems, Semantics, Memory management, General programming languages, Program semantics, Formal language definitions, Software organization and properties, Software and its engineering, Compilers]
Modular reasoning in the presence of subclassing
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Considerable progress has been made in understanding how to use subtyping in a way that facilitates modular reasoning. However, using subclassing in a way that facilitates modular reasoning is not well understood. Often methods must be overriden as a group because of dependencies on instance variables, and the programmers of subclasses cannot tell which methods are grouped without looking at the code of superclasses. Also, the programmers of subclasses must look at the code of superclasses to tell what assumptions inherited methods make about the behavior of overriden methods.We present a systematic way to use subclassing that facilitates formal and informal modular reasoning. Separate specifications are given to programmers writing code that manipulates instances of a class and to programmers writing subclasses of the class. The specifications given to programmers of subclasses are divided, by division of labor specifications, into multiple parts. Subclasses may inherit or override entire parts, but not sub-parts. Reasoning about the implementation of each part is done independently of other parts.
[Cross-computing tools and techniques, Software creation and management, Language features, Software functional properties, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Verification, Modules / packages, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Program reasoning, Formal software verification, Logic, Formal methods, General and reference, Software organization and properties, Software and its engineering]
On the semantic diversity of delegation-based programming languages
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
The prototype-based programming model has always been difficult to characterize precisely. Its basic principle advocates concrete objects as the only mean to model concepts, yet current languages promote methodologies reintroducing abstract constructions to manage efficiently groups of similar objects. In this paper, we propose a rational reconstruction of delegation-based programming languages that identifies programming models going beyond traditional prototypes. We also introduce a new classification of delegation-based languages, which clarifies these models, and we discuss their relative merits. We finally bring to the fore the existence of more and more structured delegation-based languages forming a continuum between pure prototype-based languages and class-based ones.
[Language features, Object oriented languages, Computing methodologies, Language types, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Natural language processing, Artificial intelligence, Software and its engineering]
Patterns: cult to culture?
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
None
[General programming languages, Object oriented languages, Machine learning, Computing methodologies, Language types, Software notations and tools, Software and its engineering]
Subject-oriented composition rules
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Subject-oriented programming supports composition of object-oriented programs or program fragments called subjects. This paper presents an approach to the composition rules used to specify composition details. Rules can be generic, allowing different subrules to be "plugged into" higher-level rules, and they include a means of specifying exceptions to general rules. We give definitions of a number of useful, generic rules, including merge and override, as a first step towards a generally-useful composition rule library. We also outline an object-oriented framework for implementing rules, which we are currently building as part of our support for subject-oriented programming in C++.
[Theory of computation, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Computational complexity and cryptography, Abstract data types, Software and its engineering, Complexity classes]
How and why to encapsulate class trees
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
A good reusable framework, pattern or module interface usually is represented by abstract classes. They form an abstract design and leave the implementation to concrete subclasses. The abstract design is instantiated by naming these subclasses. Unfortunately, this exposes implementation details like class names and class tree structures. The paper gives a rationale and a general metaobject protocol design that encapsulates whole class trees. Clients of an abstract design retrieve classes and create objects based on class semantics specifications. Using abstract classes as the only interface enhances information hiding and makes it easier both to evolve a system and to configure system variants.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Semantics, Program semantics, Software notations and tools, Formal language definitions, Abstract data types, Modules / packages, Software and its engineering]
A reflective model for first class dependencies
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
We propose a reflective model to express and to automatically manage dependencies between objects. This model describes reflective facilities which enable the changing of language semantics. Although the importance of inter-object dependencies is well accepted, there is only limited object-oriented language support for their specification and implementation. In response to this lack of expressiveness of object models, the FLO language integrates dependency management into the object oriented paradigm. Dependencies are described as first class objects and FLO automatically maintains the consistency of the dependency graph.In this paper, we first show how a user can declare dependencies and how the system maintains the consistency of the graph of expressed dependencies. In a second part, we focus on the implementation of this management by controlling the messages sent to linked objects. In order to make dependency management orthogonal to other application concerns, we propose an abstraction of message handling, implemented with meta-objects. We illustrate the extensibility of our language with different control behavior implementations, in particular we study different implementations of the global control of message propagation flow.
[Networks, Cross-computing tools and techniques, Network protocols, Software performance, Human-centered computing, Systems security, Extra-functional properties, Human computer interaction (HCI), Interaction techniques, Operating systems security, Network protocol design, Theory of computation, Models of computation, Security and privacy, Information flow control, Performance, General and reference, Software organization and properties, Software and its engineering]
Systematic software reuse (panel session): objects and frameworks are not enough
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
None
[Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
The future of distributed object computing (Panel Session)
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
None
[]
A metaobject protocol for C++
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
This paper presents a metaobject protocol (MOP) for C++. This MOP was designed to bring the power of meta-programming to C++ programmers. It avoids penalties on runtime performance by adopting a new meta-architecture in which the metaobjects control the compilation of programs instead of being active during program execution. This allows the MOP to be used to implement libraries of efficient, transparent language extensions.
[General programming languages, Object oriented languages, Language features, Data types and structures, Language types, Software notations and tools, Software and its engineering]
Compiling away the meta-level in object-oriented concurrent reflective languages using partial evaluation
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Meta-level programmability is beneficial for parallel/distributed object-oriented computing to improve performance, etc. The major problem, however, is interpretation overhead due to mta-circular interpretation. To solve this problem, we propose a compilation framework for object-oriented concurrent reflective languages using partial evaluation. Since traditional partial evaluators do not allow us to directly deal with meta-circular interpreters written with concurrent objects, we devised techniques such as pre-/post-processing, a new proposed preaction extension to partial evaluation in order to handle side-effects, etc. Benchmarks of a prototype compiler for our language ABCL/R3 indicate that (1) the meta-level interpretation is essentially 'compiled away,' and (2) mta-level optimizations in a parallel application, running on a Fujitsu MPP AP1000, exhibits only 10--30% overhead compared to the hand-crafted source-level optimization in a non-reflective language.
[Measurement, Cross-computing tools and techniques, Metrics, Software notations and tools, General and reference, Software and its engineering, Compilers]
Towards a methodology for explicit composition of metaobjects
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Reflective programming languages are those where users' programs are allowed to customize in an organized way the behavior of the language to their own needs. For ten years now, most of the work on reflection revolved around the definition and the implementation of metaobject protocols which express this organization. No methodologies have been proposed for reflective programming per se. This paper proposes a first one aiming at the design of composable metaobjects. Given two independently developed reflective customizations, this methodology proposes principles to be observed in their design such that they can be composed using standard base-level aggregation or specialization. While this paper focuses on a simple MOP and illustrates the methodology on specific examples, this methodology can be generalized to other languages with different MOPs. For instance, we discuss how to adapt it to C<sc>LOS</sc>.
[Software creation and management, Language features, Computing methodologies, Software notations and tools, Theory of computation, Designing software, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Abstract data types, Software and its engineering]
Objects and database standards (panel)
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
None
[Document types, General and reference, Computing standards, RFCs and guidelines, Software and its engineering]
Objects and domain engineering (panel)
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
None
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Patterns in practice
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Object-oriented systems often exhibit idiomatic and recurring structures of objects and classes that solve particular design problems and make systems more flexible, elegant, and ultimately reusable. Design patterns have been proposed as one way to represent, record and reuse these recurring design structures and associated design experience. Here we report on experiences in using design patterns during the design of object-oriented systems.
[Designing software, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Interactive visualization of design patterns can help in framework understanding
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Framework programming is regarded as one the main advantages of object-oriented software engineering, and is expected to increase software reuse. In exploiting frameworks, however, programmers often face difficulties caused by the complexity of the hidden architecture and the multiplicity of the design decisions that are embedded in a framework. Interactive visualization of design patterns occurring in a framework shows how the framework is operating, in a flexible yet structured way that contributes to the programmer's understanding of the underlying software architecture. In this way, programmers can explore and use frameworks efficiently even when they are distributed without vast amounts of documentation and source code.
[Modeling and simulation, General programming languages, Object oriented languages, Machine learning, Computing methodologies, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
A framework for network protocol software
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Writing software to control networks is important and difficult. It must be efficient, reliable, and flexible. Conduits+ is a framework for network software that has been used to implement the signalling system of a mullti-protocol ATM access switch. An earlier version was used to implement TCP/IP. It reduces the complexity of network software, makes it easier to extend or modify network protocols, and is sufficiently efficient. Conduits+ shows the power of a componentized object-oriented framework and of common object-oriented design patterns.
[Networks, Software creation and management, Network protocols, Reusability, Machine learning, Computing methodologies, Network protocol design, Software development techniques, Software and its engineering]
Creating the architecture of a manufacturing framework by design patterns
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
The class and interaction structure of object-oriented designs may become fairly complex, and consequently difficult to develop and understand. Design patterns allow to govern this complexity. This paper presents the design process of a domain-specific black-box framework for the control of automated manufacturing systems. The design is performed as a sequence of transformation steps, guided by the use of generative design patterns. Starting out from a domain-specific model, which does not provide a degree of reusability sufficiently high for a framework, the transformation steps increase the reusability until a satisfactory degree is reached. The resulting class and interaction structure allows to create each application of the considered manufacturing subdomain by selecting, configuring and parameterizing of the framework classes.
[Networks, Operations research, Network protocols, Computing methodologies, Software notations and tools, Industry and manufacturing, Network protocol design, Computing standards, RFCs and guidelines, Applied computing, Enterprise computing, Modeling and simulation, Document types, General programming languages, Machine learning, Model development and analysis, General and reference, Software and its engineering]
SCONE: using concurrent objects for low-level operating system programming
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
This paper proposes a methodology for making low-level system code of operating systems be replaceable at runtime. Our approach is to use concurrent objects as a basic programming unit for low-level system programs. To realize the different need for each type of system code and to execute these concurrent objects sufficiently efficient, we use a combination of dedicated system service layers and other implementation techniques. System service layers provide the most suitable primitive operations for each concurrent object. Under our programming model for low-level system code, which we call SCONE, it is possible to program low-level system code without hazardous operations such as explicit synchronization, direct scheduler manipulation, etc. We present the implementation of our methodology on the Apertos operating system and demonstrate its efficiency with performance evaluation.
[Cross-computing tools and techniques, Software creation and management, Software development methods, Mutual exclusion, Contextual software domains, Design, Software development process management, Operating systems, Memory management, Virtual memory, Discrete mathematics, Mathematics of computing, General and reference, Software organization and properties, Software and its engineering, Process management]
Problem-oriented object memory: customizing consistency
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
This paper presents the notion of problem-oriented object memory, and its realization in a distributed object-based programming system, Penumbra. This system allows location transparent object invocation, object migration and caching. Its distinguishing feature, however, is its support for problem-oriented object sharing.Problem-oriented object memory is an object model that allows exploitation of application specific semantics by relaxing strict consistency in favour of performance.Our work addresses the problem of achieving scalability of shared write-intensive data in an environment of networked workstations. We have successfully applied the presented ideas to the management of a highly demanding telecoms application.
[Integrated circuits, Distributed programming languages, General programming languages, Computing methodologies, Language types, Software notations and tools, Hardware, Distributed computing methodologies, Dynamic memory, Semiconductor memory, Software and its engineering]
Evolving to objects-the Witches' Brew
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
"Double, double toil and trouble, fire burn and cauldron bubble" &amp;hellip; chant the witches of Macbeth. Take a corporation with a rich, decades-old history of providing on-line services on MVS mainframes, coupled with a vision of the future including OO design and programming, DCE for client-server infrastructure, heterogeneous platform mixes across the Unix and PC worlds, and plan to tie that back to the established systems - and you have a Witches' Brew of your own. The question for our project has been "How to introduce OO technology into an existing project framework with the least effort and most benefit?". Recent industry experience reports detailing the blending of OO and DCE indicate that this has not been easy; our experience confirms that, but our approach has allowed us to utilize the strengths of OO to minimize the complexities inherent in the mix.
[Management of computing and information systems, Software creation and management, Simulation types and techniques, Object oriented languages, Language types, Computing methodologies, Professional topics, Software notations and tools, Modeling and simulation, General programming languages, Software management, Social and professional topics, Distributed simulation, Software and its engineering]
Release-to-release binary compatibility in SOM
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
SOM (IBM's System Object Model) removes a major impediment to reuse in Object-Oriented Programming by facilitating the programming of release-to-release binary compatible class libraries. This is accomplished by supporting a large number of compatibility preserving transformations. Taken together these transformations compose a discipline for programming evolving class libraries.
[Computer vision, Hierarchical representations, Computer vision representations, Object oriented languages, Computing methodologies, Language types, Software notations and tools, Object oriented frameworks, Development frameworks and environments, Complexity classes, Theory of computation, Models of computation, General programming languages, Computer graphics, Shape modeling, Computational complexity and cryptography, Artificial intelligence, Software and its engineering]
Lessons from the battlefield
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
The pragmatic aspects of deploying large scale Object Oriented (OO) applications are examined. The focus is on identifying some of the main obstacles that arise in typical large scale OO projects, and offering hints about effective solutions. This The topics are based on a number of actual large scale projects in which the author participated in a It significant capacity and solutions that he adopted or developed to deal with the problems encountered.
[Decision support systems, Project and people management, Professional topics, Software notations and tools, Contextual software domains, Information systems, Design, Enterprise computing, Modeling and simulation, Operating systems, Systems analysis and design, Social and professional topics, Model development and analysis, Software organization and properties, Software and its engineering, Modeling methodologies, Military, Cross-computing tools and techniques, Management of computing and information systems, Object oriented languages, Information systems applications, Computing methodologies, Language types, Computers in other domains, Applied computing, General programming languages, Expert systems, General and reference, Process management]
SmartFiles: an OO approach to data file interoperability
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
Data files for scientific and engineering codes typically consist of a series of raw data values whose description is buried in the programs that interact with these files. In this situation, making even minor changes in the file structure or sharing files between programs (interoperability) can only be done after careful examination of the data files and the I/O statements of the programs interacting with this file. In short, scientific data files lack self-description, and other self-describing data techniques are not always appropriate or useful for scientific data files. By applying an object-oriented methodology to data files, we can add the intelligence required to improve data interoperability and provide an elegant mechanism for supporting complex, evolving, or multidisciplinary applications, while still supporting legacy codes. As a result, scientists and engineers should be able to share datasets with far greater ease, simplifying multidisciplinary applications and greatly facilitating remote collaboration between scientists.
[Cross-computing tools and techniques, Language features, Data access methods, Data structures, Software notations and tools, Information systems, Design, General programming languages, Data types and structures, Data management systems, Database design and models, General and reference, Software and its engineering]
Extending SQL-92 for OODB access: design and implementation experience
Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 30 ISSUE 10
1995
This paper describes the design and implementation of a query engine that provides extended SQL-based access to the data managed by an object-oriented database system. This query engine allows extended SQL queries to be embedded in C++ programs or issued interactively as from a command line interface. The language supported by the engine is the complete SQL-92 select statement plus object extensions for navigating along paths and embedded structures, querying nested sets, and invoking member functions. In addition, an object-oriented SQL view facility is provided. Using this view facility, one can define object-oriented views; one can also define views that flatten complex OODB schemas, allowing direct access by existing tools designed to provide remote access to relational databases. The view facility also supports the definition of views that include reference and set-valued columns based on other views, thus allowing entire "view schemas" to be created. This paper describes the SQL-92 query and view extensions and discusses a number of issues that arose on the way to the implementation that is currently running on top of the ObjectStore OODB system.
[Object oriented languages, Language types, Software notations and tools, Information systems, Database management system engines, Theory of computation, Database query processing, Theory and algorithms for application domains, Database query processing and optimization (theory), General programming languages, Data management systems, Database theory, Query languages, Software and its engineering]
An equational object-oriented data model and its data-parallel query language
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
This paper presents an equational formulation of an object-oriented data model. In this model, a database is represented as a system of equations over a set of oid's, and a database query is a transformation of a system of equations into another system of equations. During the query processing, our model maintains an equivalence relation over oid's that relates oid's corresponding to the same "real-world entity." By this mechanism, the model achieves a declarative set-based query language and views for objects with identity. Moreover, the query primitives are designed so that queries including object traversal can be evaluated in a data-parallel fashion.
[Language features, Software notations and tools, Information systems, Database management system engines, Theory of computation, Database query processing, Theory and algorithms for application domains, Computer systems organization, Semantics and reasoning, Database query processing and optimization (theory), Data types and structures, Data management systems, Database design and models, Database theory, Software and its engineering, Data structures, Record storage systems, Parallel architectures, Program constructs, Information storage systems, Data structures and algorithms for data management, General programming languages, Data structures design and analysis, Design and analysis of algorithms, Type structures, Query languages, Architectures]
Creating host compliance in a portable framework: a study in the reuse of design patterns
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
This report describes an experiment carried out at ParcPlace-Digitalk which sought to increase the look-and-feel compliance of portable applications built using the company's Smalltalk-based VisualWorks product. We outline the structure of the current VisualWorks user interface framework, and the precise requirements which the experimental system sought to fulfill. We go on to show how we were able to reuse design patterns from the literature in a generative fashion, to direct the evolution of the new framework. This contrasts with most pattern-related work to date, which has concentrated on discerning design patterns in existing systems. Finally, we draw generalizations from our experience concerning the evolution of software architecture using patterns.
[Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Human-centered computing, Software notations and tools, Human computer interaction (HCI), Development frameworks and environments, Software development techniques, Software and its engineering]
A flexible operation execution model for shared distributed objects
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Many parallel and distributed programming models are based on some form of shared objects, which may be represented in various ways (e.g., single-copy, replicated, and partitioned objects). Also, many different operation execution strategies have been designed for each representation. In programming systems that use multiple representations integrated in a single object model, one way to provide multiple execution strategies is to implement each strategy independently from the others. However, this leads to rigid systems and provides little opportunity for code reuse. Instead, we propose a flexible operation execution model that allows the implementation of many different strategies, which can even be changed at runtime. We present the model and a distributed implementation of it. Also, we describe how various execution strategies can be expressed using the model, and we look at applications that benefit from its flexibility.
[Language features, Software notations and tools, Information systems, Theory of computation, Theory and algorithms for application domains, Mathematical analysis, Data types and structures, Data management systems, Mathematics of computing, Database theory, Software and its engineering, Object oriented languages, Computing methodologies, Parallel computing methodologies, Language types, Data structures, Record storage systems, Parallel programming languages, Distributed computing methodologies, Numerical analysis, Information storage systems, Data structures and algorithms for data management, Distributed programming languages, General programming languages, Computation of transforms, Data structures design and analysis, Design and analysis of algorithms, Compilers]
Code reuse in an optimizing compiler
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
This paper describes how the cmcc compiler reuses code---both internally (reuse between different modules) and externally (reuse between versions for different target machines). The key to reuse are the application frameworks developed for global data-flow analysis, code generation, instruction scheduling, and register allocation.The code produced by cmcc is as good as the code produced by the native compilers for the MIPS and SPARC, although significantly less resources have been spent on cmcc (overall, about 6 man years by 2.5 persons). cmcc is implemented in C++, which allowed for a compact expression of the frameworks as class hierarchies. The results support the claim that suitable frameworks facilitate reuse and thereby significantly improve developer effectiveness.
[Source code generation, Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Software notations and tools, Software development techniques, Software and its engineering, Compilers]
A monotonic superclass linearization for Dylan
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Object-oriented languages with multiple inheritance and automatic conflict resolution typically use a linearization of superclasses to determine which version of a property to inherit when several superclasses provide definitions. Recent work has defined several desirable characteristics for linearizations, the most important being monotonicity, which prohibits inherited properties from skipping over direct superclasses. Combined with Dylan's sealing mechanism, a monotonic linearization enables some compile-time method selection that would otherwise be impossible in the absence of a closed-world assumption.The Dylan linearization is monotonic, easily described, strictly observes local precedence order, and produces the same ordering as CLOS when that is monotonic. We present an implementation based on merging and a survey of class heterarchies from several large programs, analyzing where commonly used linearizations differ.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Vortex: an optimizing compiler for object-oriented languages
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Previously, techniques such as class hierarchy analysis and profile-guided receiver class prediction have been demonstrated to greatly improve the performance of applications written in pure object-oriented languages, but the degree to which these results are transferable to applications written in hybrid languages has been unclear. In part to answer this question, we have developed the Vortex compiler infrastructure, a language-independent optimizing compiler for object-oriented languages, with front-ends for Cecil, C++, Java, and Modula-3. In this paper, we describe the Vortex compiler's intermediate language, internal structure, and optimization suite, and then we report the results of experiments assessing the effectiveness of different combinations of optimizations on sizable applications across these four languages. We characterize the benchmark programs in terms of a collection of static and dynamic metrics, intended to quantify aspects of the "object-orientedness" of a program.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Perspectives on reuse (panel)
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Reuse is about more than sharing code. As technology, standards and ideas evolve: so do the artifacts available for reuse. Our understanding of the non-technical issues associated with reuse also progresses. This panel will look at reuse from 5 different perspectives. We will look at the reuse of design patterns and of services in a service-based, distributed architecture as examples of artifacts relatively new to the corporate world. We will also focus on the psychological factors affecting the success of reuse programs along with organizational modifications and measurement techniques that will help make reuse work. Lastly, we will take a look at how certain kinds of reuse can affect the success of a project at the user level, and what this might imply for measuring the effectiveness of our reuse programs. The audience will leave with some concrete ideas about how to implement and measure reuse program as well as new thoughts on what artifacts may be reused.
[Management of computing and information systems, Software creation and management, Reusability, Object oriented languages, Language types, Human-centered computing, Professional topics, Software notations and tools, Human computer interaction (HCI), Software development techniques, General programming languages, Software management, Social and professional topics, Software and its engineering]
Split objects: a disciplined use of delegation within objects
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
This paper's primary aim is to improve the understanding of the delegation mechanism as defined in [18]. We propose a new characterization of delegation based on the notions of name sharing, property sharing and value sharing. It allows us (1) to clearly differentiate delegation from class-inheritance in particular and more generally from other inheritance mechanisms and (2) to explain how a founded use of delegation relies on a correct semantics of variable property sharing between objects connected by a delegation link. We then describe a model of split objects which is proposed as an example of a disciplined and semantically founded use of delegation, where property sharing expresses viewpoints within objects.
[Object oriented languages, Language features, Language types, Software notations and tools, Data structures, Record storage systems, Information systems, Theory of computation, Theory and algorithms for application domains, Semantics and reasoning, Information storage systems, Data structures and algorithms for data management, General programming languages, Data structures design and analysis, Program semantics, Data types and structures, Data management systems, Design and analysis of algorithms, Database theory, Software and its engineering]
Reorganizing split objects
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Object-based (i.e. classless) models are very effective for elucidating requirements from users, and they support exploratory programming and rapid prototyping, providing a direct manipulation approach. On the other hand, class-based models have powerful mechanisms to control redundancy, exploit sharing, express extension, and propagate changes to instances.The price object-based approaches pay is loss of control over change propagation, and potential redundancy. Two mechanisms to overcome this are sharing among objects and definition of objects as extension of others. We examine these mechanisms, and consider the effect that interacting policies for objects sharing and definition-by-extension have on change propagation and replication control. An implication is that, in absence of meta-objects or extra-language support, monolithic shared parts cannot coexist with prototypes represented as split objects.
[Object oriented languages, Language features, Language types, Software notations and tools, Data structures, Record storage systems, Information systems, Theory of computation, Theory and algorithms for application domains, Information storage systems, Data structures and algorithms for data management, General programming languages, Data structures design and analysis, Data types and structures, Data management systems, Design and analysis of algorithms, Database theory, Software and its engineering]
Lessons learned from implementing the CORBA persistent object service
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
In this paper, the authors share their experiences gathered during the design and implementation of the CORBA Persistent Object Service. There are two problems related to a design and implementation of the Persistence Service: first, OMG intentionally leaves the functionality core of the Persistence Service unspecified; second, OMG encourages reuse of other Object Services without being specific enough in this respect. The paper identifies the key design issues implied both by the intentional lack of OMG specification and the limits of the implementation environment characteristics. At the same time, the paper discusses the benefits and drawbacks of reusing other Object Services, particularly the Relationship and Externalization Services, to support the Persistence Service. Surprisingly, the key lesson learned is that a direct reuse of these Object Services is impossible.
[Language features, Software notations and tools, Information systems, Theory of computation, Theory and algorithms for application domains, Computer systems organization, Distributed architectures, Data types and structures, Data management systems, Database theory, Software organization and properties, Software and its engineering, Object oriented languages, Language types, Data structures, Record storage systems, Distributed systems organizing principles, Software system structures, Information storage systems, Data structures and algorithms for data management, General programming languages, Data structures design and analysis, Design and analysis of algorithms, Architectures]
A situated evaluation of the Object Management Group's (OMG) Object Management Architecture (OMA)
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
It has been difficult to objectively assess the real value or maturity of the Object Management Group's Object Management Architecture (OMA). While experience reports have appeared in the literature, these have focused more on the functionality of the end-system than on systematically exploring the strengths and weaknesses of the OMA, and providing practical guidelines on the effective use of the OMA for specific software-engineering problems. In this paper we describe a case study in the use of the OMA to integrate legacy software components into a distributed object system. We assess the OMA in this problem context, and indicate strengths and weaknesses of the specification and current implementations. We extrapolate our experience to a broader class of component-based software systems, and recommend an architectural strategy for the effective use of the OMA to this class of systems.
[Software design techniques, Operations research, Software creation and management, Software development methods, Object oriented languages, Language types, Software notations and tools, Computer-aided manufacturing, Software implementation planning, Applied computing, Designing software, Software development process management, General programming languages, Software and its engineering]
Slicing class hierarchies in C++
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
This paper describes an algorithm for slicing class hierarchies in C++ programs. Given a C++ class hierarchy (a collection of C++ classes and inheritance relations among them) and a program P that uses the hierarchy, the algorithm eliminates from the hierarchy those data members, member functions, classes, and inheritance relations that are unnecessary for ensuring that the semantics of P is maintained.Class slicing is especially useful when the program P is generated from a larger program P' by a statement slicing algorithm. Such an algorithm eliminates statements that are irrelevant to a set of slicing criteria---program points of particular interest. There has been considerable previous work on statement slicing, and it will not be the concern of this paper. However, the combination of statement slicing and class slicing for C++ has two principal applications: First, class slicing can enhance statement slicing's utility in program debugging and understanding applications, by eliminating both executable and declarative program components irrelevant to the slicing criteria. Second, the combination of the two slicing algorithms can be used to decrease the space requirements of programs that do not use all the components of a class hierarchy. Such a situation is particularly common in programs that use class libraries.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Data types and structures, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering]
A functional layer for description logics: knowledge representation meets object-oriented programming
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
The paper motivates the facilities provided by Description Logics in an object-oriented programming scenario. It presents a unification approach of Description Logics and object-oriented programming that allows both views to be conveniently used for different subproblems in a modern software-engineering environment. The main thesis of this paper is that in order to use Description Logics in practical applications, a seamless integration with object-oriented system development methodologies must be realized.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Program semantics, Language types, Software notations and tools, Logic, Software and its engineering]
Environmental acquisition: a new inheritance-like abstraction mechanism
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
The class of an object is not necessarily the only determiner of its runtime behaviour. Often it is necessary to have an object behave differently depending upon the other objects to which it is connected. However, as it currently stands, object-oriented programming provides no support for this concept, and little recognition of its role in common, practical programming situations. This paper investigates a new programming paradigm, environmental acquisition in the context of object aggregation, in which objects acquire behaviour from their current containers at runtime. The key idea is that the behaviour of a component may depend upon its enclosing composite(s). In particular, we propose a form of feature sharing in which an object "inherits" features from the classes of objects in its environment. By examining the declaration of classes, it is possible to determine which kinds of classes may contain a component, and which components must be contained in a given kind of composite. These relationships are the basis for language constructs that supports acquisition. We develop the theory of acquisition that includes topics such as the kinds of links along which acquisition may occur, and the behaviour of routine (methods) and attribute features under acquisition. The proposed model for acquisition as a hierarchical abstraction mechanism is a strongly typed model that allows static type checking of programs exploiting this mechanism. We compare it to several other mechanisms including inheritance and delegation, and show that it is significantly different than these.
[Object oriented languages, Language types, Human-centered computing, Software notations and tools, Human computer interaction (HCI), Program constructs, Theory of computation, Touch screens, Interaction devices, Semantics and reasoning, General programming languages, Interaction design, Interaction paradigms, Functional constructs, Type structures, Software and its engineering]
Soft issues and hard problems in software development (panel)
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
The key to making object technology work isn't technology. So what is it? This panel will cover a lot of the "soft" issues about dealing with people and teams. It's partly about managing software development, and mostly about doing it.
[Management of computing and information systems, Project and people management, Software creation and management, Object oriented languages, Language types, Human-centered computing, Professional topics, Software notations and tools, Human computer interaction (HCI), Software configuration management and version control systems, Software development process management, General programming languages, Software management, Social and professional topics, Software and its engineering]
Automatic inheritance hierarchy restructuring and method refactoring
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Most, object-oriented programs have imperfectly designed inheritance hierarchies and imperfectly factored methods, and these imperfections tend to increase with maintenance. Hence, even object-oriented programs are more expensive to maintain, harder to understand and larger than necessary. Automatic restructuring of inheritance hierarchies and refactoring of methods can improve the design of inheritance hierarchies, and the factoring of methods. This results in programs being smaller, having better code re-use and being more consistent. This paper describes Guru, a prototype tool for automatic inheritance hierarchy restructuring and method refactoring of Self programs. Results from realistic applications of the tool are presented.
[Decision support systems, Software creation and management, Reusability, Object oriented languages, Language features, Language types, Information systems applications, Software notations and tools, Program constructs, Software development techniques, Information systems, Theory of computation, Semantics and reasoning, General programming languages, Program reasoning, Logic, Expert systems, Software and its engineering]
On automatic class insertion with overloading
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Several algorithms [Cas92, MS89, Run92, DDHL94a, DDHL95, GMM95] have been proposed to automatically insert a class into an inheritance hierarchy. But actual hierarchies all include overriden and overloaded properties that these algorithms handle either very partially or not at all. Partially handled means handled provided there is a separate given function f able to compare overloaded properties [DDHL95, GMM95].In this paper, we describe a new version of our algorithm (named Ares) which handles automatic class insertion more efficiently using such a function f. Although impossible to fully define, this function can be computed for a number of well defined cases of overloading and overriding. We give a classification of such cases and describe the computation process for a well-defined set of nontrivial cases.The algorithm preserves these important properties:- preservation of the maximal factorization of properties- preservation of the underlying structure (Galois lattice) of the input hierarchy- conservation of relevant classes of the input hierarchy with their properties.
[Software creation and management, Reusability, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Software development techniques, Theory of computation, Semantics and reasoning, General programming languages, Logic, Functional constructs, Software and its engineering]
Reuse contracts: managing the evolution of reusable assets
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
A critical concern in the reuse of software is the propagation of changes made to reusable artifacts. Without techniques to manage these changes, multiple versions of these artifacts will propagate through different systems and reusers will not be able to benefit from improvements to the original artifact. We propose to codify the management of change in a software system by means of reuse contracts that record the protocol between managers and users of a reusable asset. Just as real world contracts can be extended, amended and customised, reuse contracts are subject to parallel changes encoded by formal reuse operators: extension, refinement and concretisation. Reuse contracts and their operators serve as structured documentation and facilitate the propagation of changes to reusable assets by indicating how much work is needed to update previously built applications, where and how to test and how to adjust these applications.
[Software creation and management, Reusability, General programming languages, Object oriented languages, Documentation, Language types, Software notations and tools, Software post-development issues, Software development techniques, Software and its engineering]
OO anthropology (panel): crossing the chasm
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Anthropology is the study of civilization, particularly its societies, customs, structure, and evolution. Our premise is that there are cultureal "chasms" to be crossed to ensure the success of the technological beachhead established by innovators and early adopters of the OO paradigm. Our panelists will address the following questions:&amp;bull;What anthropological cultural factors have to be "matured" (and how?) to foster the success of the OO paradigm?&amp;bull;What mechanisms are required to facilitate communications between cultures of differing maturity?&amp;bull;What cultural chasms must be crossed to develop a successful organization/culture within the framework supported by the object-oriented paradigm (or more perrversely, is there anything "special" about the OO paradigm)?This panel will interest pracitioners as a forum to share and debate experiences related to our current-day software culture metamorphosis.
[Management of computing and information systems, Project and people management, Software creation and management, Object oriented languages, Language types, Human-centered computing, Professional topics, Software notations and tools, Law, social and behavioral sciences, Human computer interaction (HCI), Software configuration management and version control systems, Applied computing, Software development process management, General programming languages, Software management, Sociology, Social and professional topics, Software and its engineering]
Simple and effective analysis of statically-typed object-oriented programs
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
To use modern hardware effectively, compilers need extensive control-flow information. Unfortunately, the frequent method invocations in object-oriented languages obscure control flow. In this paper, we describe and evaluate a range of analysis techniques to convert method invocations into direct calls for statically-typed object-oriented languages and thus improve control-flow information in object-oriented languages. We present simple algorithms for type hierarchy analysis, aggregate analysis, and interprocedural and intraprocedural type propagation. These algorithms are also fast, O(|procedures| * &amp;sum;pprocedure np * vp) worst case time (linear in practice) for our slowest analysis, where np is the size of procedure p and vp is the number of variables in procedure p, and are thus practical for use in a compiler. When they fail, we introduce cause analysis to reveal the source of imprecision and suggest where more powerful algorithms may be warranted. We show that our simple analyses perform almost as well as an oracle that resolves all method invocations that invoke only a single procedure.
[Procedures, functions and subroutines, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Functional constructs, Type structures, Software and its engineering, Compilers]
The direct cost of virtual function calls in C++
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
We study the direct cost of virtual function calls in C++ programs, assuming the standard implementation using virtual function tables. We measure this overhead experimentally for a number of large benchmark programs, using a combination of executable inspection and processor simulation. Our results show that the C++ programs measured spend a median of 5.2% of their time and 3.7% of their instructions in dispatch code. For "all virtuals" versions of the programs, the median overhead rises to 13.7% (13% of the instructions). The "thunk" variant of the virtual function table implementation reduces the overhead by a median of 21% relative to the standard implementation. On future processors, these overheads are likely to increase moderately.
[Procedures, functions and subroutines, Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Object oriented languages, Language features, Software performance, Language types, Professional topics, Software notations and tools, Extra-functional properties, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering, Compilers]
Fast static analysis of C++ virtual function calls
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Virtual functions make code easier for programmers to reuse but also make it harder for compilers to analyze. We investigate the ability of three static analysis algorithms to improve C++ programs by resolving virtual function calls, thereby reducing compiled code size and reducing program complexity so as to improve both human and automated program understanding and analysis. In measurements of seven programs of significant size (5000 to 20000 lines of code each) we found that on average the most precise of the three algorithms resolved 71% of the virtual function calls and reduced compiled code size by 25%. This algorithm is very fast: it analyzes 3300 source lines per second on an 80 MHz PowerPC 601. Because of its accuracy and speed, this algorithm is an excellent candidate for inclusion in production C++ compilers.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering, Compilers]
Change cases: use cases that identify future requirements
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Evolution of software systems is prompted by all sorts of changes. This paper demonstrates how the use case, a well known construct in object-oriented analysis, is adapted to form the change case, to identify and articulate anticipated system changes. A change case provides the ability to identify and incorporate expected future change into a design to enhance the long-term robustness of that design. In this paper, we define change cases and demonstrate how change cases are captured by the analyst. We present examples to illustrate how change cases can influence present system design and point the way toward designs that more easily accommodate expected future changes. Change cases can be effectively employed in the context of any methodology that supports use cases and traceability links.
[Management of computing and information systems, Project and people management, Software maintenance, Software creation and management, Software development methods, Object oriented languages, Language types, Professional topics, Software notations and tools, Software post-development issues, Software development process management, General programming languages, Software management, Systems analysis and design, Software reverse engineering, Social and professional topics, Software and its engineering]
Using role components in implement collaboration-based designs
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
In this paper we present a method of code implementation that works in conjunction with collaboration and responsibility based analysis modeling techniques to achieve better code reuse and resilience to change. Our approach maintains a closer mapping from responsibilities in the analysis model to entities in the implementation. In so doing, it leverages the features of flexible design and design reuse found in collaboration-based design models to provide similar adaptability and reuse in the implementation. Our approach requires no special development tools and uses only standard features available in the C++ language. In an earlier paper we described the basic mechanisms used by our approach and discussed its advantages in comparison to the framework approach. In this paper we show how our approach combines code and design reuse, describing specific techniques that can be used in the development of larger applications.
[Software creation and management, Reusability, Object oriented languages, Language features, Language types, Software notations and tools, Software post-development issues, Software development techniques, General programming languages, Data types and structures, Software reverse engineering, Software and its engineering]
Formal design constraints
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Large software systems are often built on system platforms that support or enforce specific characteristics of the source code or actual design. These characteristics are either captured informally in design guideline documents or in specialized design and implementation languages.In our view, both approaches are unsatisfactory. Informal descriptions do not allow automated analysis and lead to vague constraint descriptions. The language-based approach leads to different languages for different platforms and even for different versions of the same basic platform.Our approach is to describe and name the constraints separately in a design constraint language called CDL, which is based on an extraordinarily concise logic of parse trees. Designs are then annotated with the names of the constraints they are supposed to satisfy.We discuss how the design constraint language is integrated into a design language environment. We exhibit industrial and experimental evidence that our choice of design constraint language allows us to formalize naturally and succinctly common design characteristics.
[Parsers, Design languages, Object oriented languages, Language types, Human-centered computing, Software notations and tools, Human computer interaction (HCI), System description languages, Computability, Theory of computation, Models of computation, General programming languages, Logic, Software and its engineering, Compilers]
Object on the server: are we ready? (panel)
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Object-oriented concepts such as reuse and encapsulation offer many benefits to application development, particularly in managing complexity and change. All the benefits of OO that apply to the client can apply equally well to the server. However, until recently, these concepts have proven to benefit only the client side. Could there be any intrinsic or conceptual reason for this? Or could it be a result of timing, the availability of the tools, and the conservative restraints that result from the mission-critical nature of server computing?This panel will explore the roles of objects on the server by examining the experiences of the panelists from a technology consumer's perspective. By doing so, we would like to provide insights for corporations that are making decisions on OO technology, point out pitfalls along the way, and identify potential opportunities for technology providers.All panelists have developed production level object servers. The panel will answer the question of whether we are ready for object servers by discussing the following issues:&amp;bull; Different server types: transactional server, data server, application server, web server, etc. Are they really that much different? Which one is the most important kind?&amp;bull; Experience in implementing and maintaining object systems on the server: the configurations of the systems and how they were arrived at; the tools and programming languages used.&amp;bull; Benefits and drawbacks of server object systems.&amp;bull; What's hard? What's easy?&amp;bull; What are the prerequisites for pervasive deployments of objects on the server? (e.g., standards, application types, customer situations, tools, and languages.)&amp;bull; What would be desirable for technology providers (researchers and vendors) to provide? (Tools, languages, execution environments that represents vendor opportunities.)&amp;bull; Practical advice to organizations interested in introducing objects to the server.
[Management of computing and information systems, System management, File systems management, Object oriented languages, Language types, Professional topics, Software notations and tools, Business process management, Computing and business, Applied computing, Enterprise computing, General programming languages, Social and professional topics, Software and its engineering]
Architecture-oriented visualization
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Tracking the changing dynamics of object-oriented frameworks[5], design patterns[7], architectural styles[8], and subsystems during the development and reuse cycle can aid producing complex systems. Unfortunately, current object-oriented programming tools are relatively oblivious to the rich architectural abstractions in a system.This paper shows that architecture-oriented visualization, the graphical presentation of system statics and dynamics in terms of its architectural abstractions, is highly beneficial in designing complex systems. In addition, the paper presents architecture-aware instrumentation, a new technique for building efficient on-line instrumentation to support architectural queries. We demonstrate the effectiveness and performance of the scheme with case studies in the design of the Choices object-oriented operating system.
[Visual languages, Software design techniques, Measurement, Cross-computing tools and techniques, Software creation and management, Object oriented languages, Language types, Context specific languages, Software notations and tools, Contextual software domains, Software implementation planning, Designing software, Software development process management, Operating systems, General programming languages, General and reference, Software organization and properties, Software and its engineering]
A framework for run-time systems and its visual programming language
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
Frameworks and domain-specific visual languages are two different reuse techniques, the first targeted at expert programmers, the second at domain experts. In fact, these techniques are closely related. This paper shows how to develop a domain-specific visual language by first developing a white-box framework for the domain, then turning it into a black-box framework, and finally building a graphical front end for it. We used this technique in a compiler to specify run-time systems.
[Visual languages, Software creation and management, Reusability, Language features, Object oriented languages, Context specific languages, Language types, Software notations and tools, Development frameworks and environments, Software development techniques, Integrated and visual development environments, General programming languages, Data types and structures, Software and its engineering]
Semantic-based visualization for parallel object-oriented programming
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
We present a graphical environment for parallel object-oriented programming. It provides visual tools to develop and debug object-oriented programs as well as parallel or concurrent systems. This environment was derived from a structural operational semantics of an extension of the Eiffel language, Eiffel//. Object-related features of the language (inheritance, polymorphism) are formalized using a big-step semantics, while the interleaving model of concurrency is expressed with small-step semantics.Without user instrumentation, the interactive environment proposes features such as step-by-step animated executions, graphical visualization of object and process topology, futures and pending requests, control of interleaving, deadlock detection.
[Visual languages, Software defect analysis, Software creation and management, Operational semantics, Object oriented languages, Software verification and validation, Language types, Computing methodologies, Parallel computing methodologies, Context specific languages, Software notations and tools, Parallel programming languages, Theory of computation, Semantics and reasoning, Software testing and debugging, General programming languages, Program semantics, Software and its engineering]
Translation: myth or reality? (panel)
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
In the realm of OO methodologies there are two major schools of thought. Both schools claim to define mechanisms whereby software applications can be created that are reusable, maintainable, and robust. Moreover, both schools claim to use abstraction as a key mechanism for achieving these benefits. At issue is whether or not these two schools are fundamentally different, or just variations on an object-oriented theme.Shlaer and Mellor have dubbed one of these schools "Translational". In the translational approach, two models are created. One is an abstract model of the application domain which is devoid of any design dependencies. The other model is an abstract model of the design which is devoid of any application dependencies. These two models are composed automatically to yield the code for the system.The other school - supported by Booch, Rumbaugh, Jacobson, and Martin - views the architecture of a system from several different perspectives of abstraction, e.g. logical, physical. These abstractions typically form a layer; abstractions in the logical sense manifest themselves as individual classes as well as collaborations of classes. There may be one layered model, at different layers of abstraction, or, especially given the Objectory view point, there may be multiple models, with an analysis model that's nearly independent from the design model.The panel will explore:&amp;bull; Is there a seamless transition between analysis and design?&amp;bull; Should there be a single model or should there be two - one for the analysis and one for the design?&amp;bull; If there are two models, how are they "bridged"?&amp;bull; What, if any, are the differences in process between the two schools?&amp;bull; How does architecture manifest itself!&amp;bull; Is there, in fact, a real difference between the two schools of thought?As a result of this exploration, we hope to answer the question: Is translation a myth or is it a reality?
[Designing software, Software creation and management, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Components on the Internet (panel)
Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 31 ISSUE 10
1996
The explosive emergence of the Internet forces us to rethink the traditional roles for client, server, and objects. Component technology has emerged as the way objects and frameworks are packaged for flexible object integration. In particular, components allow users who are not programmers to do their own integration. Up until now, components have mainly focused on object integration on end-users desktops and on a client: compound documents, application assembly, etc.Existing component models like OpenDoc and Microsoft's OLE/OCX/COM provide function for compound documents, persistence, scripting, inking, and code management (registration). A series of Internet scenarios are emerging that demand new kinds of components. These scenarios are thin clients (Internet terminals), virtual reality/rich multimedia clients, collaboration, and business data access. Each panelist will explore one of these scenarios for it's requirements on an Internet component model.
[Web applications, Human-centered computing, World Wide Web, Information retrieval, Human computer interaction (HCI), Information systems, Distributed systems organizing principles, Software system structures, Organizing principles for web applications, Information storage systems, Internet communications tools, Software organization and properties, Software and its engineering]
Maintaining the consistency of class libraries during their evolution
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Two important problems of object-oriented reuse are the propagation of design and implementation specifics of the base software to the inheritors, and the protection of the inheritors against changes in the base software. In this paper, we argue that the simple inheritance rules of existing object-oriented languages are not sufficient for properly dealing with these problems. In the proposal presented in this paper, programmers are enabled to make metalevel declarations of the internal protocols and dependencies of their classes. Additionally, changes of the base module are automatically monitored to filter out information about the alterations that may invalidate already existing inheritors. Based on these informations, the subclassing semantics is adjusted such that the maintenance of the base module properties and the protection of the inheritor is ensured during their integration, In this way, language support is provided for keeping the behavior of reusable software consistent during its evolution.
[Management of computing and information systems, Software maintenance, Software creation and management, Reusability, Object oriented languages, Professional topics, Language types, Software notations and tools, Software development techniques, Theory of computation, Semantics and reasoning, Software management, General programming languages, Semantics, Program semantics, Formal language definitions, Social and professional topics, Software libraries and repositories, Software and its engineering]
Analyzing and measuring reusability in object-oriented design
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
In this paper, we present a technique to analyze and measure the reusability of object-oriented (OO) designs. The metrics can be incorporated into a design/development environment, so that reusability measurements, analysis, and improvements can be part of "business as usual" for an organization. Design reusability measurements also enable early identification of poor reuse potential, when it is still possible to modify/refine the design. The essential components of our approach are two reuse-specific characterizations of classes and hierarchies, and a set of metrics which objectively measures the dependencies among design components based on those reuse-specific characterizations.
[Cross-computing tools and techniques, Software creation and management, Reusability, Language features, Object oriented languages, Language types, Software notations and tools, Software development techniques, Metrics, General programming languages, General and reference, Software and its engineering]
Adding type parameterization to the Java language
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Although the Java programming language has achieved widespread acceptance, one feature that seems sorely missed is the ability to use type parameters (as in Ada generics, C++ templates, and ML polymorphic functions or data types) to allow a general concept to be instantiated to one or more specific types. In this paper, we propose parameterized classes and interfaces in which the type parameter may be constrained to either implement a given interface or extend a given class. This design allows the body of a parameterized class to refer to methods on objects of the parameter type, without introducing any new type relations into the language. We show that these Java extensions may be implemented by expanding parameterized classes at class load time, without any extension or modification to existing Java bytecode, verifier or bytecode interpreter.
[General programming languages, Language features, Data types and structures, Language types, Software notations and tools, Software and its engineering]
Parasitic methods: an implementation of multi-methods for Java
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
In an object-oriented programming language, method selection is (usually) done at run-time using the class of the receiver. Some object-oriented languages (such as CLOS) have multi-methods which comprise several methods selected on the basis of the runtime classes of all the parameters, not just the receiver. Multi-methods permit intuitive and typesafe definition of binary methods such as structural equality, set inclusion and matrix multiplication, just to name a few. Java as currently defined does not support multimethods. This paper defines a simple extension to Java that enables the writing of "encapsulated" multi-methods through the use of parasitic methods, methods that "attach" themselves to other methods. Encapsulated multi-methods avoid some of the modularity problems that, arise with fully general multi-methods. Furthermore, this. extension yields for free both covariant and contravariant specialization of methods (besides Java's current invariant specialization).Programs using this extension. can be translated automatically at the source level into programs that do not; they are modular, type-safe, and allow separate compilation.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Modeling dynamic collections of interdependent objects using path-based rules
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Standard object-oriented languages do not provide language support for modeling changing collections of interdependent objects. We propose that R++, an integration of the rule and object-oriented paradigms, provides a mechanism for easily implementing such models. R++ extends C++ by adding a new programming construct called the path-based rule. Such data-driven rules are restricted to follow pointers between objects, and are like "automatic methods" that are triggered by changes to monitored objects. Path-based rules encourage a more abstract level of programming, and unlike previous rule integrations, are not at odds with the object-oriented paradigm and offer performance advantages for natural applications.
[Object oriented languages, Language types, Computing methodologies, Paths and connectivity problems, Software notations and tools, Graph theory, Mathematical software, Modeling and simulation, General programming languages, Discrete mathematics, Mathematics of computing, Software and its engineering]
Looking for the objects in object-relational DBMSs (panel)
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
The Relational Model first came into vogue in the early 1980's. It was based on the simplifying idea that all data could be modeled as mathematical relations (tables in "normal form"). Permissible operations on this table data structure were specified by the relation algebra and calculus. The Relational Model led to years of research in areas such as query languages, query optimization, transaction models, and database design methodologies. This research has dominated DBMS conferences for the last fifteen years and has also lead to major products offerings in wide-spread use in the computer industry today.While the Relational revolution was happening in the DBMS community there was a minority opinion emerging from the object community. This minority opinion surfaced in heated debates and panels at DBMS conferences where it was often pitted against "relational purists." The object proponents wanted to discuss storing and retrieving complex objects and relationships in databases while the relational purists insisted on maintaining "mathematical purity and simplicity". These panels were often some of the most acrimonious (and entertaining) at these conferences and many thought there was no way to bridge the chasm between the two schools of thought.However times changes and so do the realities of the commercial world. Object languages such as C++, Smalltalk, and Java have become de facto standards. The Internet and the PC have increased the demand for complex data types. And the relational model is evolving to accommodate these realities.All of the major RDBMS vendors have announced plans for, or are already shipping, Object-Relational DBMS (ORDBMS) products. A natural question for the object community is how well these new products will address the well-known "impedance mismatch" between a pure object model and the relational model. For example, how does one make Java, Smalltalk, or C++ objects persist using an ORDBMS? Can one search for these objects in the database using their methods?The vendors for ORDBMS are claiming well-known OO features in their implementations, such as extensible data types, inheritance, object identity, and object language bindings. This panel will allow the major vendors to explain how those features match up with the kinds of object models that OO developers are accustomed to. The panel will consist of representatives from three of the major ORDBMS vendors as well as a representative of "pure object think". The vendor representatives will each present a brief overview of the object-related features of their products and will explain why OO programmers are going to have an easier time with these ORDBMSs. This will be followed by counterpoint discussion from the pure object thinker.
[Computing industry, Computer manufacturing, Data management systems, Professional topics, Social and professional topics, Information systems, Database management system engines]
A framework for scalable dissemination-based systems
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
The dramatic improvements in global interconnectivity due to intranets, extranets, and the Internet has led to an explosion in the number and variety of new data-intensive applications. Along with the proliferation of these new applications have come increased problems of scale. This is demonstrated by frequent delays and service, disruptions when accessing networked data sources. Recently, push-based techniques have been proposed as a solution to scalability problems for distributed applications. This paper argues that push indeed has its place, but that it is just one aspect of a much larger design space for distributed information systems. We propose the notion of a Dissemination-Based Information System (DBIS) which integrates a variety of data delivery mechanisms and information broker hierarchies. We discuss the properties of such systems and provide some insight into the architectural imperatives that will influence their design. The DBIS framework can serve as the basis for development of a toolkit for constructing distributed information systems that better match the technology they employ to the characteristics of the applications they are intended to support.
[Communication hardware, interfaces and storage, Networks, Cross-computing tools and techniques, Learning paradigms, Computing methodologies, Dependable and fault-tolerant systems and networks, Network architectures, Information systems, Computer systems organization, Supervised learning, Classification and regression trees, Machine learning, Data management systems, Machine learning approaches, Hardware, Performance, General and reference, Network performance evaluation, Supervised learning by classification]
Exploring largeness, complexity and scalability from the OOT perspective (panel)
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
This panel will lay the foundation for understanding the needs of Large Systems so that OO practitioners can:&amp;bull; appreciate the problems faced;&amp;bull; understand the issues involved; and&amp;bull; re-orient the approaches to provide a viable solution when participating in similar efforts.Specifically, this panel will establish the foundation for discussions on Large Systems by establishing concepts, exposing terminology, and highlighting the state-of-the art.Large applications are usually complex and display one or more of the following dimensions of largeness:&amp;bull; Processing power: requiring tens to hundreds of gigabytes of memory and hundreds of gigaflops performance&amp;bull; High connectivity: highly-connected, systems can show aggregate behavior with complex characteristics: they can become chaotic.&amp;bull; Online access: Archival of terabytes of information, with the need to provide online access to information&amp;bull; Archival and online retrieval: The two technologies (database and archival storage), however, currently do not interoperate. There is a need to develop interfaces to integrate these two technologies.&amp;bull; Data-intensive scientific applications: These involve constructing a data handling infrastructure that simplifies the effort required to maintain petabyte archives, identify relevant data sets within the archive, move, the data to processing platforms, and distribute the data sets across multiple nodes.&amp;bull; Internet access: Large applications often require simultaneous access of information by millions of users worldwide;they must provide acceptable response times.&amp;bull; Scaleable architecture: The systems must be prepared to support exponential growth of application load.Is OOT up to the task? OO practitioners will be encountering some of these application domains in the near future. Some may have already gained some experience in trying to solve these problems. However, the literature in OO does not provide sufficient evidence to believe that OO is ready for such large systems today. Part of the problem is the cross-disciplinary nature of these problems requires a steep learning curve for OO practitioners to be effective. The modeling of these problems with an OO approach is also a challenge. Current 00 methods do not do a good job of supporting multiple views of a domain, and multiple layers of a complex application domain.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Call graph construction in object-oriented languages
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Interprocedural analyses enable optimizing compilers to more precisely model the effects of non-inlined procedure calls, potentially resulting in substantial increases in application performance. Applying interprocedural analysis to programs written in object-oriented or functional languages is complicated by the difficulty of constructing an accurate program call graph. This paper presents a parameterized algorithmic framework for call graph construction in the presence of message sends and/or first class functions. We use this framework to describe and to implement a number of well-known and new algorithms. We then empirically assess these algorithms by applying them to a suite of medium-sized programs written in Cecil and Java, reporting on the relative cost of the analyses, the relative precision of the constructed call graphs, and the impact of this precision on the effectiveness of a number of interprocedural optimizations.
[General programming languages, Object oriented languages, Language types, Discrete mathematics, Software notations and tools, Mathematics of computing, Mathematical software, Software and its engineering, Compilers]
Efficient dynamic dispatch without virtual function tables: the SmallEiffel compiler
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
SmallEiffel is an Eiffel compiler which uses a fast simple type inference mechanism to remove most late binding calls, replacing them by static bindings. Starting from the system's entry point, it compiles only statically living code, which saves compiling and then removing dead code. As the whole system is analyzed at compile time, multiple inheritance and genericity do not cause any overhead.SmallEiffel features a coding scheme which eliminates the need for virtual function tables. Dynamic dispatch is implemented without any array access but uses a simple static binary branch code. We show that this implementation makes it possible to use modern hardware very efficiently. It also allows us to inline more calls even when dynamic dispatch is required. Some more dispatch sites are removed after the type inference algorithm has been performed, if the different branches of a dispatch site lead to the same code.The advantage of this approach is that it greatly speeds up execution time and considerably decreases the amount of generated code.
[General programming languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Efficient type inclusion tests
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
A type inclusion test determines whether one type is a subtype of another. Efficient type testing techniques exist for single subtyping, but not for languages with multiple subtyping. To date, the fast constant-time technique relies on a binary matrix encoding of the subtype relation with quadratic space requirements. In this paper, we present three new encodings of the subtype relation, the packed encoding, the bit-packed encoding and the compact encoding. These encodings have different characteristics. The bit-packed encoding delivers the best compression rates: on average 85% for real life programs. The packed encoding performs type inclusion tests in only 4 machine instructions. We present a fast algorithm for computing these encoding which runs in less than 13 milliseconds for PE and BPE, and 23 milliseconds for CE on an Alpha processor. Finally, we compare our results with other constant-time type inclusion tests on a suite of 11 large -benchmark hierarchies.
[Software defect analysis, Software creation and management, Language features, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Mathematical software, Computability, Theory of computation, Models of computation, Software testing and debugging, General programming languages, Data types and structures, Mathematics of computing, Logic, Software and its engineering]
Changing the engine of the car? (panel): while driving 60 miles an hour!
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Most software development projects don't practice what is usually considered "proper" software engineering practices: well-documented, traceable requirements do not exist, formal inspections are non-existent, analysis and design inodels are incomplete or not even done at all, and so forth. We know that many of these projects fail, and it is easy to blame the failure of the project on the lack of good software engineering practices ("If we only had well-documented requirements, a complete and thorough test plan, and formal schedules then we would have been successful!")But many projects that do not practice what many consider to be good software engineering practices succeed, and succeed famously. Examples include the startup introducing a revolutionary new product, the skunkworks project of an established firm that succeeds in changing the status quo, and selecting a mission critical application as the first OO application of a group just beginning to make the transition to the new technology.Gaining a deeper understanding of success and failure on software projects is absolutely essential for the continued maturation of our industry, and object technology in particular.
[Management of computing and information systems, Software creation and management, Software management, General programming languages, Object oriented languages, Professional topics, Language types, Software notations and tools, Social and professional topics, Software and its engineering]
Garbage collecting the world: one car at a time
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
A new garbage collection algorithm for distributed object systems, called DMOS (Distributed. Mature Object Space), is presented. It is derived from two previous algorithms, MOS (Mature Object Space), sometimes called the train algorithm, and PMOS (Persistent Mature Object Space). The contribution of DMOS is that it provides the following unique combination of properties for a distributed collector: safety, completeness, non-disruptiveness, incrementality, and scalability. Furthermore, the DMOS collector is non-blocking and does not use global tracing.
[Object oriented languages, Language types, Software notations and tools, Mathematical software, Contextual software domains, Operating systems, Memory management, General programming languages, Allocation / deallocation strategies, Discrete mathematics, Mathematics of computing, Software organization and properties, Software and its engineering]
Ephemerons : a new finalization mechanism
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Finalization occurs when a garbage collector informs an application that an object is "almost collectable." It is used to help an application maintain its invariants. To make finalization more useful, this paper defines "almost collectable" in terms of a new class of objects, called ephemerons. Ephemerons are similar to weak pairs, but an object in an ephemeron's key field may be classed as "almost collectable" even if it is reachable from the epehemeron's value fields.
[Operating systems, Memory management, General programming languages, Allocation / deallocation strategies, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
The design and performance of a real-time CORBA event service
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
The CORBA Event Service provides a flexible model for asynchronous communication among objects. However, the standard CORBA Event Service specification lacks important features required by real-time applications. For instance, operational flight programs for fighter aircraft have complex real-time processing requirements. This paper describes the design and performance of an object-oriented, real-time implementation of the GORBA Event Service that is designed to meet these requirements.This paper makes three contributions to the design and performance measurement of object-oriented real-time systems. First, it illustrates how to extend the CORBA Event Service so that it is suitable for real-time systems. These extensions support periodic rate-based event processing and efficient event filtering and correlation. Second, it describes how to develop object-oriented event dispatching and scheduling mechanisms that can provide real-time guarantees. Finally, the paper presents benchmarks that demonstrate the performance tradeoffs of alternative concurrent dispatching mechanisms for real-time Event Services.
[Object oriented languages, Embedded and cyber-physical systems, Language types, Professional topics, Software notations and tools, Computing standards, RFCs and guidelines, Embedded software, Computer systems organization, Computing industry, Software system structures, Embedded systems, General programming languages, Document types, Real-time systems, Social and professional topics, General and reference, Software organization and properties, Software and its engineering, Real-time systems software]
UML (panel): the language of blueprints for software?
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
The Unified Method was launched by Grady Booch and Jim Rumbaugh at an OOPSLA'95 Conference Fringe meeting organised by Rational Software Corporation. In 1996 the Unified Method was re-scoped to a notation, and renamed the Unified Modeling Language (UML).Earlier this year, UML was submitted to the Object Management Group for standardisation and has been endorsed by Microsoft, IBM, HP, Platinum Technologies, ObjectTime and many other corporations. No wonder UML is the leading contender as the de facto standard notation for object-oriented analysis and design.The panel will take a sanity check, and will go beyond the hype and newsgroup flames and attempt to form an objective view of UML and its prospects.The members of the panel have been working closely with UhL in many different roles, including that of UML language designer, end-user, consultant, CASE tool expert, and object-oriented methodologist. The discussion will focus on how LJML matches up in practice against one of its original. raisons d'etre as "the language of blueprints for software".Specific issues to be addressed include:&amp;bull; What is the advantage of UML over existing OOA/D notations?&amp;bull; Can UML be used on real projects today?&amp;bull; Is the language sufficiently simple, and well-enough defined, to become the de facto standard?&amp;bull; Will UML lead to improved OOA/D methods and CASE tools?&amp;bull; What is the importance of the meta-model in UML?
[Modeling and simulation, General programming languages, Simulation support systems, Language types, Computing methodologies, Software notations and tools, Software and its engineering, Simulation languages]
Tiling design patterns-a case study using the interpreter pattern
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
This paper explains how patterns can be used to describe the implementation of other patterns. It is demonstrated how certain design patterns can describe their own design. This is a fundamental reflexive relationship in pattern relationships. The process of assembling patterns by other patterns is named pattern tiling. Tiling enables us to interweave simple understood concepts of patterns into their complex real-life implementation. Several pattern tilings for the Interpreter design pattern are illustrated.
[Designing software, Software creation and management, General programming languages, Object oriented languages, Interpreters, Discrete mathematics, Language types, Software notations and tools, Mathematics of computing, Software and its engineering, Compilers]
Composite design patterns
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Software design patterns are the core abstractions from successful recurring problem solutions in software design. Composite design patterns are the core abstractions from successful recurring frameworks. A composite design pattern is a pattern that is best described as the composition of further patterns the integration of which shows a synergy that makes the composition more than just the sum of its parts. This paper presents examples of composite patterns, discusses a role-based analysis and composition technique, and demonstrates that composite patterns extend the pattern idea from single problem solutions to object-oriented frameworks.
[Designing software, Software creation and management, Software and its engineering]
An open implementation analysis and design for lightweight threads
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Open Implementation Analysis and Design (OIA/D) has been introduced as a design methodology for object-oriented software systems, and in particular for substrate software. In this paper we detail our experiences with using OIA/D to design and implement a common substrate component for parallel language runtime systems: a lightweight threads package. We show how existing thread packages employ a "black-box" design, hiding crucial design decisions that drastically reduce their ability to be re-used. We detail these design decisions (dilemmas) and show how an implementation based on OIA/D principles results in a thread package that is flexible, efficient, portable, and re-usable.
[Theory of computation, Models of computation, Designing software, Software creation and management, General programming languages, Object oriented languages, Concurrency, Language types, Software notations and tools, Software and its engineering, Parallel computing models]
Migrating relational data to an ODBMS: strategics and lessons from a molecular biology experience
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
The growing maturity of ODBMS technology is causing many enterprises to consider migrating relational databases to ODBMS's. While data remapping is relatively straightforward in most cases, greater challenges lie in economically and non-invasively adapting legacy application software. We report on a genetics laboratory database migration experiment, which was facilitated by both organization of the relational data in object-like form and a C++ framework designed to insulate application code from relational artifacts. Although this experiment was largely successful, we discovered to our surprise that the framework failed to encapsulate three subtle aspects of the relational implementation, thereby "contaminating" application code. We analyze the underlying issues, and offer cautionary guidance to future migrators.
[Applied computing, Life and medical sciences, Systems biology, Data management systems, Genetics, Information systems, Database management system engines, Computational biology]
The ODMG object model: does it make sense?
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
The ODMG Object Model is shown to have a number of problems. A major confusion is caused by the intended type of polymorphism and the way it is expressed in the Model. Dynamic type checking is required even in situations when static type checking is possible. There are situations in which there is no way that type checking can determine whether a particular construct is type correct or not. The model of persistence in the ODMG Standard is not orthogonal, which has undesirable pragmatic consequences on complex objects. The discrepancies between the ODMG Object Model and the particular language bindings of the ODMG Standard are non-trivial. This paper presents solutions to some of these problems together with the associated formal system. Without such a formal system the recommended ODMG bindings are open to a wide range of different, and sometimes confusing interpretations. The criticism expressed in the paper is intended to be helpful in developing future releases of the ODMG Standard.
[Object oriented languages, Professional topics, Language types, Software notations and tools, Computing standards, RFCs and guidelines, Information systems, Computing industry, Document types, General programming languages, Social and professional topics, General and reference, Software and its engineering]
Class hierarchy specialization
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Class libraries are generally designed with an emphasis on versatility and extensibility. Applications that use a library typically exercise only part of the library's functionality. As a result, objects created by the application may contain unused members. We present an algorithm that specializes a class hierarchy with respect to its usage in a program P. That is, the algorithm analyzes the member access patterns for P's variables, and creates distinct classes for variables that access different members. Class hierarchy specialization reduces object size, and is hence primarily a space optimization. However, execution time may also be reduced through reduced object creation/destruction time, and caching/paging effects.
[General programming languages, Language features, Discrete mathematics, Language types, Software notations and tools, Mathematics of computing, Mathematical software, Software libraries and repositories, Software and its engineering]
Declarative specialization of object-oriented programs
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Designing and implementing generic software components is encouraged by languages such as object-oriented ones and commonly advocated in most application areas. Generic software components have many advantages among which the most important is reusability. However, it comes at a price: genericity often incurs a loss of efficiency.This paper presents an approach aimed at reconciling genericity and efficiency. To do so, we introduce declarations to the Java language to enable a programmer to specify how generic programs should be specialized for a particular usage pattern. Our approach has been implemented as a compiler from our extended language into standard Java.
[Object oriented languages, Language types, Software notations and tools, Mathematical software, Theory of computation, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Mathematics of computing, Software and its engineering, Compilers]
The OT idea life-cycle (panel): from eureka! to shrink wrap
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Over the past years, the Object Technology community has seen the birth of a number of new technology ideas that have changed the way we do computing. These ideas have affected compiler design, analysis approaches, project management techniques, user interface design, deployment strategies and implementation tactics. But where do these ideas come from? And how do they evolve? Do they address the needs as specified by members of the Object Community? Is there a way we can nurture the introduction and assimilation of these ideas to and by the community at large? And what are the market forces that bend ideas to their will. This panel will look at new ideas in Object Technology from a variety of perspectives and will attempt to get to the heart of the way that we, as technologists, create, buy, sell and grow ideas.
[Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Query-based debugging of object-oriented programs
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Object relationships in modem software systems are becoming increasingly numerous and complex. Programmers who try to find violations of such relationships need new tools that allow them to explore objects in a large system more efficiently. Many existing debuggers present only a low-level, one-object-at-a-time view of objects and their relationships. We propose a new solution to overcome these problems: query-based debugging. The implementation of the query-based debugger described here offers programmers an effective query tool that allows efficient searching of large object spaces and quick verification of complex relationships. Even for programs that have large numbers of objects, the debugger achieves interactive response times for common queries by using a combination of fast searching primitives, query optimization, and incremental result delivery.
[Software defect analysis, Software creation and management, Integrated and visual development environments, Software testing and debugging, General programming languages, Object oriented languages, Software verification and validation, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Back to the future: the story of Squeak, a practical Smalltalk written in itself
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Squeak is an open, highly-portable Smalltalk implementation whose virtual machine is written entirely in Smalltalk, making it easy to. debug, analyze, and change. To achieve practical performance, a translator produces an equivalent C program whose performance is comparable to commercial Smalltalks.Other noteworthy aspects of Squeak include: a compact object format that typically requires only a single word of overhead per object; a simple yet efficient incremental garbage collector for 32-bit direct pointers; efficient bulk-mutation of objects; extensions of BitBlt to handle color of any depth and anti-aliased image rotation and scaling; and real-time sound and music synthesis written entirely in Smalltalk.
[General programming languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Constraint diagrams: visualizing invariants in object-oriented models
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
A new visual notation is proposed for precisely expressing constraints on object-oriented models, as an alternative to mathematical logic notation used in methods such as Syntropy and Catalysis. The notation is potentially intuitive, expressive, integrates well with existing visual notations, and has a clear and unambiguous semantics. It is reminiscent of informal diagrams used by mathematicians for illustrating relations, and borrows much from Venn diagrams. It may be viewed as a generalization of instance diagrams.
[Management of computing and information systems, Software creation and management, Object oriented languages, Language types, Professional topics, Software notations and tools, Designing software, General programming languages, Software management, Social and professional topics, Software libraries and repositories, Software and its engineering]
Beyond the hype (panel): do patterns and frameworks reduce discovery costs?
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 32 ISSUE 10
1997
Patterns and frameworks are two approaches to the development of both new and evolving software systems. An implicit hypothesis is that "discovery costs" are reduced by leveraging knowledge previously collected, analyzed, organized, and packaged. "Discovery costs" (or "getting started" costs) include both the costs of understanding the problem to be solved and the cost of understanding the tools, methods, existing software, etc. For large, multi-year development projects in industries such as defense or telecommunications, discovery costs can dominate the overall cost (and risk) of software development.This panel will share its experience and perspectives with the audience with a discussion initiated by the following questions:&amp;bull; Have patterns and frameworks really delivered on their claims for reducing discovery costs? Can current best-practices be characterized as meaningful or marginal (what are the measures)?&amp;bull; What are the discovery cost factors where frameworks and patterns appear to deliver the biggest bang for the buck?&amp;bull; While mature pattern languages and frameworks may reduce the learning curve, they do not, eliminate it. How much of a learning curve is required to develop a sufficient shared context with the authors of a set of patterns or a framework?
[Management of computing and information systems, Designing software, Software creation and management, General programming languages, Object oriented languages, Software management, Language types, Professional topics, Software notations and tools, Social and professional topics, Software and its engineering]
An evaluation of automatic object inline allocation techniques
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Object-oriented languages such as Java and Smalltalk provide a uniform object reference model, allowing objects to be conveniently shared. If implemented directly, these uniform reference models can suffer in efficiency due to additional memory dereferences and memory management operations. Automatic inline allocation of child objects within parent objects can reduce overheads of heap-allocated pointer-referenced objects.We present three compiler analyses to identify inlinable fields by tracking accesses to heap objects. These analyses span a range from local data flow to adaptive whole-program, flow-sensitive inter-procedural analysis. We measure their cost and effectiveness on a suite of moderate-sized C++ programs (up to 30,000 lines including libraries). We show that aggressive interprocedural analysis is required to enable object inlining, and our adaptive inter-procedural analysis [23] computes precise information efficiently. Object inlining eliminates typically 40% of object accesses and allocations (improving performance up to 50%). Furthermore,
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Dynamic class loading in the Java virtual machine
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Class loaders are a powerful mechanism for dynamically loading software components on the Java platform. They are unusual in supporting all of the following features: laziness, type-safe linkage, user-defined extensibility, and multiple communicating namespaces.We present the notion of class loaders and demonstrate some of their interesting uses. In addition, we discuss how to maintain type safety in the presence of user-defined dynamic class loading.
[General programming languages, Language types, Context specific languages, Software notations and tools, Software and its engineering]
Object-oriented practice in 1998 (panel): does it help or hinder collaboration?
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Groups of people working in concert perform most commercial, industrial or in-house software development. These groups are often quite diverse. This panel brings together object-oriented consultants and developers as well as practitioners and researchers interested in human factors and user-centered design, project management and technical writing. The panel will address the question, "To successfully complete today's projects, does object-oriented development as practiced today do an adequate job of supporting ALL of the participants who must collaborate?"
[Management of computing and information systems, Software creation and management, Collaborative and social computing, Object oriented languages, Language types, Human-centered computing, Professional topics, Software notations and tools, General programming languages, Software management, Social and professional topics, Software and its engineering]
Ownership types for flexible alias protection
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Object-oriented programming languages allow inter-object aliasing. Although necessary to construct linked data structures and networks of interacting objects, aliasing is problematic in that an aggregate object's state can change via an alias to one of its components, without the aggregate being aware of any aliasing.Ownership types form a static type system that indicates object ownership. This provides a flexible mechanism to limit the visibility of object references and restrict access paths to objects, thus controlling a system's dynamic topology. The type system is shown to be sound, and the specific aliasing properties that a system's object graph satisfies are formulated and proven invariant for well-typed programs.
[Theory of computation, Semantics and reasoning, Operational semantics, General programming languages, Object oriented languages, Program semantics, Language types, Software notations and tools, Software and its engineering]
Borrow, copy or steal?: loans and larceny in the orthodox canonical form
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Dynamic memory management in C++ is complex, especially across the boundaries of library abstract data types. C++ libraries designed in the orthodox canonical form (OCF) alleviate some of the problems by ensuring that classes which manage any kind of heap structures faithfully copy and delete these. However, in certain common circumstances, OCF heap structures are wastefully copied multiple times. General reference counting is not an option in OCF, since a shared body violates the intended value semantics; although a copy-on-write policy can be made to work with borrowed heap structures. A simpler ownership policy, based on larceny, allows low-level memory manager objects to steal heap structures from temporary variables, in properly isolated circumstances. Various strategies for regulating theft are presented, ranging from pilfer-constructors to locks on heap data. Larceny has similarities with other transfer of ownership patterns, but is more a core implementation technique designed to improve the efficiency and effectiveness of OCF-conformant libraries.
[File systems management, Language types, Software notations and tools, Contextual software domains, Information systems, Information storage systems, Operating systems, General programming languages, Storage management, Memory management, Software libraries and repositories, Software organization and properties, Software and its engineering]
Safe metaclass programming
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
In a system where classes are treated as first class objects, classes are defined as instances of other classes called metaclasses. An important benefit of using metaclasses is the ability to assign properties to classes (e.g. being abstract, being final, tracing particular messages, supporting multiple inheritance), independently from the base-level code. However, when both inheritance and instantiation are explicitly and simultaneously involved, communication between classes and their instances raises the metaclass compatibility issue. Some languages (such as S<sc>MALLTALK</sc>) address this issue but do not easily allow the assignment of specific properties to classes. In contrast, other languages (such as CLOS) allow the assignment of specific properties to classes but do not tackle the compatibility issue well.In this paper, we describe a new model of metalevel organization, called the compatibility model, which overcomes this difficulty. It allows safe metaclass programming since it makes it possible to assign specific properties to classes while ensuring metaclass compatibility. Therefore, we can take advantage of the expressive power of metaclasses to build reliable software. We extend this compatibility model in order to enable safe reuse and composition of class specific properties. This extension is implemented in N<sc>EOCLASSTALK</sc>, a fully reflective S<sc>MALLTALK</sc>.
[Management of computing and information systems, Software creation and management, Reusability, Language types, Professional topics, Software notations and tools, Software development techniques, General programming languages, Software management, Social and professional topics, Software libraries and repositories, Software and its engineering]
Adaptive plug-and-play components for evolutionary software development
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
In several works on design methodologies, design patterns, and programming language design, the need for program entities that capture the patterns of collaboration between several classes has been recognized. The idea is that in general the unit of reuse is not a single class, but a slice of behavior affecting a set of collaborating classes. The absence of large-scale components for expressing these collaborations makes object-oriented programs more difficult to maintain and reuse, because functionality is spread over several methods and it becomes difficult to get the "big picture". In this paper, we propose Adaptive Plug and Play Components to serve this need. These components are designed such that they not only facilitate the construction of complex software by making the collaborations explicit, but they do so in a manner that supports the evolutionary nature of both structure and behavior.
[Software implementation planning, Software design techniques, Management of computing and information systems, Designing software, Software development process management, Software creation and management, Software management, Professional topics, Social and professional topics, Software development techniques, Software and its engineering]
Role model based framework design and integration
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Today, any large object-oriented software system is built using frameworks. Yet, designing frameworks and defining their interaction with clients remains a difficult task. A primary reason is that today's dominant modeling concept, the class, is not well suited to describe the complexity of object collaborations as it emerges in framework design and integration. We use role modeling to overcome the problems and limitations of class-based modeling. Using role models, the design of a framework and its use by clients can be described succinctly and with much better separation of concerns than with classes. Using role objects, frameworks can be integrated into use-contexts that have not been foreseen by their original designers.
[Management of computing and information systems, Software creation and management, Object oriented languages, Language features, Language types, Professional topics, Software notations and tools, General programming languages, Software management, Frameworks, Social and professional topics, Software and its engineering]
How to preserve the benefits of design patterns
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
The rapid evolution of Design Patterns has hampered the benefits gained from using Design Patterns. The increase in the number of Design Patterns makes a common vocabulary unmanageable, and the tracing problem obscures the documentation that should be enhanced by using Design Patterns. We present an analysis of Design Patterns that will strongly reduce the number of Fundamental Design Patterns and show how strong language abstractions can solve the tracing problem and thereby enhance the documentation.
[Software design techniques, Management of computing and information systems, Software creation and management, Language features, Professional topics, Software notations and tools, Software implementation planning, Designing software, Software development process management, Software management, General programming languages, Social and professional topics, Software and its engineering]
Data groups: specifying the modification of extended state
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
This paper explores the interpretation of specifications in the context of an object-oriented programming language with subclassing and method overrides. In particular, the paper considers annotations for describing what variables a method may change and the interpretation of these annotations. The paper shows that there is a problem to be solved in the specification of methods whose overrides may modify additional state introduced in subclasses. As a solution to this problem, the paper introduces data groups, which enable modular checking and rather naturally capture a programmer's design decisions.
[Software implementation planning, Software design techniques, Designing software, Requirements analysis, Software development process management, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Logical observable entities
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
We show how finite-state machines can standardize the protocol used by a component object to notify other interested objects of its state changes, resulting in a more effective use of static types to constrain both parties, and a more efficient dissemination of information. The enhanced component specification is called a logical observable entity, or LOE. We address two key issues in effectively applying such a strategy: how to extend subtyping to consider the state machines, and how to ensure some kind of compliance between the state-machine specification and its implementation. This leads to an unusual subtyping predicate for LOEs on the one hand, and a prototype code generation strategy on the other.
[Theory of computation, Networks, Network protocols, Document types, Formal languages and automata theory, General and reference, Computing standards, RFCs and guidelines, Software and its engineering]
A lambda calculus of objects with self-inflicted extension
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
In this paper we investigate, in the context of functional prototype-based languages, objects which might extend themselves upon receiving a message. The possibility for an object of extending its own "self", referred to by Cardelli, as a self-inflicted operation, is novel in the context of typed object-based languages. We present a sound type system for this calculus which guarantees that evaluating a well-typed expression will never yield a message-not-found run-time error. We give several examples which illustrate the increased expressive power of our system with respect to existing calculi of objects. The new type system allows also for a flexible width-subtyping, still permitting sound method override, and a limited form of object extension. The resulting calculus appears to be a good starting point for a rigorous mathematical analysis of class-based languages.
[Operational semantics, Object oriented languages, Language types, Software notations and tools, Calculus, Program constructs, Computability, Theory of computation, Models of computation, Semantics and reasoning, Mathematical analysis, General programming languages, Lambda calculus, Continuous mathematics, Program semantics, Mathematics of computing, Type structures, Software and its engineering]
The new crop of Java virtual machines (panel)
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
None
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, General programming languages, Language types, Software notations and tools, Software and its engineering]
Making the future safe for the past: adding genericity to the Java programming language
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
We present GJ, a design that extends the Java programming language with generic types and methods. These are both explained and implemented by translation into the unextended language. The translation closely mimics the way generics are emulated by programmers: it erases all type parameters, maps type variables to their bounds, and inserts casts where needed. Some subtleties of the translation are caused by the handling of overriding.GJ increases expressiveness and safety: code utilizing generic libraries is no longer buried under a plethora of casts, and the corresponding casts inserted by the translation are guaranteed to not fail.GJ is designed to be fully backwards compatible with the current Java language, which simplifies the transition from non-generic to generic programming. In particular, one can retrofit existing library classes with generic interfaces without changing their code.An implementation of GJ has been written in GJ, and is freely available on the web.
[Computing / technology policy, Language types, Software notations and tools, Systems security, Operating systems security, Computer crime, Program constructs, Theory of computation, Semantics and reasoning, Security and privacy, General programming languages, Social and professional topics, Type structures, Software and its engineering]
Compatible genericity with run-time types for the Java programming language
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
The most serious impediment to writing substantial programs in the Java&amp;trade; programming language is the lack of a gentricity mechanism for abstracting classes and methods with respect to type. During the past two years, several research groups have developed Java extensions that support various forms of genericity, but none has succeeded in accommodating general type parameterization (akin to Java arrays) while retaining compatibility with the existing. Java Virtual Machine. In this paper, we explain how to support general type parameterization---including both non-variant and covariant subtyping---on top of the existing Java Virtual Machine at the cost of a larger code footprint and the forwarding of some method calls involving parameterized classes and methods. Our language extension is forward and backward compatible with the Java 1.2 language and run-time environment: programs in the extended language will run on existing Java 1.2 virtual machines (relying only on the unparameterized Java core libraries) and all existing Java 1.2 programs have the same binary representation and semantics (behavior) in the extended language.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering]
Parametric polymorphism for Java: a reflective solution
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
A number of inadequacies of existing implementation techniques for extending Java&amp;trade; with parametric polymorphism are revealed. Homogeneous translations are the most space-efficient but they are not compatible with reflection, some models of persistence, and multiple dispatch. Heterogeneous translations, on the other hand, can potentially produce large amounts of redundant information. Implementation techniques that address these concerns are developed. In languages that support run-time reflection, an adequate implementation of parametric, bounded and F-bounded polymorphism is shown to require (reflective) run-time support. In Java, extensions to the core classes are needed. This is in spite of the fact that parametric polymorphism is intended to be managed statically.
[General programming languages, Language types, Software notations and tools, Software and its engineering]
Question time! about use cases
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
None
[Management of computing and information systems, Software creation and management, General programming languages, Object oriented languages, Software management, Language types, Professional topics, Software notations and tools, Social and professional topics, Software and its engineering]
Vclusters: a flexible, fine-grained object clustering mechanism
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
We consider the problem of delivering an effective fine-grained clustering tool to implementors and users of object-oriented database systems. This work emphasizes on-line clustering mechanisms, as contrasted with earlier work that concentrates on clustering policies (deciding which objects should be near each other). Existing on-line clustering methods can be ineffective and/or difficult to use and may lead to poor space utilization on disk and in the disk block cache, particularly for small- to medium-size groups of objects. We introduce variable-size clusters (Vclusters), a fine-grained object clustering architecture that can be used directly or as the target of an automatic clustering algorithm. We describe an implementation of Vclusters in the Shore OODBMS and present experimental results that show that Vclusters significantly outperform other mechanisms commonly found in object database systems (fixed-size clusters and near hints). Vclusters deliver excellent clustering and space utilization with only a modest cost for maintaining clustering during updates.
[]
System support for object groups
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
This paper draws several observations from our experiences in building support for object groups. These observations actually go beyond our experiences and may apply to many other developments of object based distributed systems.Our first experience aimed at building support for Smalltalk object replication using the Isis process group toolkit. It was quite easy to achieve group transparency but we were confronted with a strong mismatch between the rigidity of the process group model and the flexible nature of object interactions. Consequently, we decided to build our own object oriented protocol framework, specifically dedicated to support object groups (instead of using a process group toolkit). We built our framework in such a way that basic distributed protocols, such as failure detection and multicasts, are considered as first class entities, directly accessible to the programmers. To achieve flexible and dynamic protocol composition, we had to go beyond inheritance and objectify distributed algorithms.Our second experience consisted in building a CORBA service aimed at managing group of objects written on different languages and running on different platforms. This experience revealed a mismatch between the asynchrony of group protocols and the synchrony of standard CORBA interaction mechanisms, which limited the portability of our CORBA object group service. We restricted the impact of this mismatch by encapsulating asynchrony issues inside a specific messaging sub-service.We dissect the cost of object group transparency in our various implementations, and we point out the recurrent sources of overheads, namely message indirection, marshaling/unmarshaling and strong consistency.
[Networks, Management of computing and information systems, Project and people management, Software creation and management, Network protocols, Collaborative and social computing, Object oriented languages, Human-centered computing, Professional topics, Language types, Software notations and tools, Software configuration management and version control systems, Designing software, Requirements analysis, Software development process management, General programming languages, Social and professional topics, Software and its engineering]
Extending the ODMG object model with composite objects
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
In this paper we extend the ODMG object data model with composite objects. A composite object is an object built by aggregating other component objects. Exclusiveness and dependency constraints, as well as referential integrity, can be associated with composition relationships among objects. Our composite object model is developed in the framework of the ODMG object database standard data model, but can be used in both object-oriented and object-relational database systems. In the paper, we propose a language for defining composite objects and we define the semantics of update operations on composite objects.
[Object oriented languages, Language types, Software notations and tools, Information retrieval, Information systems, Database management system engines, Theory of computation, Theory and algorithms for application domains, Database and storage security, Security and privacy, General programming languages, Data management systems, Database design and models, Database theory, Theory of database privacy and security, Software and its engineering]
Visualizing dynamic software system information through high-level models
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Dynamic information collected as a software system executes can help software engineers perform some tasks on a system more effectively. To interpret the sizable amount of data generated from a system's execution, engineers require tool support. We have developed an off-line, flexible approach for visualizing the operation of an object-oriented system at the architectural level. This approach complements and extends existing profiling and visualization approaches available to engineers attempting to utilize dynamic information. In this paper, we describe the technique and discuss preliminary qualitative studies into its usefulness and usability. These studies were undertaken in the context of performance tuning tasks.
[Visual languages, Management of computing and information systems, Software management, Professional topics, Context specific languages, Software notations and tools, Social and professional topics, Development frameworks and environments, Software and its engineering]
Object lessons learned from a distributed system for remote building monitoring and operation
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
In this paper we describe our experiences with the design, the deployment, and the initial operation of a distributed system for the remote monitoring and operation of multiple heterogeneous commercial buildings across the Internet from a single control center. Such systems can significantly reduce building energy usage.Our system is distinguished by its ability to interface to multiple heterogeneous legacy building Energy Management Control Systems (EMCSs), its use of the Common Object Request Broker Architecture (CORBA) standard communication protocols for the former task, development of a standardized naming system for monitoring points in buildings, the use of a relational DBMS to store and process time series data, automatic time and unit conversion, and a scripted time series visualization system.We describe our design choices and our experiences in development and operation. We note requirements for future distributed systems software for interoperability of heterogeneous real-time data acquisition and control systems.
[Distributed retrieval, Parallel and distributed DBMSs, Object oriented languages, Storage architectures, Language types, Information retrieval, Software notations and tools, Distributed storage, Information systems, Database management system engines, Theory of computation, Theory and algorithms for application domains, Database and storage security, Search engine architectures and scalability, Security and privacy, Information storage systems, General programming languages, Data management systems, Database design and models, Database theory, Theory of database privacy and security, Peer-to-peer retrieval, Software and its engineering]
Lightweight object-oriented shared variables for distributed applications on the Internet
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
This paper describes a lightweight yet powerful approach for writing distributed applications using shared variables. Our approach, called S<sc>HARE</sc>H<sc>OLDER</sc>, is inspired by the flexible and intuitive model of information access common to the World Wide Web. The distributed applications targeted by our approach all share a weak consistency model and loose transaction semantics, similar to a user's model of accessing email, bulletin boards, chat rooms, etc. on the Internet. The S<sc>HARE</sc>H<sc>OLDER</sc> infrastructure has several advantages. Its highly object-oriented view of shared variables simplifies their initialization and configuration. A shared variable's distribution mechanism is specified through an associated configuration object, and the programmer does not need to write any extra code to implement the sharing mechanism. These configuration objects can be initialized at run-time, allowing tremendous flexibility in dynamic control of distribution of shared variables. Finally, the programmer can treat shared variables and local variables interchangeably, thus simplifying conversion of a serial application into a distributed application.
[Transport protocols, Distributed retrieval, Networks, Network protocols, Web applications, Software notations and tools, World Wide Web, Network types, Information systems, Database management system engines, Computer systems organization, Web-based interaction, Search engine architectures and scalability, Distributed architectures, Data management systems, Software organization and properties, Software and its engineering, Parallel and distributed DBMSs, Object oriented languages, Storage architectures, Language types, Human-centered computing, Information retrieval, Human computer interaction (HCI), Distributed storage, Distributed systems organizing principles, Software system structures, Web services, Information storage systems, General programming languages, Public Internet, Interaction paradigms, Peer-to-peer retrieval, Architectures]
A type system for object initialization in the Java bytecode language
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
In the standard Java implementation, a Java language program is compiled to Java bytecode. This bytecode may be sent across the network to another site, where it is then interpreted by the Java Virtual Machine. Since bytecode may be written by hand, or corrupted during network transmission, the Java Virtual Machine contains a bytecode verifier that performs a number of consistency checks before code is interpreted. As illustrated by previous attacks on the Java Virtual Machine, these tests, which include type correctness, are critical for system security. In order to analyze existing bytecode verifiers and to understand the properties that should be verified, we develop a precise specification of statically-correct Java bytecode, in the form of a type system. Our focus in this paper is a subset of the bytecode language dealing with object creation and initialization. For this subset, we prove that for every Java bytecode program that satisfies our typing constraints, every object is initialized before it is used. The type system is easily combined with a previous system developed by Stata and Abadi for bytecode subroutines. Our analysis of subroutines and object initialization reveals a previously unpublished bug in the Sun JDK bytecode verifier.
[Theory of computation, Semantics and reasoning, Operational semantics, General programming languages, Language features, Program semantics, Language types, Software notations and tools, Program constructs, Type structures, Software and its engineering]
Reasoning about Java classes: preliminary report
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
We present the first results of a project called LOOP, on formal methods for the object-oriented language Java. It aims at verification of program properties, with support of modern tools. We use our own front-end tool (which is still partly under construction) for translating Java classes into higher order logic, and a back-end theorem prover (namely PVS, developed at SRI) for reasoning. In several examples we demonstrate how non-trivial properties of Java programs and classes can be proven following this two-step approach.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Language types, Software notations and tools, Verification, Formal languages and automata theory, Software verification, Program verification, Theory of computation, Designing software, Software development process management, Requirements analysis, Semantics and reasoning, General programming languages, Formal language definitions, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
What is Java binary compatibility?
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Separate compilation allows the decomposition of programs into units that may be compiled separately, and linked into an executable. Traditionally, separate compilation was equivalent to the compilation of all units together, and modification and re-compilation of one unit required re-compilation of all importing units.Java suggests a more flexible framework, in which the linker checks the integrity of the binaries to be combined. Certain source code modifications, such as addition of methods to classes, are defined as binary compatible. The language description guarantees that binaries of types (i.e. classes or interfaces) modified in binary compatible ways may be re-compiled and linked with the binaries of types that imported and were compiled using the earlier versions of the modified types.However, this is not always the case: some of the changes considered by Java as binary compatible do not guarantee successful linking and execution. In this paper we study the concepts around binary compatibility. We suggest a formalization of the requirement of safe linking and execution without re-compilation, investigate alternatives, demonstrate several of its properties, and propose a more restricted definition of binary compatible changes. Finally, we prove for a substantial subset of Java, that this restricted definition guarantees error-free linking and execution.
[General programming languages, Language features, Language types, Software notations and tools, Modules / packages, Software and its engineering, Compilers]
Compound types for Java
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Type compatibility can be defined based on name equivalence, that is, explicit declarations, or on structural matching. We argue that component software has demands for both. For types expressing individual contracts, name equivalence should be used so that references are made to external semantical specifications. For types that are composed of several such contracts, the structure of this composition should decide about compatibility.We introduce compound types as the mechanism to handle such compositions. To investigate the integrability into a strongly typed language, we add compound types to Java and report on a mechanical soundness proof of the resulting type system.Java users benefit from the higher expressiveness of the extended type system. We introduce compound types as a strict extension of Java, that is without invalidating existing programs. In addition, our proposal can be implemented on the existing Java Virtual Machine.
[Software design techniques, Software creation and management, Object oriented languages, Language types, Software notations and tools, Program constructs, Theory of computation, Software implementation planning, Designing software, Software development process management, Semantics and reasoning, General programming languages, Type structures, Software and its engineering]
Multiple dispatch as dispatch on Tuples
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
Many popular object-oriented programming languages, such as C++, Smalltalk-80, Java, and Eiffel, do not support multiple dispatch. Yet without multiple dispatch, programmers find it difficult to express binary methods and design patterns such as the "visitor" pattern. We describe a new, simple, and orthogonal way to add multimethods to single-dispatch object-oriented languages, without affecting existing code. The new mechanism also clarifies many differences between single and multiple dispatch.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language types, Software notations and tools, Formal language definitions, Formal languages and automata theory, Program constructs, Type structures, Software and its engineering]
Contraint-based polymorphism in Cecil: towards a practical and static type system
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
We present a static type system for object-oriented languages which strives to provide static typechecking without resorting to dynamic "type casts," restricting what code the programmer can write, or being too verbose or difficult to use in practice. The type system supports bounded parametric polymorphism where the bounds on type variables can be expressed using general recursive subtype or signature constraints, with F-bounded polymorphism and covariant type parameters being special cases.We implemented this type system in the Cecil language and used it to successfully typecheck a 100,000-line Cecil program, the Vortex optimizing compiler. Our experience was very good: dynamically-typed code needed very little rewriting. We also observed several common programming situations that presented a challenge for our type system. We discuss these situations and ways to typecheck them statically.
[Object oriented languages, Language types, Software notations and tools, Formal languages and automata theory, Program constructs, Theory of computation, Semantics and reasoning, General programming languages, Formal language definitions, Type structures, Software and its engineering, Compilers]
Building distributed systems (panel)
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
None
[Distributed retrieval, Search engine architectures and scalability, Parallel and distributed DBMSs, Information storage systems, Storage architectures, Data management systems, Information retrieval, Peer-to-peer retrieval, Distributed storage, Information systems, Database management system engines]
Software reuse (panel): nemesis or nirvana?
Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 33 ISSUE 10
1998
None
[Management of computing and information systems, Software creation and management, Reusability, Software management, Professional topics, Software notations and tools, Social and professional topics, Software development techniques, Software libraries and repositories, Software and its engineering]
Escape analysis for Java
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
This paper presents a simple and efficient data flow algorithm for escape analysis of objects in Java programs to determine (i) if an object can be allocated on the stack; (ii) if an object is accessed only by a single thread during its lifetime, so that synchronization operations on that object can be removed. We introduce a new program abstraction for escape analysis, the <italic>connection graph</italic>, that is used to establish reachability relationships between objects and object references. We show that the connection graph can be summarized for each method such that the same summary information may be used effectively in different calling contexts. We present an interprocedural algorithm that uses the above property to efficiently compute the connection graph and identify the non-escaping objects for methods and threads. The experimental results, from a prototype implementation of our framework in the IBM High Performance Compiler for Java, are very promising. The percentage of objects that may be allocated on the stack exceeds 70% of all dynamically created objects in three out of the ten benchmarks (with a median of 19%), 11% to 92% of all lock operations are eliminated in those ten programs (with a median of 51%), and the overall execution time reduction ranges from 2% to 23% (with a median of 7%) on a 333 MHz PowerPC workstation with 128 MB memory.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Language features, Software verification and validation, Language types, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Discrete mathematics, Mathematics of computing, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Escape analysis for object-oriented languages: application to Java
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Escape analysis [27, 14, 5] is a static analysis that determines whether the lifetime of data exceeds its static scope.The main originality of our escape analysis is that it determines precisely the effect of assignments, which is necessary to apply it to object oriented languages with promising results, whereas previous work [27, 14, 5] applied it to functional languages and were very imprecise on assignments. Our implementation analyses the full Java&trade; Language.We have applied our analysis to stack allocation and synchronization elimination. We manage to stack allocate 13% to 95% of data, eliminate more than 20% of synchronizations on most programs (94% and 99% on two examples) and get up to 44% speedup (21% on average). Our detailed experimental study on large programs shows that the improvement comes from the decrease of the garbage collection and allocation times than from improvements on data locality [7], contrary to what happened for ML [5].
[Software creation and management, Language features, Software verification and validation, Software notations and tools, Software verification, Theory of computation, Software development process management, Semantics and reasoning, Mathematical analysis, Mathematics of computing, Program reasoning, Formal methods, Software organization and properties, Software and its engineering, Cross-computing tools and techniques, Software functional properties, Object oriented languages, Language types, Verification, Program verification, Numerical analysis, General programming languages, Computation of transforms, Formal software verification, General and reference]
Detecting defects in object-oriented designs: using reading techniques to increase software quality
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Inspections can be used to identify defects in software artifacts. In this way, inspection methods help to improve software quality, especially when used early in software development. Inspections of software design may be especially crucial since design defects (problems of correctness and completeness with respect to the requirements, internal consistency, or other quality attributes) can directly affect the quality of, and effort required for, the implementation.We have created a set of "reading techniques" (so called because they help a reviewer to "read" a design artifact for the purpose of finding relevant information) that gives specific and practical guidance for identifying defects in Object-Oriented designs. Each reading technique in the family focuses the reviewer on some aspect of the design, with the goal that an inspection team applying the entire family should achieve a high degree of coverage of the design defects.In this paper, we present an overview of this new set of reading techniques. We discuss how some elements of these techniques are based on empirical results concerning an analogous set of reading techniques that supports defect detection in requirements documents. We present an initial empirical study that was run to assess the feasibility of these new techniques, and discuss the changes made to the latest version of the techniques based on the results of this study.
[Software defect analysis, System management, Software creation and management, Software verification and validation, Professional topics, Software notations and tools, Software verification, Theory of computation, Software development process management, Quality assurance, Semantics and reasoning, Program reasoning, Social and professional topics, Formal methods, Software organization and properties, Software and its engineering, Cross-computing tools and techniques, Management of computing and information systems, Object oriented languages, Software functional properties, Language types, Verification, Program verification, Software testing and debugging, General programming languages, Formal software verification, General and reference]
A problem-oriented analysis of basic UML static requirements modeling concepts
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
The <italic>Unified Modeling Language</italic> (UML) is a standard modeling language in which some of the best object-oriented (OO) modeling experiences are embedded. In this paper we illustrate the role formal specification techniques can play in developing a precise semantics for the UML. We present a precise characterization of requirements-level (problem-oriented) Class Diagrams and outline how the characterization can be used to semantically analyze requirements Class Diagrams.
[Software creation and management, Language types, Software notations and tools, Theory of computation, Designing software, Requirements analysis, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Software and its engineering]
A language for specifying recursive traversals of object structures
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
We present a domain-specific language for specifying recursive traversals of object structures, for use with the visitor pattern. Traversals are traditionally specified as iterations, forcing the programmer to adopt an imperative style, or are hard-coded into the program or visitor. Our proposal allows a number of problems best approached by recursive means to be tackled with the visitor pattern, while retaining the benefits of a separate traversal specification.
[Language features, Context specific languages, Language types, Software notations and tools, Program schemes, Recursion, Program constructs, Specialized application languages, Theory of computation, Semantics and reasoning, General programming languages, Software and its engineering]
Confined types
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Sharing and transfer of object references is difficult to control in object-oriented languages. Unconstrained sharing poses serious problems for writing secure components in object-oriented languages. In this paper, we present a set of inexpensive syntactic constraints that strengthen encapsulation in object-oriented programs and facilitate the implementation of secure systems. We introduce two mechanisms: <italic>confined types</italic> to impose static scoping on dynamic object references and, for technical reasons, <italic>anonymous methods</italic> which are methods that do not reveal the identity of the current instance (this). Confined types protect objects from use by untrusted code, while anonymous methods allow standard classes to be reused from confined classes. We have implemented a verifier which performs a modular analysis of Java programs and provides a static guarantee that confinement is respected. We present security related programming examples.
[Language features, Object oriented languages, Computing / technology policy, Language types, Software notations and tools, Mathematical foundations of cryptography, Program constructs, Computer crime, Computability, Theory of computation, Models of computation, Coding theory, Semantics and reasoning, Security and privacy, General programming languages, Mathematics of computing, Social and professional topics, Cryptography, Logic, Software and its engineering, Information theory]
Modular type-based reverse engineering of parameterized types in Java code
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
An analysis is provided for Java programs that reverse engineers parameterized types into existing Java code. This analysis propagates precise type information about the contents of container objects. As an application, the analysis can be used to justify the safe removal of downcasts that are guaranteed to succeed. Another application is in automatically reverse engineering parameterized types into existing Java libraries, so that they can be used in Java dialects with parameterized types.
[Software creation and management, Language types, Software notations and tools, Software post-development issues, Mathematical foundations of cryptography, Formal languages and automata theory, Computability, Theory of computation, Models of computation, Coding theory, Security and privacy, General programming languages, Formal language definitions, Mathematics of computing, Software reverse engineering, Cryptography, Logic, Software and its engineering, Information theory]
Semantic analysis of virtual classes and nested classes
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Virtual classes and nested classes are distinguishing features of BETA. Nested classes originated from Simula, but until recently they have not been part of main stream object- oriented languages. C++ has a restricted form of nested classes and they were included in Java 1.1. Virtual classes is the BETA mechanism for expressing generic classes and virtual classes is an alternative to parameterized classes. There has recently been an increasing interest in virtual classes and a number of proposals for adding virtual classes to other languages, extending virtual classes, and unifying virtual classes and parameterized classes have been made. Although virtual classes and nested classes have been used in BETA for more than a decade, their implementation has not been published. The purpose of this paper is to contribute to the understanding of virtual classes and nested classes by presenting the central elements of the semantic analysis used in the Mj&oslash;lner BETA compiler.
[Theory of computation, Classes and objects, Semantics and reasoning, General programming languages, Language features, Semantics, Program semantics, Language types, Software notations and tools, Formal language definitions, Software and its engineering]
Featherweight Java: a minimal core calculus for Java and GJ
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Several recent studies have introduced lightweight versions of Java: reduced languages in which complex features like threads and reflection are dropped to enable rigorous arguments about key properties such as type safety. We carry this process a step further, omitting almost all features of the full language (including interfaces and even assignment) to obtain a small calculus, Featherweight Java, for which rigorous proofs are not only possible but easy.Featherweight Java bears a similar relation to full Java as the lambda-calculus does to languages such as ML and Haskell. It offers a similar computational "feel," providing classes, methods, fields, inheritance, and dynamic typecasts, with a semantics closely following Java's. A proof of type safety for Featherweight Java thus illustrates many of the interesting features of a safety proof for the full language, while remaining pleasingly compact. The syntax, type rules, and operational semantics of Featherweight Java fit on one page, making it easier to understand the consequences of extensions and variations.As an illustration of its utility in this regard, we extend Featherweight Java with <italic>generic classes</italic> in the style of GJ (Bracha, Odersky, Stoutamire, and Wadler) and sketch a proof of type safety. The extended system formalizes for the first time some of the key features of GJ.
[Theory of computation, Models of computation, General programming languages, Language types, Software notations and tools, Formal language definitions, Formal languages and automata theory, Logic, Software and its engineering, Computability]
A formal framework for the Java bytecode language and verifier
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
This paper presents a sound type system for a large subset of the Java bytecode language including classes, interfaces, constructors, methods, exceptions, and bytecode subroutines. This work serves as the foundation for developing a formal specification of the bytecode language and the Java Virtual Machine's bytecode verifier. We also describe a prototype implementation of a type checker for our system and discuss some of the other applications of this work. For example, we show how to extend our work to examine other program properties, such as the correct use of object locks.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Language features, Software verification and validation, Language types, Software notations and tools, Verification, Software verification, Development frameworks and environments, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Program semantics, Frameworks, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Correspondence polymorphism for object-oriented languages
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
In this paper we propose a new form of polymorphism for object-oriented languages, called <italic>correspondence polymorphism</italic>. It lies in a different dimension than either parametric or subtype polymorphism. In correspondence polymorphism, some methods are declared to correspond to other methods, via a <italic>correspondence relation</italic>. With this relation, it is possible to reuse non-generic code in various type contexts-not necessarily subtyping or matching contexts-without having to plan ahead for this reuse. Correspondence polymorphism has advantages over other expressive object type systems in that programmer-declared types still may be simple, first-order types that are easily understood. We define a simple language LCP that reflects these new ideas, illustrating its behavior with multiple examples. We present formal type rules and an operational semantics for LCP, and establish soundness of the type system with respect to reduction.
[Operational semantics, Object oriented languages, Language types, Software notations and tools, Computability, Theory of computation, Models of computation, Semantics and reasoning, General programming languages, Program semantics, Logic, Software and its engineering]
Compositional pointer and escape analysis for Java programs
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
This paper presents a combined pointer and escape analysis algorithm for Java programs. The algorithm is based on the abstraction of points-to escape graphs, which characterize how local variables and fields in objects refer to other objects. Each points-to escape graph also contains escape information, which characterizes how objects allocated in one region of the program can escape to be accessed by another region. The algorithm is designed to analyze arbitrary regions of complete or incomplete programs, obtaining complete information for objects that do not escape the analyzed regions.We have developed an implementation that uses the escape information to eliminate synchronization for objects that are accessed by only one thread and to allocate objects on the stack instead of in the heap. Our experimental results are encouraging. We were able to analyze programs tens of thousands of lines long. For our benchmark programs, our algorithms enable the elimination of between 24% and 67% of the synchronization operations. They also enable the stack allocation of between 22% and 95% of the objects.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Language types, Software notations and tools, Verification, Software verification, Computing standards, RFCs and guidelines, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Document types, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
An efficient meta-lock for implementing ubiquitous synchronization
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Programs written in concurrent object-oriented languages, especially ones that employ thread-safe reusable class libraries, can execute synchronization operations (lock, notify, etc.) at an amazing rate. Unless implemented with utmost care, synchronization can become a performance bottleneck. Furthermore, in languages where every object may have its own monitor, per-object space overhead must be minimized. To address these concerns, we have developed a meta-lock to mediate access to synchronization data. The meta-lock is fast (lock + unlock executes in 11 SPARC&trade; architecture instructions), compact (uses only two bits of space), robust under contention (no busy-waiting), and flexible (supports a variety of higher-level synchronization operations). We have validated the meta-lock with an implementation of the synchronization operations in a high-performance product-quality Java&trade; virtual machine and report performance data for several large programs.
[Cross-computing tools and techniques, Evaluation, Language features, Object oriented languages, Language types, Software notations and tools, Contextual software domains, Metrics, Multithreading, Operating systems, Process synchronization, General programming languages, Data types and structures, General and reference, Software organization and properties, Software and its engineering, Process management]
A study of locking objects with bimodal fields
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Object locking can be efficiently implemented by bimodal use of a field reserved in an object. The field is used as a lightweight lock in one mode, while it holds a reference to a heavyweight lock in the other mode. A bimodal locking algorithm recently proposed for Java achieves the highest performance in the absence of contention, and is still fast enough when contention occurs.However, mode transitions inherent in bimodal locking have not yet been fully considered. The algorithm requires busy-wait in the transition from the light mode (inflation), and does not make the reverse transition (deflation) at all.We propose a new algorithm that allows both inflation without busy-wait and deflation, but still maintains an almost maximum level of performance in the absence of contention. We also present statistics on the synchronization behavior of real multithreaded Java programs, which indicate that busy-wait in inflation and absence of deflation can be problematic in terms of robustness and performance. Actually, an implementation of our algorithm shows increased robustness, and achieves performance improvements of up to 13.1% in server-oriented benchmarks.
[Middleware for databases, Distributed transaction monitors, Language features, Language types, Software notations and tools, Contextual software domains, Information systems, Operating systems, General programming languages, Data types and structures, Data management systems, Monitors, Software organization and properties, Software and its engineering, Process management]
Efficient multiple and predicated dispatching
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
The speed of message dispatching is an important issue in the overall performance of object-oriented programs. We have developed an algorithm for constructing efficient dispatch functions that combines novel algorithms for efficient single dispatching, multiple dispatching, and predicate dispatching. Our algorithm first reduces methods written in the general predicate dispatching model (which generalizes single dispatching, multiple dispatching, predicate classes and classifiers, and pattern-matching) into ones written using a simpler multimethod dispatching model. Our algorithm then computes a strategy for implementing multiple dispatching in terms of sequences of single dispatches, representing the strategy as a <italic>lookup DAG</italic>. Finally, our algorithm computes an implementation strategy separately for each of the single dispatches, producing for each dispatch a <italic>dispatch tree</italic>, which is a binary decision tree blending class identity tests, class range tests, and table lookups. Our algorithm exploits any available static information (from type declarations or class analysis) to prune unreachable paths from the lookup DAG, and uses any available dynamic profile information to minimize the expected time to search the dispatch trees. We measure the effectiveness of our dispatching algorithms on a collection of large Cecil programs, compiled by the Vortex optimizing compiler, showing improvements of up to 30% over already heavily optimized baseline versions.
[General programming languages, Object oriented languages, Language types, Discrete mathematics, Software notations and tools, Graph theory, Mathematics of computing, Software and its engineering]
Space and time-efficient memory layout for multiple inheritance
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
<italic>Traditional implementations of multiple inheritance bring about not only an overhead in terms of run-time but also a significant increase in object space. For example, the number of compiler-generated fields in a certain object can be as large as quadratic in the number of its subobjects. The problem of efficient object layout is compounded by the need to support two different semantics of multiple inheritance:</italic> shared, <italic>in which a base class inherited along distinct paths occurs only once in the derived class, and</italic> repeated, <italic>in which this base has multiple distinct occurrences in the derived. In this theoretical and foundational paper, we introduce two new techniques to optimize memory layout for multiple inheritance. The main ideas behind these techniques are the inlining of virtual bases and bidirectional memory layout. Our techniques never increase time overhead, and usually even decrease it. We show that in some example hierarchies, more than ten-fold reduction in the space overhead can be achieved. We analyze the complexity of the algorithms to apply these techniques, and give theorems to estimate the efficacy of this application. For concreteness, techniques and examples are discussed in the context of C++.</italic>
[File systems management, Language features, Sorting and searching, Inheritance, Language types, Software notations and tools, Contextual software domains, Information systems, Theory of computation, Information storage systems, Operating systems, General programming languages, Storage management, Memory management, Data structures design and analysis, Design and analysis of algorithms, Software organization and properties, Software and its engineering]
Reducing transfer delay using Java class file splitting and prefetching
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
<italic>The proliferation of the Internet is fueling the development of mobile computing environments in which mobile code is executed on remote sites. In such environments, the end user must often wait while the mobile program is transferred from the server to the client where it executes. This downloading can create significant delays, hurting the interactive experience of users.</italic><italic>We propose Java class file splitting and class file prefetching optimizations in order to reduce transfer delay. Class file splitting moves the infrequently used part of a class file into a corresponding cold class file to reduce the number of bytes transferred. Java class file prefetching is used to overlap program transfer delays with program execution. Our splitting and prefetching compiler optimizations do not require any change to the Java Virtual Machine, and thus can be used with existing Java implementations. Class file splitting reduces the startup time for Java programs by 10% on average, and class file splitting used with prefetching reduces the overall transfer delay encountered during a mobile program's execution by 25% to 30% on average.</italic>
[Networks, Data compression, Computing / technology policy, Software notations and tools, Dependable and fault-tolerant systems and networks, Data layout, Wireless access networks, Network types, Privacy policies, Information systems, Theory of computation, Computer systems organization, Security and privacy, Data management systems, Mobile networks, Social and professional topics, Network performance evaluation, Software and its engineering, Human and societal aspects of security and privacy, Cross-computing tools and techniques, Language types, Data structures, General programming languages, Data structures design and analysis, Performance, General and reference, Design and analysis of algorithms]
Practical experience with an application extractor for Java
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Java programs are routinely transmitted over low-bandwidth network connections as compressed class file archives (i.e., zip files and jar files). Since archive size is directly proportional to download time, it is desirable for applications to be as small as possible. This paper is concerned with the use of program transformations such as removal of dead methods and fields, inlining of method calls, and simplification of the class hierarchy for reducing application size. Such "extraction" techniques are generally believed to be especially useful for applications that use class libraries, since typically only a small fraction of a library's functionality is used. By "pruning away" unused library functionality, application size can be reduced dramatically. We implemented a number of application extraction techniques in Jax, an application extractor for Java, and evaluate their effectiveness on a set of realistic benchmarks ranging from 27 to 2,332 classes (with archives ranging from 56,796 to 3,810,120 bytes). We report archive size reductions ranging from 13.4% to 90.2% (48.7% on average).
[Cross-computing tools and techniques, Evaluation, Language features, Data compression, Language types, Software notations and tools, Data structures, Data layout, Information systems, Theory of computation, Metrics, General programming languages, Data structures design and analysis, Data management systems, General and reference, Design and analysis of algorithms, Software and its engineering, Compilers]
A performance evaluation of the mobile agent paradigm
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
This paper presents a performance evaluation of the mobile agent paradigm in comparison to the client/server paradigm. This evaluation has been conducted on top of the Java environment, using respectively RMI, the Aglets mobile agents platform and a mobile agents prototype that we implemented. The measurements give the cost of the basic mechanisms involved in the implementation of a mobile agent platform, and a comparative evaluation of the two considered models (client/server and mobile agents) through two application scenarios. The results show that significant performance improvements can be obtained using mobile agents.
[Personal computers and PC applications, Networks, Dependable and fault-tolerant systems and networks, Software notations and tools, Wireless access networks, Client-server architectures, Network types, Information systems, Computer systems organization, Distributed architectures, Database web servers, Data management systems, Mobile networks, Network performance evaluation, Software organization and properties, Software and its engineering, Cross-computing tools and techniques, Middleware for databases, Language types, Computers in other domains, Application servers, Distributed systems organizing principles, Applied computing, Software system structures, General programming languages, Performance, General and reference, Architectures]
Implementing jalape&ntilde;o in Java
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Jalape&ntilde;o is a virtual machine for Java&trade; servers written in Java.A running Java program involves four layers of functionality: the user code, the virtual-machine, the operating system, and the hardware. By drawing the Java / non-Java boundary below the virtual machine rather than above it, Jalape&ntilde;o reduces the boundary-crossing overhead and opens up more opportunities for optimization.To get Jalape&ntilde;o started, a <italic>boot image</italic> of a working Jalape&ntilde;o virtual machine is concocted and written to a file. Later, this file can be loaded into memory and executed. Because the boot image consists entirely of Java objects, it can be concocted by a Java program that runs in <italic>any</italic> JVM. This program uses reflection to convert the boot image into Jalape&ntilde;o's object format.A special MAGIC class allows unsafe casts and direct access to the hardware. Methods of this class are recognized by Jalape&ntilde;o's three compilers, which ignore their bytecodes and emit special-purpose machine code. User code will not be allowed to call MAGIC methods so Java's integrity is preserved.A small non-Java program is used to start up a boot image and as an interface to the operating system.Java's programming features - object orientation, type safety, automatic memory management - greatly facilitated development of Jalape&ntilde;o. However, we also discovered some of the language's limitations.
[Middleware for databases, Object oriented languages, Language types, Software notations and tools, Client-server architectures, Contextual software domains, Application servers, Information systems, Computer systems organization, Distributed architectures, Operating systems, General programming languages, Database web servers, Data management systems, Software organization and properties, Software and its engineering, Architectures, Process management, Compilers]
Subject-oriented design: towards improved alignment of requirements, design, and code
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
None
[Software design techniques, Management of computing and information systems, Software creation and management, Object oriented languages, Language types, Professional topics, Software notations and tools, Theory of computation, Software implementation planning, Designing software, Software development process management, Semantics and reasoning, General programming languages, Software management, Social and professional topics, Logic, Software and its engineering]
Atlas: a case study in building a web-based learning environment using aspect-oriented programming
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
The Advanced Teaching and Learning Academic Server (Atlas) is a software system that supports web-based learning. Students can register for courses, and can navigate through personalized views of course material. Atlas has been built according to Sun Microsystem's Java&trade; Servlet specification using Xerox PARC's aspect-oriented programming support called Aspect&trade;. Since aspect-oriented programming is still in its infancy, little experience with employing this paradigm is currently available. In this paper, we start filling this gap by describing the aspects we used in Atlas and by discussing the effect of aspects on our object-oriented development practices. We describe some rules and policies that we employed to achieve our goals of maintainability and modifiability, and introduce a straightforward notation to express the design of aspects. Although we faced some obstacles along the way, this combination of technology helped us build a fast, well-structured system in a reasonable amount of time.
[Management of computing and information systems, E-learning, Software creation and management, Distance learning, Human-centered computing, Web applications, Professional topics, World Wide Web, Human computer interaction (HCI), Software development techniques, Information systems, Applied computing, Web-based interaction, Web services, Software management, Education, Social and professional topics, Interaction paradigms, Software and its engineering]
Role model designs and implementations with aspect-oriented programming
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
This paper describes research in applications of aspect-oriented programming (AOP) as captured in the AspectJ&trade; language. In particular, it compares object-oriented and aspect-oriented designs and implementations of role models.Sections 1, 2, and 3 provide background information on role models, object-oriented role model implementations, and aspect-oriented programming, respectively. New aspect-oriented designs for role models are explored in sections 4, 5, and 6.The base reference for this exploration is the Role Object pattern. Although useful for role models, this pattern introduces some problems at the implementation level, namely object schizophrenia, significant interface maintenance, and no support for role composition. Our research has resulted in alternative aspect-oriented designs that alleviate some of these problems.Section 7 discusses how an agent framework that implements role models has been partially reengineered with aspects. The reengineering addressed concerns that are orthogonal or cross cut both the core and the role behavior. The aspect oriented redesign significantly reduced code tangling, overall method and module count, and total lines of code. These results and other conclusions are presented in section 8.
[Software creation and management, General programming languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Age-based garbage collection
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Modern generational garbage collectors look for garbage among the young objects, because they have high mortality; however, these objects include the very youngest objects, which clearly are still live. We introduce new garbage collection algorithms, called <italic>age-based</italic>, some of which postpone consideration of the youngest objects. Collecting less than the whole heap requires <italic>write barrier</italic> mechanisms to track pointers into the collected region. We describe here a new, efficient write barrier implementation that works for age-based and traditional generational collectors. To compare several collectors, their configurations, and program behavior, we use an accurate simulator that models all heap objects and the pointers among them, but does not model cache or other memory effects. For object-oriented languages, our results demonstrate that an <italic>older-first</italic> collector, which collects older objects before the youngest ones, copies on average much less data than generational collectors. Our results also show that an older-first collector does track more pointers, but the combined cost of copying and pointer tracking still favors an older-first over a generational collector in many cases. More importantly, we reopen for consideration the question where in the heap and with which policies copying collectors will achieve their best performance.
[Garbage collection, Cross-computing tools and techniques, Evaluation, Object oriented languages, Language types, Software notations and tools, Contextual software domains, Metrics, Operating systems, Memory management, General programming languages, General and reference, Software organization and properties, Software and its engineering]
Mostly-copying reachability-based orthogonal persistence
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
We describe how reachability-based orthogonal persistence can be supported even in uncooperative implementations of languages such as C++ and Modula-3, and without modification to the compiler. Our scheme extends Bartlett's mostly-copying garbage collector to manage both transient objects and resident persistent objects, and to compute the reachability closure necessary for stabilization of the persistent heap. It has been implemented in our prototype of reachability-based persistence for Modula-3, yielding performance competitive with that of comparable, but non-orthogonal, persistent variants of C++. Experimental results, using the 007 object database benchmarks, reveal that the mostly-copying approach offers a straightforward path to efficient orthogonal persistence in these uncooperative environments. The results also characterize the performance of persistence implementations based on virtual memory protection primitives.
[Garbage collection, Operating systems, General programming languages, Memory management, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
The generic graph component library
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
In this paper we present the Generic Graph Component Library (GGCL), a generic programming framework for graph data structures and graph algorithms. Following the theme of the Standard Template Library (STL), the graph algorithms in GGCL do not depend on the particular data structures upon which they operate, meaning a single algorithm can operate on arbitrary concrete representations of graphs. To attain this type of flexibility for graph data structures, which are more complicated than the containers in STL, we introduce several concepts to form the generic interface between the algorithms and the data structures, namely, Vertex, Edge, Visitor, and Decorator. We describe the principal abstractions comprising the GGCL, the algorithms and data structures that it provides, and provide examples that demonstrate the use of GGCL to implement some common graph algorithms. Performance results are presented which demonstrate that the use of novel lightweight implementation techniques and static polymorphism in GGCL results in code which is significantly more efficient than similar libraries written using the object-oriented paradigm.
[Software creation and management, General programming languages, Language features, Data types and structures, Discrete mathematics, Software notations and tools, Mathematics of computing, Development frameworks and environments, Software development techniques, Software libraries and repositories, Software and its engineering]
Zones, contracts and absorbing changes: an approach to software evolution
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
This paper describes a novel approach to managing the evolution of distributed, persistent systems at run-time. This is achieved by partitioning a system into disjoint <italic>zones</italic>, each of which can be evolved without affecting code in any other. <italic>Contracts</italic> are defined between zones, making type-level interdependencies and inter-zone communication explicit. Programmer supplied code is added to the running system, at the boundary between zones, to constrain the scope of changes. A change methodology is presented which the software engineer uses to help describe and manage the evolution of the system. Knowledge of the application semantics is essential when evolving a system and our approach allows the engineer to concentrate on these semantic aspects of change. Our Java-based demonstration platform and methodology reduce or remove some of the burdensome tasks the software engineer is normally expected to perform when changing a system, making evolution more tractable.
[Project and people management, Software creation and management, Language features, Professional topics, Software notations and tools, Information systems, Software configuration management and version control systems, Theory of computation, Theory and algorithms for application domains, Software development process management, Data types and structures, Data management systems, Social and professional topics, Database theory, Software and its engineering, Management of computing and information systems, Data structures, Record storage systems, Information storage systems, Data structures and algorithms for data management, Software management, General programming languages, Data structures design and analysis, Design and analysis of algorithms]
A distributed object-oriented framework for dependable multiparty interactions
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
In programming distributed object-oriented systems, there are several approaches for achieving binary interactions in a multiprocess environment. Usually these approaches take care only of synchronisation or communication. In this paper we describe a way of designing and implementing a more general concept: <italic>multiparty interactions</italic>. In a multiparty interaction, several parties (objects or processes) somehow "come together" to produce an intermediate and temporary combined state, use this state to execute some activity, and then leave this interaction and continue their normal execution. The concept of multiparty interactions has been investigated by several researchers, but to the best of our knowledge none have considered how failures in one or more participants of the multiparty interaction can be dealt with. In this paper, we propose a general scheme for constructing <italic>dependable multiparty interactions</italic> in a distributed object-oriented system, and describe its implementation in Java. In particular, we extend the notion of multiparty interaction to include facilities for handling exceptions. To show how our scheme can be used, we use our framework to build an abstraction mechanism that supports cooperative and competitive concurrency in distributed systems. This mechanism is then applied to program a system in which multiparty interactions are more than simple synchronisations or communications.
[Software defect analysis, Software creation and management, Language features, Object oriented languages, Software verification and validation, Computing methodologies, Language types, Software notations and tools, Control structures, Software testing and debugging, General programming languages, Frameworks, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Object views: language support for intelligent object caching in parallel and distributed computations
Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 34 ISSUE 10
1999
Object-based parallel and distributed applications are becoming increasingly popular, driven by the programmability advantages of component technology and a flat shared-object space. However, the flat shared-object space introduces a performance challenge: applications that rely on the transparent coherent caching of objects achieve high performance only on tightly coupled parallel machines. In distributed environments, the overheads of object caching force application designers to choose other solutions. Consequently, most applications sacrifice programmability, relying instead on either the explicit coherence management of cached objects, or on vastly different middleware abstractions such as multicast and events.In this paper, we describe object views - language support for efficient object caching in parallel and distributed computations. Object views specify restrictions on <italic>how</italic> computation threads can use an object, providing the underlying implementation with information about the potential side effects of object access, and thereby enabling construction of scalable, low-overhead caching protocols customized to application requirements. We present extensions to the Java programming language for expressing object views, and describe the design and implementation of a translator and run-time system for executing view-augmented Java programs on a distributed cluster of workstations. Experimental results based on a shared whiteboard application demonstrate that view-based object caching can achieve performance superior to multicast- and event-based implementations, while retaining essentially a shared object interface.
[Collaborative and social computing, General programming languages, Object oriented languages, Computing methodologies, Language types, Human-centered computing, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Improving the Java memory model using CRF
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
This paper describes alternative memory semantics for Java programs using an enriched version of the Commit/Reconcile/Fence (CRF) memory model [16]. It outlines a set of reasonable practices for safe multithreaded programming in Java. Our semantics allow a number of optimizations such as load reordering that are currently prohibited. Simple thread-local algebraic rules express the effects of optimizations at the source or bytecode level. The rules focus on reordering source-level operations; they yield a simple dependency analysis algorithm for Java. An instruction-by-instruction translation of Java memory operations into CRF operations captures thread interactions precisely. The fine-grained synchronization of CRF means the algebraic rules are easily derived from the translation. CRF can be mapped directly to a modern architecture, and is thus a suitable target for optimizing memory coherence during code generation.
[Language types, Software notations and tools, Formal languages and automata theory, Parallel architectures, Computing standards, RFCs and guidelines, Theory of computation, Computer systems organization, General programming languages, Document types, Formal language definitions, Multiple instruction, multiple data, General and reference, Software and its engineering, Architectures]
Exclusion for composite objects
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Designing concurrent object-oriented programs is hard. Correct programs must coordinate multiple threads accessing composite objects, using low-level mechanisms such as locks and read-write sets. Efficient programs must balance the complexity and overhead of the coordination mechanisms against the increased performance possible through concurrency. A method-level algebra of exclusion provides a succinct description of the conditions under which a thread must be excluded from a component of a composite object. Using the algebra, programmers can check whether their programs meet their exclusion requirements, can eliminate redundant exclusion controls, and can remove synchronisation overhead by reducing concurrency.
[Object oriented languages, Computing methodologies, Language types, Human-centered computing, Software notations and tools, Human computer interaction (HCI), Theory of computation, Models of computation, General programming languages, Concurrency, Concurrent programming languages, Interaction paradigms, Concurrent computing methodologies, Software and its engineering, Graphical user interfaces, Parallel computing models]
Adaptive optimization in the Jalape&ntilde;o JVM
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Future high-performance virtual machines will improve performance through sophisticated online feedback-directed optimizations. this paper presents the architecture of the Jalape&amp;ntilde;o Adaptive Optimization System, a system to support leading-edge virtual machine technology and enable ongoing research on online feedback-directed optimizations. We describe the extensible system architecture, based on a federation of threads with asynchronous communication. We present an implementation of the general architecture that supports adaptive multi-level optimization based purely on statistical sampling. We empirically demonstrate that this profiling technique has low overhead and can improve startup and steady-state performance, even without the presence of online feedback-directed optimizations. The paper also describes and evaluates an online feedback-directed inlining optimization based on statistical edge sampling. The system is written completely in Java, applying the described techniques not only to application code and standard libraries, but also to the virtual machine itself.
[Cross-computing tools and techniques, Evaluation, Metrics, General programming languages, Language types, Software notations and tools, General and reference, Software and its engineering, Compilers]
Quicksilver: a quasi-static compiler for Java
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
This paper presents the design and implementation of the Quicksilver1 quasi-static compiler for Java. Quasi-static compilation is a new approach that combines the benefits of static and dynamic compilation, while maintaining compliance with the Java standard, including support of its dynamic features. A quasi-static compiler relies on the generation and reuse of persistent code images to reduce the overhead of compilation during program execution, and to provide identical, testable and reliable binaries over different program executions. At runtime, the quasi-static compiler adapts pre-compiled binaries to the current JVM instance, and uses dynamic compilation of the code when necessary to support dynamic Java features. Our system allows interprocedural program optimizations to be performed while maintaining binary compatibility. Experimental data obtained using a preliminary implementation of a quasi-static compiler in the Jalape&amp;ntilde;o JVM clearly demonstrates the benefits of our approach: we achieve a runtime compilation cost comparable to that of baseline (fast, non-optimizing) compilation, and deliver the runtime program performance of the highest optimization level supported by the Jalape&amp;ntilde;o optimizing compiler. For the SPECjvm98 benchmark suite, we obtain a factor of 104 to 158 reduction in the runtime compilation overhead relative to the Jalape&amp;ntilde;o optimizing compiler. Relative to the better of the baseline and the optimizing Jalape&amp;ntilde;o compilers, the overall performance (taking into account both runtime compilation and execution costs) is increased by 9.2% to 91.4% for the SPECjvm98 benchmarks with size 100, and by 54% to 356% for the (shorter running) SPECjvm98 benchmarks with size 10.
[Software notations and tools, Software and its engineering, Compilers]
Sealed calls in Java packages
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Determining the potential targets of virtual method invocations is essential for inter-procedural optimizations of object-oriented programs. It is generally hard to determine such targets accurately. The problem is especially difficult for dynamic languages such as Java, because additional targets of virtual calls may appear at runtime. Current mechanisms that enable inter-procedural optimizations for dynamic languages, repeatedly validate the optimizations at runtime. This paper addresses this predicament by proposing a novel technique for conservative devirtualization analysis, which applies to a significant number of virtual calls in Java programs. Unlike previous work, our technique requires neither whole program analysis nor runtime information, and incurs no runtime overhead. Our solution is very efficient to compute and is based on a newly introduced, seemingly unrelated security feature of Java file archives. On average, our analysis "seals" (safely devirtualizes) about 39% of the virtual calls (to non-final methods) that appear in SPECjvm98 programs, and about 29% of the calls invoked while executing these programs. In the runtime library rt.jar, about 10% of the packages contain a significant percentage (20--60%) of sealed calls, with a total average of about 8.5%. Most of these calls are also shown to be monomorphic, a fact which can be safely exploited by aggressive inter-procedural optimizations such as direct inlining. These results indicate that our technique has a strong potential for enhancing the analysis and optimization of Java programs.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Runtime environments, Software and its engineering, Compilers]
A real world object modeling method for creating simulation environment of real-time systems
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Most real-time embedded control software feature complex interactions with asynchronous inputs and environment objects, and a meaningful simulation of a real-time control software specification requires realistic simulation of its environment. Two problems that need to be addressed in the simulation of a target software system and its environment: First, integration and simulation of the specifications of a target software system and its artificial environment are often performed too late in the lifecycle to provide any significant value. Second, real world objects in the environment usually have spatial characteristics (form) such as shape, motion, etc. that must be specified for simulation, and there is no method to express these spatial characteristics at various levels of abstraction that are adequate for the required simulation fidelity.To address these problems, we have developed a method that supports incremental specification and simulation of both the target software system and its environmental objects. The method includes: (1) a specification method for behavior, function, and form integrated objects; (2) form specification primitives that abstract common spatial characteristics of real world objects, their typical spatial relations, and spatial interactions; and (3) a methodology that refines, verifies, and validates behavior, function, and form specification of both the real-time embedded control software and its environment in a systematic and incremental manner. The proposed specification, verification, and validation method has been applied to a robot control system example to demonstrate its effectiveness and usefulness.
[Control methods, Embedded and cyber-physical systems, Computing methodologies, Embedded software, Computer systems organization, Software system structures, Embedded systems, Modeling and simulation, Computational control theory, Real-time systems, Model development and analysis, Artificial intelligence, Model verification and validation, Software organization and properties, Software and its engineering, Simulation evaluation, Real-time systems software]
Formal specification of CORBA services: experience and lessons learned
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
CORBA is now established as one of the main contenders in object-oriented middleware. Beyond the definition of this standard for distributed object systems, the Object Management Group (OMG) has specified several object services (Common Object Services, COS) that should foster the interoperability of distributed applications. Based on experiment, the goal of this paper is to show that the OMG's style of specification of the CORBA services is not suited to guarantee that implementers will produce interoperable and substitutable implementations. To illustrate our point, we give an account of an experiment based upon the formal specification of one COS, namely the CORBA Event Service. This formal specification highlights several ambiguities and under-specifications in the OMG document. We then test several commercial and public domain implementations of the CORBA Event Service, in order to assess how the implementers have dealt with these under-specifications. We show that the choices made by the implementers lead to incompatible implementations. We finally suggest a solution to overcome the problem of specification of object services, which satisfies the views of both implementers and users. Specifically, we suggest that the specification of such services be made using a formal description technique, and that implementers be provided with test cases derived from the formal specification.
[Software creation and management, Object oriented languages, Petri nets, Language types, Software notations and tools, Software system structures, Software system models, Designing software, Requirements analysis, General programming languages, Software organization and properties, Software and its engineering]
Middleware object query processing with deferred updates and autonomous sources
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
This paper presents a query processing algorithm called DECAF for use in middleware object query systems that are based on the use of an object cache. The DECAF algorithm is designed to work correctly even in the presence of updates to the underlying databases that don't go through the object cache (i.e., even for autonomous data sources that can be updated through legacy applications that do not perform their updates through the middleware object layer). DECAF's query results are consistent with updates performed by such transactions; its results are also consistent with any deferred updates that are present in the object cache but not yet committed at the database server. The DECAF algorithm attempts to push down query predicates to the underlying DBMSs to take advantage of the query processing capabilities of these systems and to reduce the amount of data transferred from these systems to the object cache.
[Object oriented languages, Language types, Software notations and tools, Information systems, Database management system engines, Theory of computation, Database query processing, Theory and algorithms for application domains, Database query processing and optimization (theory), General programming languages, Data management systems, Database theory, Software and its engineering, Compilers]
MultiJava: modular open classes and symmetric multiple dispatch for Java
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
We present MultiJava, a backward-compatible extension to Java supporting open classes and symmetric multiple dispatch. Open classes allow one to add to the set of methods that an existing class supports without creating distinct subclasses or editing existing code. Unlike the "Visitor" design pattern, open classes do not require advance planning, and open classes preserve the ability to add new subclasses modularly and safely. Multiple dispatch offers several well-known advantages over the single dispatching of conventional object-oriented languages, including a simple solution to some kinds of "binary method" problems. MultiJava's multiple dispatch retains Java's existing class-based encapsulation properties. We adapt previous theoretical work to allow compilation units to be statically typechecked modularly and safely, ruling out any link-time or run-time type errors. We also present a n compilation scheme that operates modularly and incurs performance overhead only where open classes or multiple dispatching are actually used.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Parametric polymorphism in Java: an approach to translation based on reflective features
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
The introduction of parametric polymorphism in Java with translation approaches has been shown to be of considerable interest, allowing the definition of extensions of Java on top of the existing Virtual Machines. Homogeneous translations furthermore, seem to be more useful than heterogeneous, avoiding the continuous increase of library code with redundant information. At this time however, homogeneous approaches aren't as flexible as heterogeneous, with extensions failing to integrate well with base language typing. In this paper, using some of the features of the Core Reflection of Java, we introduce a homogeneous translation in which run-time information about instantiation of type-parameters is carried, allowing full integration of parame-terized types with Java typing. Performance overhead is greatly decreased using a brand new translation technique based on the deferring of the management of type information at load-time. The same power and flexibility of previous heterogeneous approaches is obtained while maintaining homogeneous translation advantages.
[General programming languages, Language types, Software notations and tools, Software and its engineering]
Finding refactorings via change metrics
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Reverse engineering is the process of uncovering the design and the design rationale from a functioning software system. Reverse engineering is an integral part of any successful software system, because changing requirements lead to implementations that drift from their original design. In contrast to traditional reverse engineering techniques ---which analyse a single snapshot of a system--- we focus the reverse engineering effort by determining where the implementation has changed. Since changes of object-oriented software are often phrased in terms of refactorings, we propose a set of heuristics for detecting refactorings by applying lightweight, object-oriented metrics to successive versions of a software system. We validate our approach with three separate case studies of mature object-oriented software systems for which multiple versions are available. The case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system.
[Cross-computing tools and techniques, Software creation and management, Object oriented languages, Language types, Computing methodologies, Heuristic function construction, Software notations and tools, Software post-development issues, Search methodologies, Metrics, General programming languages, Software reverse engineering, General and reference, Artificial intelligence, Software and its engineering]
Mapping UML designs to Java
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Tools for the generation of code from model descriptions are valuable in helping developers maintain consistency between a model and its implementation. In this paper, we describe a new method for generating Java implementation code from UML diagrams. Our method accepts UML diagrams specified at a higher-level than current tools, and places fewer constraints on the supported UML constructs, like multiple generalizations and association classes. Unlike current tools, it generates implementation code that shields system implementers from the low-level details of how associations and other UML constructs are mapped to Java. Furthermore, it supports the modular design of systems according to concerns[2, 10] by being able to generate code from a set of related UML diagrams. While our discussion is focused on the special problem of generating Java implementation code, the issues discussed in this paper are applicable more generally to object-oriented implementation languages.
[Source code generation, General programming languages, Language types, Software notations and tools, Software and its engineering, Compilers]
PIROL: a case study for multidimensional separation of concerns in software engineering environments
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
In this paper, we present our experience with applying multidimensional separation of concerns to a software engineering environment. By comparing two different designs of our system, we show the importance of separating integration issues from the implementation of the individual concerns. We present a model in which integration issues are encapsulated into rst--class connector objects and indicate how this facilitates the understandability, maintenance and evolution of the system. We identify issues of binding time, binding granularity and binding cardinality as important criteria in selecting an appropriate model for separation of concerns. We finally show how a good choice following these criteria and considering the requirements of software engineering environments leads to a system with dynamic configurability, high--level component integration and support for multiple instantiable views.
[Software system structures, General programming languages, Language types, Software notations and tools, Development frameworks and environments, Software architectures, Software organization and properties, Software and its engineering]
Safely creating correct subclasses without seeing superclass code
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
A major problem for object-oriented frameworks and class libraries is how to provide enough information about a superclass, so programmers can safely create new subclasses without giving away the superclass's code. Code inherited from the superclass can call down to methods of the subclass, which may cause nontermination or unexpected behavior. We describe a reasoning technique that allows programmers, who have no access to the code of the superclass, to determine both how to safely override the superclass's methods and when it is safe to call them. The technique consists of a set of rules and some new forms of specification. Part of the specification would be generated automatically by a tool, a prototype of which is planned for the formal specification language JML. We give an example to show the kinds of problems caused by method overrides and how our technique can be used to avoid them. We also argue why the technique is sound and give guidelines for library providers and programmers that greatly simplify reasoning about how to avoid problems caused by method overrides.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Specification languages, System description languages, Software and its engineering]
OoLALA: an object oriented analysis and design of numerical linear algebra
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
In this paper we review the design of a sequential object oriented linear algebra library, O<sc>O</sc>L<sc>A</sc>L<sc>A</sc>. Several designs are proposed and used to classify existing sequential object oriented libraries. The classification is based on the way that matrices and matrix operations are represented. O<sc>O</sc>L<sc>A</sc>L<sc>A</sc>'s representation of matrices is capable of dealing with certain matrix operations that, although mathematically valid, are not handled correctly by existing libraries. O<sc>O</sc>L<sc>A</sc>L<sc>A</sc> also enables implementations of matrix calculations at various abstraction levels ranging from the relatively low-level abstraction of a Fortran BLAS-like implementation to higher-level abstractions that hide many implementation details. O<sc>O</sc>L<sc>A</sc>L<sc>A</sc> addresses a wide range of numerical linear algebra functionality while the reviewed object oriented libraries concen trate on parts of such functionality. We include some preliminary performance results for a Java implementation of O<sc>O</sc>L<sc>A</sc>L<sc>A</sc>.
[Object oriented languages, Language types, Computing methodologies, Symbolic and algebraic manipulation, Software notations and tools, Linear algebra algorithms, Numerical analysis, General programming languages, Mathematical analysis, Computations on matrices, Symbolic and algebraic algorithms, Mathematics of computing, Software libraries and repositories, Software and its engineering]
Towards agent-oriented assistance for framework instantiation
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
In this work we present a tool for assisting object-oriented framework instantiation based on Intelligent Agent technology. Differently from other approaches, the user is able to select the functionality needed for the new application, and based on this selection an agent elaborates a sequence of programming activities that should be carried out in order to implement it. In addition, the agent guides the execution of the activities according to the framework design. To enable this behavior, the framework need to be documented following the SmartBooks method, which extends traditional framework documentation with instantiation rules. In this paper we present an example of an instantiation environment built based on these ideas and the main characteristics of the SmartBooks method for documenting frameworks through instantiation knowledge rules.
[Software creation and management, Reusability, Language features, Professional topics, Software notations and tools, Software implementation planning, Software development process management, Frameworks, Social and professional topics, Software and its engineering, Software design techniques, Management of computing and information systems, Object oriented languages, Distributed artificial intelligence, Documentation, Computing methodologies, Language types, Software post-development issues, Software development techniques, Designing software, Software management, General programming languages, Artificial intelligence, Software libraries and repositories]
Practical virtual method call resolution for Java
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
This paper addresses the problem of resolving virtual method and interface calls in Java bytecode. The main focus is on a new practical technique that can be used to analyze large applications. Our fundamental design goal was to develop a technique that can be solved with only one iteration, and thus scales linearly with the size of the program, while at the same time providing more accurate results than two popular existing linear techniques, class hierarchy analysis and rapid type analysis.We present two variations of our new technique, variable-type analysis and a coarser-grain version called declared-type analysis. Both of these analyses are inexpensive, easy to implement, and our experimental results show that they scale linearly in the size of the program.We have implemented our new analyses using the Soot frame-work, and we report on empirical results for seven benchmarks. We have used our techniques to build accurate call graphs for complete applications (including libraries) and we show that compared to a conservative call graph built using class hierarchy analysis, our new variable-type analysis can remove a significant number of nodes (methods) and call edges. Further, our results show that we can improve upon the compression obtained using rapid type analysis.We also provide dynamic measurements of monomorphic call sites, focusing on the benchmark code excluding libraries. We demonstrate that when considering only the benchmark code, both rapid type analysis and our new declared-type analysis do not add much precision over class hierarchy analysis. However, our finer-grained variable-type analysis does resolve significantly more call sites, particularly for programs with more complex uses of objects.
[General programming languages, Language features, Frameworks, Language types, Discrete mathematics, Software notations and tools, Mathematics of computing, Software and its engineering]
Scalable propagation-based call graph construction algorithms
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Propagation-based call graph construction algorithms have been studied intensively in the 199Os, and differ primarily in the number of sets that are used to approximate run-time values of expressions. In practice, algorithms such as RTA that use a single set for the whole program scale well. The scalability of algorithms such as 0-CFA that use one set per expression remains doubtful.In this paper, we investigate the design space between RTA and 0-CFA. We have implemented various novel algorithms in the context of Jax, an application extractor for Java, and shown that they all scale to a 325,000-line program. A key property of these algorithms is that they do not analyze values on the run-time stack, which makes them efficient and easy to implement. Surprisingly, for detecting unreachable methods, the inexpensive RTA algorithm does almost as well as the seemingly more powerful algorithms. However, for determining call sites with a single target, one of our new algorithms obtains the current best tradeoff between speed and precision.
[Cross-computing tools and techniques, Evaluation, Metrics, Discrete mathematics, Software notations and tools, Mathematics of computing, General and reference, Software and its engineering, Compilers]
A study of devirtualization techniques for a Java Just-In-Time compiler
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
Many devirtualization techniques have been proposed to reduce the runtime overhead of dynamic method calls for various object-oriented languages, however, most of them are less effective or cannot be applied for Java in a straightforward manner. This is partly because Java is a statically-typed language and thus transforming a dynamic call to a static one does not make a tangible performance gain (owing to the low overhead of accessing the method table) unless it is inlined, and partly because the dynamic class loading feature of Java prohibits the whole program analysis and optimizations from being applied.We propose a new technique called direct devirtualization with the code patching mechanism. For a given dynamic call site, our compiler first determines whether the call can be devirtualized, by analyzing the current class hierarchy. When the call is devirtualizable and the target method is suitably sized, the compiler generates the inlined code of the method, together with the backup code of making the dynamic call. Only the inlined code is actually executed until our assumption about the devirtualization becomes invalidated, at which time the compiler performs code patching to make the backup code executed subsequently. Since the new technique prevents some code motions across the merge point between the inlined code and the backup code, we have furthermore implemented recently-known analysis techniques, such as type analysis and preexistence analysis, which allow the backup code to be completely eliminated. We made various experiments using 16 real programs to understand the effectiveness and characteristics of the devirtualization techniques in our Java Just-In-Time (JIT) compiler. In summary, we reduced the number of dynamic calls by ranging from 8.9% to 97.3% (the average of 40.2%), and we improved the execution performance by ranging from -1% to 133% (with the geometric mean of 16%).
[General programming languages, Language types, Software notations and tools, Software and its engineering, Compilers]
An efficient class and object encoding
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
An object encoding translates a language with object primitives to one without. Similarly, a class encoding translates classes into other primitives. Both are important theoretically for comparing the expressive power of languages and for transferring results from traditional languages to those with objects and classes. Both are also important foundations for the implementation of object-oriented languages as compilers typically include a phase that performs these translations.This paper describes a language with a primitive notion of classes and objects and presents an encoding of this language into one with records and functions. The encoding uses two techniques often used in compilers for single-inheritance class-based object-oriented languages: the self-application semantics and the method-table technique. To type the output of the encoding, the encoding uses a new formulation of self quantifiers that is more powerful than previous approaches.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Program semantics, Language types, Software notations and tools, Formal language definitions, Formal languages and automata theory, Software and its engineering, Compilers]
A formal specification of Java class loading
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
The Java Virtual Machine (JVM) has a novel and powerful mechanism to support lazy, dynamic class loading according to user-definable policies. Class loading directly impacts type safety, on which the security of Java applications is based. Conceptual bugs in the loading mechanism were found in earlier versions of the JVM that lead to type violations. A deeper understanding of the class loading mechanism, through such means as formal analysis, will improve our confidence that no additional bugs are present.The work presented in this paper provides a formal specification of (the relevant aspects of) class loading in the JVM and proves its type safety. Our approach to proving type safety is different from the usual ones since classes are dynamically loaded and full type information may not be statically available. In addition, we propose an improvement in the interaction between class loading and bytecode verification, which is cleaner and enables lazier loading.
[Theory of computation, Semantics and reasoning, General programming languages, Program semantics, Language types, Software notations and tools, Formal language definitions, Formal languages and automata theory, Software and its engineering, Compilers]
An Aristotelian understanding of object-oriented programming
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
The folklore of the object-oriented programming community at times maintains that object-oriented programming has drawn inspiration from philosophy, specifically that of Aristotle. We investigate this relation, first of all, in the hope of attaining a better understanding of object-oriented programming and, secondly, to explain aspects of Aristotelian logic to the computer science research community (since it differs from first order predicate calculus in a number of important ways). In both respects we endeavour to contribute to the theory of objects, albeit in a more philosophical than mathematical fashion.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Application isolation in the Java Virtual Machine
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
To date, systems offering multitasking for the Java&amp;trade; programming language either use one process or one class loader for each application. Both approaches are unsatisfactory. Using operating system processes is expensive, scales poorly and does not fully exploit the protection features inherent in a safe language. Class loaders replicate application code, obscure the type system, and non-uniformly treat 'trusted' and 'untrusted' classes, which leads to subtle, but nevertheless, potentially harmful forms of undesirable inter-application interaction.In this paper we propose a novel, simple yet powerful solution. The new model improves on existing designs in terms of resource utilization while offering strong isolation among applications. The approach is applicable both on high-end servers and on small devices. The main idea is to maintain only one copy of every class, regardless of how many applications use it. Classes are transparently and automatically modified, so that each application has a separate copy of its static fields. Two prototypes are described and selected performance data is analyzed. Various aspects of the proposed architectural changes to the Java Virtual Machine are discussed.
[Multiprocessing / multiprogramming / multitasking, Operating systems, General programming languages, Language types, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Process management, Compilers]
An approach to safe object sharing
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
It is essential for security to be able to isolate mistrusting programs from one another, and to protect the host platform from programs. Isolation is difficult in object-oriented systems because objects can easily become aliased. Aliases that cross program boundaries can allow programs to exchange information without using a system provided interface that could control information exchange. In Java, mistrusting programs are placed in distinct loader spaces but uncontrolled sharing of system classes can still lead to aliases between programs. This paper presents the object spaces protection model for an object-oriented system. The model decomposes an application into a set of spaces, and each object is assigned to one space. All method calls between objects in different spaces are mediated by a security policy. An implementation of the model in Java is presented.
[Access control, Language types, Computing methodologies, Software notations and tools, Systems security, Operating systems security, Modeling and simulation, Security and privacy, General programming languages, Security services, Model development and analysis, Model verification and validation, Software and its engineering]
Guava: a dialect of Java without data races
Proceedings of the 15th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 35 ISSUE 10
2000
We introduce Guava, a dialect of Java whose rules statically guarantee that parallel threads access shared data only through synchronized methods. Our dialect distinguishes three categories of classes: (1) monitors, which may be referenced from multiple threads, but whose methods are accessed serially; (2) values, which cannot be referenced and therefore are never shared; and (3) objects, which can have multiple references but only from within one thread, and therefore do not need to be synchronized. Guava circumvents the problems associated with today's Java memory model, which must define behavior when concurrent threads access shared memory without synchronization.We present an overview of the syntax and the semantic rules of Guava. We discuss how implementations of Guava can exploit these rules to re-enable compiler optimizations inhibited by standard Java. We discuss how compilers for certain multiprocessor architectures can automatically generate certain programming idioms, such as double-check reads, as optimizations of serialized monitors.
[Networks, Routers, Language types, Intermediate nodes, Software notations and tools, Concurrency control, Contextual software domains, Theory of computation, Models of computation, Network components, Operating systems, General programming languages, Concurrency, Software organization and properties, Software and its engineering, Parallel computing models, Process management]
Contract Soundness for object-oriented languages
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Checking pre- and post-conditions of procedures and methods at runtime helps improve software reliability. In the procedural world, pre- and post-conditions have a straightforward interpretation. If a procedure's pre-condition doesn't hold, the caller failed to establish the proper context. If a post-condition doesn't hold, the caller failed to establish the proper context. If a post-condition doesn't hold, the procedure failed to compute the expected result. In the object-oriented world, checking pre- and post-conditions for methods, often called contracts in this context, poses complex problems. Because methods may be overridden, it is not sufficient to check only pre- and post-conditions. In addition, the contract hierarchy must be checked to ensure that the contracts on overridden methods are properly related to the contracts on overriding methods. Otherwise, a class hierarchy may violate the substitution principle, that is, it may no longer be true that an instance of a class is substitutable for objects of the super-class. In this paper, we study the problem of contract enforcement in an object-oriented world from a foundational perspective. More specifically, we study contracts as refinements of types. Pushing the analogy further, we state and prove a contract soundness theorem that captures the essential properties of contract enforcement. We use the theorem to illustrate how most existing tools suffer from a fundamental flaw and how they can be improved.
[Object oriented languages, Language features, Computing methodologies, Language types, Nonmonotonic, default reasoning and belief revision, Software notations and tools, Knowledge representation and reasoning, Probabilistic reasoning, Program constructs, Computability, Theory of computation, Models of computation, Semantics and reasoning, General programming languages, Vagueness and fuzzy logic, Logic, Artificial intelligence, Software and its engineering]
The Java syntactic extender (JSE)
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The ability to extend a language with new syntactic forms is a powerful tool. A sufficiently flexible macro system allows programmers to build from a common base towards a language designed specifically for their problem domain. However, macro facilities that are integrated, capable, and at the same time simple enough to be widely used have been limited to the Lisp family of languages to date. In this paper we introduce a macro facility, called the Java Syntactic Extender (JSE), with the superior power and ease of use of Lisp macro sytems, but for Java, a language with a more conventional algebraic syntax. The design is based on the Dylan macro system, but exploits Java's compilation model to offer a full procedural macro engine. In other words, syntax expanders may be implemented in, and so use all the facilities of, the full Java language
[General programming languages, Language types, Functional languages, Software notations and tools, Formal language definitions, Syntax, Software and its engineering]
Points-to analysis for Java using annotated constraints
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The goal of point-to analysis for Java is to determine the set of objects pointed by a reference variable or a reference object field. This information has a wide variety of client applications in optimizing compilers and software engineering tools. In this paper we present a point-to analysis for Java based on Andersen's point-to analysis for C [5]. We implement the analysis by using a constraint-based approach which employs annotated inclusion constraints. Constraint annotations allow us model precisely and efficiently the semantics of virtual calls and the flow of values through object fields. By solving systems of annotated inclusion constraints, we have been albe to perform practical and precies points-to analysis for Java
[General programming languages, Language types, Functional languages, Software notations and tools, Software and its engineering, Compilers]
A parameterized type system for race-free Java programs
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
This paper presents a new static type system for multithreaded programs; any well-typed program in our system is free of data races. Our type system is significantly more expressive than previous such type systems. In particular, our system lets programmers write generic code to implement a class, then create different objects of the same class that have different objects of the same class that have different protection mechanisms. This flexibility enables programmers to reduce the number of unnecessary synchronizationoperations in a program without risking data races. We also support default types which reduce the burden of writing extra type annotations. Our experience indicates that our system provides a promising approach to make multithreaded programs more reliable and efficient
[Theory of computation, Semantics and reasoning, General programming languages, Language types, Functional languages, Software notations and tools, Program constructs, Type structures, Software and its engineering]
Object race detection
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
We present an on-the-fly mechanism that detects access conflicts in executions of multi-threaded Java programs. Access conflicts are a conservative approximation of data races. The checker tracks access information at the level of objects (object races) rather than at the level of individual variables. This viewpoint allows the checker to exploit specific properties of object-oriented programs for optimization by restricting dynamic checks to those objects that are identified by escape analysis as potentially shared. The checker has been implemented in collaboration with an "ahead-of-time"Java compiler. The combination fo static program analysis (escape-analysis) and inline instrumentation during code generation allows us to reduce the runtime overhead of detecting access conflicts. This overhead amounts to about 16-129% in time and less than 25% in space for typical benchmark applications and compares favorably to previously published on-the-fly mechanism that incurred an overhead of about a factor of 2-80 in time and up to a factor of 2 in space.
[General programming languages, Object oriented languages, Language types, Functional languages, Software notations and tools, Software and its engineering]
A study of exception handling and its dynamic optimization in Java
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Optimizing exception handling is critical for programs that frequently throw exceptions. We observed that there are many such exception-intensive programs iin various categories of Java programs. There are two commonly used exception handling techniques, stack unwinding optimizes the normal path, while stack cutting optimizes the exception handling path. However, there has been no single exception handling technique to optimize both paths.
[General programming languages, Language types, Functional languages, Software notations and tools, Runtime environments, Incremental compilers, Software and its engineering, Compilers]
Efficient subtyping tests with PQ-encoding
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Subtyping test, i.e., determining whether one type is a subtype of another, are a frequent operation during the execution of object-oriented programs. The challenge is in encoding the hierarchy in a small space, while simulataneously making sure that subtyping tests have efficient implmentation. We present a new scheme for encoding multiple and single inheritance hierarchies, which, in the standardized hierarchies, reduces the footprint of all previsously published schemes. The scheme is called PQ-encoding after PQ-trees, a data structure previously used in graph theory for finding the orderings that satisfy a collection of constraints. In particular, we show that in the traditional object layout model, the extra memory requirement for single inheritance hierarchies is zero. In the PQ-encoding subtyping tests are constant time, and use only two comparisons. Other than PQ-trees, PQ-encoding uses several novel optimization techniques. These techniques are applicable also in improving the performance of otehr, previously published, encoding schemes.
[Trees, Object oriented languages, Language types, Software notations and tools, Record storage systems, Graph theory, Program constructs, Information systems, Theory of computation, Semantics and reasoning, Information storage systems, General programming languages, B-trees, Discrete mathematics, Mathematics of computing, Directory structures, Type structures, Software and its engineering]
Efficient implementation of Java interfaces: Invokeinterface considered harmless
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Single superclass inheritance enables simple and efficient table-driven virtual method dispathc. However, virtual method table dispatch does not handle multiple inheritance and interfaces. This complication has led to a widespread misimpression that interface method dispatch is inherently inefficient. This paper argues that with proper implementation techniques, Java interfaces need not be a source of significant performance degradation.
[General programming languages, Language features, Language types, Functional languages, Software notations and tools, Modules / packages, Software and its engineering]
Multitasking without comprimise: a virtual machine evolution
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The multitasking virtual machine (called from now on simply MVM) is a modification of the Java virtual machine. It enables safe, secure, and scalable multitasking. Safety is achieved by strict isolation of application from one another. Resource control augment security by preventing some denial-of-service attacks. Improved scalability results from an aggressive application of the main design principle of MVM: share as much of the runtime as possible among applications and replicate everything else. The system can be described as a 'no compromise'approach --- all the known APIs and mechanisms of the Java programming language are available to applications. MVM is implemented as a series of carefully tuned modifications to the Java HotSpot virtual machine, including the dynamic compiler. this paper presents the design of MVM, focusing on several novel and general techniques: an in-runtime design of lightweight isolation, an extension of a copying, generational garbage collector to provide best-effort management of a portion of the heap space, and a transparent and automated mechanism for safe execution of user-level native code. MVM demonstrates that multitasking in a safe language can be accomplished with a high degree of protection, without constraining the language, and and with competitive performance characteristics
[Garbage collection, Operating systems, General programming languages, Memory management, Language types, Functional languages, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
Portable resource control in Java
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Preventing abusive resource consumption is indispensable for all kinds of systems that execute untrusted mobile coee, such as mobile object sytems, extensible web servers, and web browsers. To implement the required defense mechanisms, some support for resource control must be available: accounting and limiting the usage of physical resources like CPU and memory, and of logical resources like threads. Java is the predominant implementation language for the kind of systems envisaged here, even though resource control is a missing feature on standard Java platforms. This paper describes the model and implementation mechanisms underlying the new resource-aware version of the J-SEAL2 mobile object kernel. Our fundamental objective is to achieve complete portability, and our approach is therefore based on Java bytecode transformations. Whereas resource control may be targeted towards the provision of quality of service or of usage-based billing, the focus of this paper is on security, and more specificlly on prevention of denial-of-service attacks orginating from hostile or poorly implemented mobile code.
[File systems management, Language types, Software notations and tools, Contextual software domains, Information systems, Information storage systems, Operating systems, General programming languages, Storage management, Memory management, Functional languages, Software organization and properties, Software and its engineering]
Incremental computation of complex object queries
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The need for incremental algorithms for evaluating database queries is well known, but constructing algorithms that work on object-oriented databases (OODBs) has been difficult. The reason is that OODB query languages involve complex data types including composite objects and nested collections. As a result, existing algorithms have limitations in that the kinds of database updates are restricted, the operations found in many query languages are not supported, or the algorithms are too complex to be described precisely. We present an incremental computation algorithm that can handle any kind of database updates, can accept any expressions in complex query languages such as OQL, and can be described precisely. By translating primitive values and records into collections, we can reduce all query expressions comprehension. This makes the problems with incremental computation less complicated and thus allows us to decribe of two parts: one is to maintain the consistency in each comprehension occurrence and the other is to update the value of an entire expression. The algorithm is so flexible that we can use strict updates, lazy updates, and their combinations. By comparing the performance of applications built with our mechanism and that of equivalent hand written update programs, we show that our incremental algorithm can be iplemented efficiently.
[Theory of computation, Database query processing, Theory and algorithms for application domains, Database query processing and optimization (theory), Data management systems, Database theory, Information systems, Database management system engines]
Partial method compilation using dynamic profile information
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The traditional tradeoff when performing dynamic compilation is that of fast compilation time versus fast code performance. Most dynamic compilation systems for Java perform selective compilation and/or optimization at a method granularity. This is the not the optimal granularity level. However, compiling at a sub-method granularity is thought to be too complicated to be practical. This paper describes a straightforward technique for performing compilation and optimizations at a finer, sub-method granularity. We utilize dynamic profile data to determine intra-method code regions that are rarely or never executed, and compile and optimize the code without those regions. If a branch that was predicted to be rare is actually taken at run time, we fall back to the interpreter or dynamically compile another version of the code. By avoiding compiling and optimizing code that is rarely executed, we are able to decrease compile time significantly, with little to no degradation in performance. Futhermore, ignoring rarely-executed code can open up more optimization opportunities on the common paths. We present two optimizations---partial dead code elimination and rare-path-sensitive pointer and escape analysis---that take advantage of rare path information. Using these optimizations, our technique is able to improve performance beyond the compile time improvements
[General programming languages, Language types, Functional languages, Software notations and tools, Software and its engineering, Compilers]
A dynamic optimization framework for a Java just-in-time compiler
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The high performance implementation of Java Virtual Machines (JVM) and just-in-time (JIT) compilers is directed toward adaptive compilation optimizations on the basis of online runtime profile information. This paper describes the design and implementation of a dynamic optimization framework in a production-level Java JIT compiler. Our approach is to employ a mixed mode interpreter and a three level optimizing compiler, supporting quick, full, and special optimization, each of which has a different set of tradeoffs between compilation overhead and execution speed. a lightweight sampling profiler operates continuously during the entire program's exectuion. When necessary, detailed information on runtime behavior is collected by dynmiacally generating instrumentation code which can be installed to and uninstalled from the specified recompilation target code. Value profiling with this instrumentation mechanism allows fully automatic code specialization to be performed on the basis of specific parameter values or global data at the highest optimization level. The experimental results show that our approach offers high performance and a low code expansion ratio in both program startup and steady state measurements in comparison to the compile-only approach, and that the code specialization can also contribute modest performance improvement
[General programming languages, Language types, Functional languages, Software notations and tools, Software and its engineering, Compilers]
Dynamic optimistic interprocedural analysis: a framework and an application
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
In this paper, we address the problem of dynamic optimistic interprocedural analysis. Our goal is to build on past work on static interprocedural analysis and dynamic optimization by combining their advantages. We present a framework for performing dynamic optimistic interprocedural analysis. the framework is designed to be used in the context of dynamic class loading and dynamic compilation, and includes mechanisms for event notification (on class loading and method compilation) and dependence tracking (to enable invalidation of optimistic assumptions). We illustrate the functionality of the framework by using it to be used in the context of dynamic class loading and dynamic compilation, and includes mechanisms for event notification (on class loading and method compilaton) and dependence tracking (to enable invalidation of optimistic assumptions). We illustrate the functionality of the framework by using it to implement a dynamic optimistic interprocedural type (DOIT) analysis algorithm. The DOIT algorithm uses a new global data structure called the Value Graph. The framework and DOIT analysis of the IBM Jalape&ntilde;o Java virtual machine. Our experimental results for the SPECjvm benchmarks and two larger programs show promising benefits due to dynamic optimistic analysis. Compared to pessimistic analysis, the reduction in number of methods and fields analyzed was in the 2.7x-4.6x and 1.6-2.4x ranges respectively. The average fraction of polymorphic virtual calls decreased from 39.5% to 24.4% due to optimistic analysis, with a best-case decrease from 47.0% to 8.1%. The average fraction of polymorphic interface calls decreased from 96.4% to 36.2% due to optimistic analysis, with a best-case decrease from 100.0% to 0.0%. These benefits were obtained with a low dynamic analysis overhead in the range of 570-930 bytecode bytes/millisecond (about 2.5x-5.4x faster than the Jalape&ntilde;o baseline compiler)
[General programming languages, Object oriented languages, Language types, Functional languages, Software notations and tools, Software and its engineering, Compilers]
Jiazzi: new-age components for old-fasioned Java
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
We present Jiazzi, a system that enables the construction of large-scale binary components in Java. Jiazzi components can be thought of as generalizations of Java packages with added support for external linking and separate compilation. Jiazzi components are practical becuase they are constructed out of standard Java source code. Jiazzi requires neither extensions to the Java language nor special conventions for writing Java source code that will go inside a component. Our components are expressive becuase Jiazzi supports cyclic component linking and mixins, which are used together in an open class pattern that enables the modular addition of new features to existing classes. This paper describes Jiazzi, how it enhances Java with components, its implementation, and how type checking works. An implementation of Jiazzi is available for download.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Language types, Functional languages, Software notations and tools, Program constructs, Software and its engineering]
Modular mixin-based inheritance for application frameworks
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Mixin modules are proposed as an extension of a class-based programming language. Mixin modules combine parallel extension of classes, including extension of the self types for those classes, with mixin-based inheritance. For soundness of sybtyping purposes, they require an explicit distinction between mixin-based objects and class-based objects. Applications of mixin modules are in statically type-safe monad-based aspect-oriented programming, and in modular mixin-based Internet programming.
[Language features, Software notations and tools, Modules / packages, Program constructs, Theory of computation, Semantics and reasoning, Semantics, General programming languages, Program semantics, Data types and structures, Formal language definitions, Software and its engineering]
Encapsulating objects with confined types
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Object-oriented languages provide little support for encapsulating objects. Reference semantics allows objects to escape their defining scope. The pervasive aliasing that ensues remains a major source of software defects. This paper introduces Kacheck/J a tool for inferring object encapulation properties in large Java programs. Our goal is to develop practical tools to assist software engineers, thus we focus on simple and scalable techniques. Kacheck/J is able to infer confinement for Java classes. A class and its sublasses are confined if all of their instances are encapsulated in their defining package. This simple property can be used to identify accidental leaks of sensitive objects. The analysis is scalable and efficient; Kacheck/J is able t infer confinement on a corpus of 46,000 classes (115 MB) in 6 minutes
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
On objects and events
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
This paper presents linguistic primitives for publish/subscribe programming using events and objects. We integrate our primitives into a strongly typed object-oriented language through four mechnisms: (1) serialization, (2) multiple subtyping, (3)closures, and (4) deferred code evaluation. We illustrate our primitives through Java, showing how we have overcome its respective lacks. A precompiler transforms statements based on our publish/subscribe primitives into calls to specifically generated typed adapters, which resemble the typed stubs and skeletons by the rmic precompiler for remote method invocations in Java
[Language features, Object oriented languages, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Distributed computing methodologies, Distributed systems organizing principles, Software system structures, Organizing principles for web applications, Distributed programming languages, General programming languages, Software organization and properties, Software and its engineering]
Visitor combination and traversal control
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The Visitor design pattern allows the encapsulation of polymorphic behavior outside the class hierarchy on which it operates. A common application of Visitor is the encapsulation of tree traversals. A clean separation can be made between the generic parts of the combinator set and the parts that are specific to a particular class hierarchy. The generic parts form a reusable framework. The generic parts form a reusable framework. The specific parts can be generated from a (tree) grammar. Due to this separation, programming with visitor combinators becomes a form of generic programming with significant reuse of (visitor) code.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language types, Software notations and tools, Program constructs, Object oriented constructs, Software and its engineering]
Object-oriented composition untangled
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Object-oriented languages come with pre-defined composition mechansims, such as inheritance, object composition, or delegation, each characterized by a certain set of composition properties, which do not themselves individually exist as abstractions at the language level. However, often non-standard composition semantics is needed, with a mixture of composition mechanisms. Such non-standard semantics are simulated by complicated architectures that are sensitive to requirement changes and cannot easily be adapted without invalidating existing clients. In this paper, we propose compound references, a new abstraction for object references, that allows us to provide explicit linguistic means for expressing and combining individual composition properties on-demand. The model is statically typed and allows the programmer to express a seamless spectrum of composition semantics in the interval between object composition and inheritance. The resulting programs are better understandable, due to explicity expressed design decisions, and less sensitive to requirement changes.
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Program constructs, Software and its engineering]
A categorization of classes based on the visualization of their internal structure: the class blueprint
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
The reengineering and reverse engineering of software systems is gaining importance in software industry, because the accelerated turnover in software industry, because the accelerated turnover in software companies creates legacy systems in a shorter period of time. Especially understanding classes is a key activity in object-oriented programming, since classes represent the primary abstractions from which applications are built. The main problem of this task is to quickly grasp the purpose of a class and its inner structure. To help the reverse engineers in their first contact with a foreign system, we propose a categorization of classes based on the visualization of their internal structure. The contributions of this paper are a novel categorization of classes and a visualization of the which we call the class blueprint. We have validated the categorization on several case studies, two of which we present here.
[Visual languages, Software creation and management, Object oriented languages, Language types, Context specific languages, Software notations and tools, Software post-development issues, Theory of computation, Semantics and reasoning, General programming languages, Software reverse engineering, Logic, Software and its engineering]
Regression test selection for Java software
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Regression testing is applied to modified software to provide confidence that the changed parts behave as intended and that the unchanged parts have not been adversely affected by the modifications. To reduce the cost of regression testing, test cases are selected from the test suite that was used to test the original version of the software---this process is called regression test selection. A safe regression-test-selection algorithm selects every test case in the test suite that may reveal a fault in the modified software. Safe regression-test-selection technique that, based on the use of a suitable representation, handles the features of the Java language. Unlike other safe regression test selection techniques, the presented technique also handles incomplete programs. The technique can thus be safely applied in the (very common) case of Java software that uses external libraries of components; the analysis of the external code is note required for the technique to select test cases for such software. The paper also describes RETEST, a regression-test-selection algorithm can be effective in reducing the size of the test suite.
[Software defect analysis, Software creation and management, Software testing and debugging, General programming languages, Software verification and validation, Language types, Functional languages, Software notations and tools, Software post-development issues, Software reverse engineering, Software and its engineering]
The architecture of a UML virtual machine
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Current software development tools let developers model a software system and generate program code from the models to run the system. However, generating code and installing a non-trivial system induces a time delay between changing the model and executing it that makes rapid model prototyping awkard if not impossible. This paper presents the architecture of a virtual machine for UML that interprets UML models without any intermediate code-generation step. The paper shows how to embed UML in a metalevel architecture so that a key property of model-based systems, the casual connection between models and model instances, is guaranteed. With this architecture, changes to a model have immediate effects on its execution, providing users with rapid feedback about the model's structure and behavior. This approach supports model innovation better than today's code-generation approaches.
[Software prototyping, Software creation and management, Classes and objects, Object oriented languages, Language features, Language types, Software notations and tools, Object oriented frameworks, Software post-development issues, Development frameworks and environments, Software development techniques, Software evolution, General programming languages, Object oriented development, Frameworks, Software and its engineering, Compilers]
Pretenuring for Java
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Pretenuring can reduce copying costs in garbage collectors by allocating long-lived objects into regions that the garbage collector with rarely, if ever, collect. We extend previous work on pretenuring as follows. (1) We produce pretenuring advice that is neutral with respect to the garbage collector algorithm and configuration. We thus can and do combine advice from different applications. We find that predictions using object lifetimes at each allocation site in Java prgroams are accurate, which simplifies the pretenuring implementation. (2) We gather and apply advice to applications and the Jalape&ntilde;o JVM, a compiler and run-time system for Java written in Java. Our results demonstrate that building combined advice into Jalape&ntilde;o from different application executions improves performance regardless of the application Jalape&ntilde;o is compiling and executing. This build-time advice thus gives user applications some benefits of pretenuring without any application profiling. No previous work pretenures in the run-time system. (3) We find that application-only advice also improves performance, but that the combination of build-time and application-specific advice is almost always noticeably better. (4) Our same advice improves the performance of generational and Older First colleciton, illustrating that it is collector neutral.
[Garbage collection, Operating systems, General programming languages, Memory management, Language types, Functional languages, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
Controlling garbage collection and heap growth to reduce the execution time of Java applications
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
In systems that support garbage collection, a tension exists between collecting garbage too frequently and not collecting garbage frequently enough. Garbage collection that occurs too frequently may introduce unnecessary overheads at the rist of not collecting much garbage during each cycle. On the other hand, collecting garbage too infrequently can result in applications that execute with a large amount of virtual memory (i.e., with a large footprint) and suffer from increased execution times die to paging. In this paper, we use a large colleciton of Java applications and the highly tuned and widely used Boehm-Demers-Weiser (BDW) conservative mark-and-sweep garbage collector to experimentally examine the extent to which the frequency of garbage collectio impacts an application's execution time, footprint, and pause times. We use these results to devise some guidelines for controlling garbage and heap growth in a conservative garbage collection in order to minimize application execution times. Then we describe new strategies for controlling in order to minimize application execution times.
[Garbage collection, Operating systems, General programming languages, Memory management, Language types, Functional languages, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
An on-the-fly reference counting garbage collector for Java
Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 36 ISSUE 11
2001
Reference counting is not naturally suitable for running on multiprocessors. The update of pointers and reference counts requires atomic and synchronized operations. We present a novel reference counting algorithm suitable for a multiprocessor that does not require any synchronized operation in its write barrier (not even a compare-and-swap type of synchronization). The algorithm is efficient and may complete with any tracing algorithm.
[Garbage collection, Operating systems, General programming languages, Memory management, Language types, Functional languages, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering]
Creating and preserving locality of java applications at allocation and garbage collection times
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
The growing gap between processor and memory speeds is motivating the need for optimization strategies that improve data locality. A major challenge is to devise techniques suitable for pointer-intensive applications. This paper presents two techniques aimed at improving the memory behavior of pointer-intensive applications with dynamic memory allocation, such as those written in Java. First, we present an allocation time object placement technique based on the recently introduced notion of prolific (frequently instantiated) types. We attempt to co-locate, at allocation time, objects of prolific types that are connected via object references. Then, we present a novel locality based graph traversal technique. The benefits of this technique, when applied to garbage collection (GC), are twofold: (i) it improves the performance of GC due to better locality during a heap traversal and (ii) it restructures surviving objects in a way that enhances locality. On multiprocessors, this technique can further reduce overhead due to synchronization and false sharing. The experimental results, on a well-known suite of Java benchmarks (SPECjvm98 [26], SPECjbb2000 [27], and jOlden [4]), from an implementation of these techniques in the Jikes RVM [1], are very encouraging. The object co-allocation technique improves application performance by up to 21% (10% on average) in the Jikes RVM configured with a non-copying mark-and-sweep collector. The locality-based traversal technique reduces GC times by up to 20% (10% on average) and improves the performance of applications by up to 14% (6% on average) in the Jikes RVM configured with a copying semi-space collector. Both techniques combined can improve application performance by up to 22% (10% on average) in the Jikes RVM configured with a non-copying mark-and-sweep collector.
[Garbage collection, Dynamic compilers, Operating systems, Memory management, Allocation / deallocation strategies, Software notations and tools, Runtime environments, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
BuddyCache: high-performance object storage for collaborative strong-consistency applications in a WAN
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Collaborative applications provide a shared work environment for groups of networked clients collaborating on a common task. They require strong consistency for shared persistent data and efficient access to fine-grained objects. These properties are difficult to provide in wide area networks because of high network latency.BuddyCache is a new transactional caching approach that improves the latency of access to shared persistent objects for collaborative strong-consistency applications in high-latency network environments. The challenge is to improve performance while providing the correctness and availability properties of a transactional caching protocol in the presence of node failures and slow peers.We have implemented a BuddyCache prototype and evaluated its performance. Analytical results, confirmed by measurements of the BuddyCache prototype using the multi-user 007 benchmark indicate that for typical Internet latencies, e.g. ranging from 40 to 80 milliseconds round trip time to the storage server, peers using BuddyCache can reduce by up to 50% the latency of access to shared objects compared to accessing the remote servers directly.
[Computer systems organization, Software system structures, Distributed architectures, Software organization and properties, Software and its engineering, Architectures, Distributed systems organizing principles]
Workflow enactment with continuation and future objects
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
An increasing number of software developers are turning to workflow to separate the logic and the control aspects in their applications, thus making them more amenable to change. However, in spite of recent efforts to standardize and provide reusable workflow components, many developers build their own. This is a challenging endeavor and involves solving problems which seem incompatible with the object paradigm and current object-oriented programming languages. In the context of an object-oriented workflow framework, this paper demonstrates a novel approach that resolves this impedance mismatch with techniques drawn from programming language theory. This successful cross-pollination narrows the gap between the results of decades of research in programming languages and developers working hard to cope with change.
[Classes and objects, General programming languages, Object oriented languages, Language features, Frameworks, Language types, Software notations and tools, Software and its engineering]
Integrating independent components with on-demand remodularization
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
This paper proposes language concepts that facilitate the separation of an application into independent reusable building blocks and the integration of pre-build generic software components into applications that have been developed by third party vendors. A key element of our approach are on-demand remodularizations, meaning that the abstractions and vocabulary of an existing code base are translated into the vocabulary understood by a set of components that are connected by a common collaboration interface. This general concept allows us to mix-and-match remodularizations and components on demand.
[Software creation and management, Reusability, General programming languages, Language features, Software notations and tools, Modules / packages, Software development techniques, Software libraries and repositories, Software and its engineering]
Portable serialization of CORBA objects: a reflective approach
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
The objective of this work is to define, implement and illustrate a portable serialization technique for CORBA objects. We propose an approach based on reflection: through open compilers facilities the internal state of CORBA objects is obtained and transformed into a language independent format using CORBA mechanisms. This state can be restored and used by objects developed using different languages and running on different software platforms. A tool was developed and applied to a Chat application as a case study. The proposed technique is used to exchange state information between a C++ and a Java incarnation of this CORBA service. An observer tool enables the object state to be displayed and analyzed by the user. The applicability of this technique to various domains is discussed. Beyond the interest of language reflection, we finally advocate that operating system and middleware reflection would also be powerful concepts to extend the work presented in this paper.
[Distributed retrieval, Classes and objects, Object oriented languages, Language features, Storage architectures, Language types, Software notations and tools, Information retrieval, Record storage systems, Program constructs, Distributed storage, Object oriented constructs, Information systems, Theory of computation, Search engine architectures and scalability, Semantics and reasoning, Information storage systems, General programming languages, Peer-to-peer retrieval, Software and its engineering]
Multiple instances and symbolic variables in executable sequence charts
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
We extend live sequence charts (LSCs), a highly expressive variant of sequence diagrams, and provide the extension with an executable semantics. The extension involves support for instances that can bind to multiple objects and symbolic variables that can bind to arbitrary values. The result is a powerful executable language for expressing behavioral requirements on the level of inter-object interaction. The extension is implemented in full in our play-engine tool, with which one can execute the requirements directly without the need to build or synthesize an intra-object system model. It seems that in addition to many advantages in testing and requirements engineering, for some kinds of systems this could lead to the requirements actually serving as the final implementation.
[Designing software, Requirements analysis, Software creation and management, Software and its engineering]
A constraint-based architecture for local search
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Combinatorial optimization problems are ubiquitous in numerous practical applications. Yet most of them are challenging, both from computational complexity and programming standpoints. Local search is one of the main approaches to address these problems. However, it often requires sophisticated incremental algorithms and data structures, and considerable experimentation. This paper proposes a constraint-based, object-oriented, architecture to reduce the development time of local search algorithms significantly. The architecture consists of declarative and search components. The declarative component includes invariants, which maintain complex expressions incrementally, and differentiable objects, which maintain properties that can be queried to evaluate the effect of local moves. Differentiable objects are high-level modeling concepts, such as constraints and functions, that capture combinatorial substructures arising in many applications. The search component supports various abstractions to specify heuristics and meta-heuristics. We illustrate the architecture with the language <sc>Comet</sc> and several applications, such as car sequencing and the progressive party problem. The applications indicate that the architecture allows for very high-level modeling of local search algorithms, while preserving excellent performance.
[Software creation and management, Reusability, Object oriented languages, Language features, Language types, Software notations and tools, Software development techniques, Constraints, General programming languages, Frameworks, Software libraries and repositories, Software and its engineering, Compilers]
Online feedback-directed optimization of Java
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
This paper describes the implementation of an online feedback-directed optimization system. The system is fully automatic; it requires no prior (offline) profiling run. It uses a previously developed low-overhead instrumentation sampling framework to collect control flow graph edge profiles. This profile information is used to drive several traditional optimizations, as well as a novel algorithm for performing feedback-directed control flow graph node splitting. We empirically evaluate this system and demonstrate improvements in peak performance of up to 17% while keeping overhead low, with no individual execution being degraded by more than 2% because of instrumentation.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Lock reservation: Java locks can mostly do without atomic operations
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Because of the built-in support for multi-threaded programming, Java programs perform many lock operations. Although the overhead has been significantly reduced in the recent virtual machines, One or more atomic operations are required for acquiring and releasing an object's lock even in the fastest cases.This paper presents a novel algorithm called lock reservation. It exploits thread locality of Java locks, which claims that the locking sequence of a Java lock contains a very long repetition of a specific thread. The algorithm allows locks to be reserved for threads. When a thread attempts to acquire a lock, it can do without any atomic operation if the lock is reserved for the thread. Otherwise, it cancels the reservation and falls back to a conventional locking algorithm.We have evaluated an implementation of lock reservation in IBM's production virtual machine and compiler. The results show that it achieved performance improvements up to 53% in real Java programs.
[Software notations and tools, Software and its engineering, Compilers]
Fast algorithm for creating space efficient dispatching tables with application to multi-dispatching
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
The dispatching problem can be solved very efficiently in the single-inheritance~(SI) setting. In this paper we show how to extend one such solution to the multiple-inheritance~(MI) setting. This generalization comes with an increase to the space requirement by a small factor of &kappa; This factor can be thought of as a metric of the complexity of the topology of the inheritance hierarchy.On a data set of~35 hierarchies totaling some~64 thousand types, our dispatching data structure, based on a novel type slicing technique, exhibits very significant improvements over previous dispatching techniques, not only in terms of the time for creating the underlying data structure, but also in terms of total space used.The cost is in the dispatching time, which is no longer constant, but doubly logarithmic in the number of types. Conversely, by using a simple binary search, dispatching time is logarithmic in the number of different implementations. In practice dispatching uses one indirect branch and, on average, only~2.5 binary branches.Our results also have applications to the space-efficient implementation of the more general problem of dispatching multi-methods.A by-product of our type slicing technique is an incremental algorithm for constant-time subtyping tests with favorable memory requirements. (The incremental version of the subtyping problem is to maintain the subtyping data structure in presence of additions of types to the inheritance hierarchy.)
[]
Design pattern implementation in Java and aspectJ
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
AspectJ implementations of the GoF design patterns show modularity improvements in 17 of 23 cases. These improvements are manifested in terms of better code locality, reusability, composability, and (un)pluggability.The degree of improvement in implementation modularity varies, with the greatest improvement coming when the pattern solution structure involves crosscutting of some form, including one object playing multiple roles, many objects playing one role, or an object playing roles in multiple pattern instances.
[Classes and objects, Language features, Software notations and tools, Client-server architectures, Software architectures, System description languages, Distributed systems organizing principles, Software system structures, General programming languages, Patterns, Software organization and properties, Software and its engineering]
Implementing distribution and persistence aspects with aspectJ
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
This paper reports our experience using AspectJ, a general-purpose aspect-oriented extension to Java, to implement distribution and persistence aspects in a web-based information system. This system was originally implemented in Java and restructured with AspectJ. Our main contribution is to show that AspectJ is useful for implementing several persistence and distribution concerns in the application considered, and other similar applications. We have also identified a few drawbacks in the language and suggest some minor modifications that could significantly improve similar implementations. Despite the drawbacks, we argue that the AspectJ implementation is superior to the pure Java implementation. Some of the aspects implemented in our experiment are abstract and constitute a simple aspect framework. The other aspects are application specific but we suggest that different implementations might follow the same aspect pattern. The framework and the pattern allow us to propose architecture-specific guidelines that provide practical advice for both restructuring and implementing certain kinds of persistent and distributed applications with AspectJ.
[Software creation and management, General programming languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Write barrier removal by static analysis
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
We present a new analysis for removing unnecessary write barriers in programs that use generational garbage collection. To our knowledge, this is the first static program analysis for this purpose. Our algorithm uses a pointer analysis to locate assignments that always create a reference from a younger object to an older object, then transforms the program to remove the write barriers normally associated with such assignments. We have implemented two transformations that reorder object allocations; these transformations can significantly increase the effectiveness of our write barrier removal algorithm.Our base technique assumes that the collector promotes objects in age order. We have developed an extension that enables the optimistic removal of write barriers, with the collector lazily adding each newly promoted object into a remembered set of objects whenever the compiler may have removed write barriers involving the object at statements that have yet to execute. This mechanism enables the application of our technique to virtually any memory management system that uses write barriers to enable generational garbage collection.Results from our implemented system show that our technique can remove substantial numbers of write barriers from the majority of the programs in our benchmark set, producing modest performance improvements of up to 6% of the overall execution time. Moreover, by dynamically instrumenting the executable, we are able to show that for six of our nine benchmark programs, our analysis is close to optimal in the sense that it removes the write barriers for almost all assignments that do not, in the observed execution, create a reference from an older object to a younger object. Finally, our results show that the overhead of our optimistic extension is negligible.
[Garbage collection, Operating systems, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Ownership types for safe programming: preventing data races and deadlocks
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
This paper presents a new static type system for multithreaded programs; well-typed programs in our system are guaranteed to be free of data races and deadlocks. Our type system allows programmers to partition the locks into a fixed number of equivalence classes and specify a partial order among the equivalence classes. The type checker then statically verifies that whenever a thread holds more than one lock, the thread acquires the locks in the descending order.Our system also allows programmers to use recursive tree-based data structures to describe the partial order. For example, programmers can specify that nodes in a tree must be locked in the tree order. Our system allows mutations to the data structure that change the partial order at runtime. The type checker statically verifies that the mutations do not introduce cycles in the partial order, and that the changing of the partial order does not lead to deadlocks. We do not know of any other sound static system for preventing deadlocks that allows changes to the partial order at runtime.Our system uses a variant of ownership types to prevent data races and deadlocks. Ownership types provide a statically enforceable way of specifying object encapsulation. Ownership types are useful for preventing data races and deadlocks because the lock that protects an object can also protect its encapsulated objects. This paper describes how to use our type system to statically enforce object encapsulation as well as prevent data races and deadlocks. The paper also contains a detailed discussion of different ownership type systems and the encapsulation guarantees they provide.
[Cross-computing tools and techniques, Software creation and management, Language features, Software functional properties, Software verification and validation, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
An analyzable annotation language
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
The Alloy Annotation Language (AAL) is a language (under development) for annotating Java code based on the Alloy modeling language. It offers a syntax similar to the Java Modeling Language (JML), and the same opportunities for generation of run-time assertions. In addition, however, AAL offers the possibility of fully automatic compile-time analysis. Several kinds of analysis are supported, including: checking the code of a method against its specification; checking that the specification of a method in a subclass is compatible with the specification in the superclass; and checking properties relating method calls on different objects, such as that the equals methods of a class (and its overridings) induce an equivalence. Using partial models in place of code, it is also possible to analyze object-oriented designs in the abstract: investigating, for example, a view relationship amongst objects.The paper gives examples of annotations and such analyses. It presents (informally) a systematic translation of annotations into Alloy, a simple first-order logic with relational operators. By doing so, it makes Alloy's automatic analysis, which is based on state-of-the-art SAT solvers, applicable to the analysis of object-oriented programs, and demonstrates the power of a simple logic as the basis for an annotation language.
[Validation, Cross-computing tools and techniques, Software creation and management, Classes and objects, Object oriented languages, Software functional properties, Language features, Software verification and validation, Language types, Software notations and tools, Invariants, Theory of computation, Designing software, Requirements analysis, Semantics and reasoning, General programming languages, Program reasoning, Formal software verification, Formal methods, Reliability, General and reference, Software organization and properties, Software and its engineering]
Performance and scalability of EJB applications
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
We investigate the combined effect of application implementation method, container design, and efficiency of communication layers on the performance scalability of J2EE application servers by detailed measurement and profiling of an auction site server.We have implemented five versions of the auction site. The first version uses stateless session beans, making only minimal use of the services provided by the Enterprise JavaBeans (EJB) container. Two versions use entity beans, one with container-managed persistence and the other with bean-managed persistence. The fourth version applies the session fasade pattern, using session beans as a fasade to access entity beans. The last version uses EJB 2.0 local interfaces with the session fasade pattern. We evaluate these different implementations on two popular open-source EJB containers with orthogonal designs. JBoss uses dynamic proxies to generate the container classes at run time, making an extensive use of reflection. JOnAS pre-compiles classes during deployment, minimizing the use of reflection at run time. We also evaluate the communication optimizations provided by each of these EJB containers.The most important factor in determining performance is the application implementation method. EJB applications with session beans perform as well as a Java servlets-only implementation and an order-of-magnitude better than most of the implementations based on entity beans. The fine-granularity access exposed by the entity beans limits scalability. Use of session fasade beans improves performance for entity beans, but only if local communication is very efficient or EJB 2.0 local interfaces are used. Otherwise, session fasade beans degrade performance.For the implementation using session beans, communication cost forms the major component of the execution time on the EJB server. The design of the container has little effect on performance. With entity beans, the design of the container becomes important. In particular, the cost of reflection affects performance. For implementations using session fasade beans, local communication cost is critically important. EJB 2.0 local interfaces improve the performance by avoiding the communication layers for local communications.
[]
Incommunicado: efficient communication for isolates
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Executing computations in a single instance of safe language virtual machine can improve performance and overall platform scalability. It also poses various challenges. One of them is providing a fast inter-application communication mechanism. In addition to being efficient, such a mechanism should not violate any functional and non-functional properties of its environment, and should also support enforcement of application-specific security policies. This paper explores the design and implementation of a communication substrate for applications executing within a single Java virtual machine modified to enable safe and interference-free execution of isolated computations. Designing an efficient extension that does not break isolation properties and at the same time pragmatically offers an intuitive API has proven non-trivial. This paper demonstrates a set of techniques that lead to at least an eight-fold performance improvement over the in-process inter-application communication using standard mechanisms offered by the Java platform.
[]
Sifting out the mud: low level C++ code reuse
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
More and more computers are being incorporated in devices where the available amount of memory is limited. This contrasts with the increasing need for additional functionality and the need for rapid application development. While object-oriented programming languages, providing mechanisms such as inheritance and templates, allow fast development of complex applications, they have a detrimental effect on program size. This paper introduces new techniques to reuse the code of whole procedures at the binary level and a supporting technique for data reuse. These techniques benefit specifically from program properties originating from the use of templates and inheritance. Together with our previous work on code abstraction at lower levels of granularity, they achieve additional code size reductions of up to 38% on already highly optimized and compacted binaries, without sacrificing execution speed. We have incorporated these techniques in <sc>Squeeze++</sc>, a prototype link-time binary rewriter for the Alpha architecture, and extensively evaluate them on a suite of 8 real-life C++ applications. The total code size reductions achieved post link-time (i.e. without requiring any change to the compiler) range from 27 to 70%, averaging at around 43%.
[Source code generation, Data compression, Language types, Software notations and tools, Data structures, Data layout, Information systems, Theory of computation, General programming languages, Data structures design and analysis, Data management systems, Design and analysis of algorithms, Software and its engineering, Compilers]
Ownership, encapsulation and the disjointness of type and effect
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Ownership types provide a statically enforceable notion of object-level encapsulation. We extend ownership types with computational effects to support reasoning about object-oriented programs. The ensuing system provides both access control and effects reporting. Based on this type system, we codify two formal systems for reasoning about aliasing and the disjointness of computational effects. The first can be used to prove that evaluation of two expressions will never lead to aliases, while the latter can be used to show the non-interference of two expressions.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Alias annotations for program understanding
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
One of the primary challenges in building and evolving large object-oriented systems is understanding aliasing between objects. Unexpected aliasing can lead to broken invariants, mistaken assumptions, security holes, and surprising side effects, all of which may lead to software defects and complicate software evolution.This paper presents AliasJava, a capability-based alias annotation system for Java that makes alias patterns explicit in the source code, enabling developers to reason more effectively about the interactions in a complex system. We describe our implementation, prove the soundness of the annotation system, and give an algorithm for automatically inferring alias annotations. Our experience suggests that the annotation system is practical, that annotation inference is efficient and yields appropriate annotations, and that the annotations can express important invariants of data structures and of software architectures.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Towards a formalization for COM part i: the primitive calculus
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
We introduce in this paper a typed calculus intended to capture the execution model of COM. The innovation of this calculus is to model very low-level aspects of the COM framework, specifically the notion of interface pointers. This is handled by specifying an allocation semantics for the calculus, thereby modeling heap allocation of interfaces explicitly. Having an explicit way of talking about interface pointers allows us to model in a reasonable way the notions of interface sharing and object identity. We introduce a type system that can be used to disambiguate between specification and implementation of interfaces. The type system moreover can capture a notion of COM conformance, that is, the legality of COM components. We discuss extensions of the calculus to handle subtyping of interfaces, dynamic interface negotiation and aggregation.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Object oriented languages, Language types, Functional languages, Software notations and tools, Modules / packages, Program constructs, Software and its engineering]
GCspy: an adaptable heap visualisation framework
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
GCspy is an architectural framework for the collection, transmission, storage and replay of memory management behaviour. It makes new contributions to the understanding of the dynamic memory behaviour of programming languages (and especially object-oriented languages that make heavy demands on the performance of memory managers). GCspy's architecture allows easy incorporation into any memory management system: it is not limited to garbage-collected languages. It requires only small changes to the system in which it is incorporated but provides a simple to use yet powerful data-gathering API. GCspy scales to allow very large heaps to be visualised effectively and efficiently. It allows already-running, local or remote systems to be visualised and those systems to run at full speed outside the points at which data is gathered. GCspy's visualisation tool presents this information in a number of novel ways.Deep understanding of program behaviour is essential to the design of the next generation of garbage collectors and explicit allocators. Until now, no satisfactory tools have been available to assist the implementer in gaining an understanding of heap behaviour. GCspy has been demonstrated to be a practical solution to this dilemma. It has been used to analyse production Java virtual machines running applications of realistic sizes. Its use has revealed important insights into the interaction between application program and JVM and has led to the development of better garbage collectors.
[Garbage collection, Measurement, Cross-computing tools and techniques, Human-centered computing, Software notations and tools, Human computer interaction (HCI), Contextual software domains, Metrics, Operating systems, Memory management, General and reference, Software organization and properties, Software and its engineering]
Access rights analysis for Java
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Java 2 has a security architecture that protects systems from unauthorized access by mobile or statically configured code. The problem is in manually determining the set of security access rights required to execute a library or application. The commonly used strategy is to execute the code, note authorization failures, allocate additional access rights, and test again. This process iterates until the code successfully runs for the test cases in hand. Test cases usually do not cover all paths through the code, so failures can occur in deployed systems. Conversely, a broad set of access rights is allocated to the code to prevent authorization failures from occurring. However, this often leads to a violation of the "Principle of Least Privilege"This paper presents a technique for computing the access rights requirements by using a context sensitive, flow sensitive, interprocedural data flow analysis. By using this analysis, we compute at each program point the set of access rights required by the code. We model features such as multi-threading, implicitly defined security policies, the semantics of the Permission.implies method and generation of a security policy description. We implemented the algorithms and present the results of our analysis on a set of programs. While the analysis techniques described in this paper are in the context of Java code, the basic techniques are applicable to access rights analysis issues in non-Java-based systems.
[Software design techniques, Software defect analysis, Validation, Cross-computing tools and techniques, Software creation and management, Software development methods, Empirical software validation, Software functional properties, Software verification and validation, Software implementation planning, Traceability, Designing software, Software development process management, Software testing and debugging, Process validation, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering, Walkthroughs]
Language-specific make technology for the Java programming language
Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 37 ISSUE 11
2002
Keeping the code of a Java application consistent (code is consistent if all of the project classes can be recompiled together without errors) prevents late linking errors, and thus may significantly improve development turnaround time. In this paper we describe a make technology for the Java programming language, that is based on smart dependency checking, guarantees consistency of the project code, and at the same time reduces the number of source code recompilations to the minimum. After project code consistency is initially assured by complete recompilation, the information extracted from the binary classes is stored in a so-called project database. Whenever the source code for some class C is changed, its recompiled binary is compared to the old version of C preserved in the project database. As a result, we find a minimum subset of classes that depend on C and may be affected by the particular change made to it. These are recompiled in turn, and absence of compilation errors at this phase guarantees the consistency of the new project code. To determine which dependent classes to recompile, we categorize all source incompatible changes, and for each category establish a criterion for finding the smallest possible subset of dependent classes.
[Management of computing and information systems, Software creation and management, Software management, Professional topics, Software notations and tools, Social and professional topics, Incremental compilers, Software and its engineering, Compilers]
Language-independent aspect-oriented programming
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
The term aspect-oriented programming (AOP) has come to describe the set of programming mechanisms developed specifically to express crosscutting concerns. Since crosscutting concerns cannot be properly modularized within object-oriented programming, they are expressed as aspects and are composed, or woven, with traditionally encapsulated functionality referred to as components.Many AOP models exist, but their implementations are typically coupled with a single language. To allow weaving of existing components with aspects written in the language of choice, AOP requires a language-independent tool.
[Software creation and management, General programming languages, Multiparadigm languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Refactoring for generalization using type constraints
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Refactoring is the process of applying behavior-preserving transformations (called "refactorings") in order to improve a program's design. Associated with a refactoring is a set of preconditions that must be satisfied to guarantee that program behavior is preserved, and a set of source code modifications. An important category of refactorings is concerned with generalization (e.g., <sc>Extract Interface</sc> for re-routing the access to a class via a newly created interface, and <sc>Pull Up Members</sc> for moving members into a superclass). For these refactorings, both the preconditions and the set of allowable source code modifications depend on interprocedural relationships between types of variables. We present an approach in which type constraints are used to verify the preconditions and to determine the allowable source code modifications for a number of generalization-related refactorings. This work is implemented in the standard distribution of Eclipse (see www.eclipse.org).
[Theory of computation, Software creation and management, Semantics and reasoning, Program semantics, Software notations and tools, Software post-development issues, Program reasoning, Program analysis, Software reverse engineering, Development frameworks and environments, Software and its engineering]
Partial behavioral reflection: spatial and temporal selection of reification
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Behavioral reflection is a powerful approach for adapting the behavior of running applications. In this paper we present and motivate partial behavioral reflection, an approach to more efficient and flexible behavioral reflection. We expose the spatial and temporal dimensions of such reflection, and propose a model of partial behavioral reflection based on the notion of hooksets. In the context of Java, we describe a reflective architecture offering appropriate interfaces for static and dynamic configuration of partial behavioral reflection at various levels, as well as Reflex, an open reflective extension for Java implementing this architecture. Reflex is the first extension that fully supports partial behavioral reflection in a portable manner, and that seamlessly integrates load-time and runtime behavioral reflection. The paper shows preliminary benchmarks and examples supporting the approach. The examples, dealing with the observer pattern and asynchronous communication via transparent futures, also show the interest of partial behavioral reflection as a tool for open dynamic Aspect-Oriented Programming.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
OOPAL: integrating array programming in object-oriented programming
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Array programming shines in its ability to express computations at a high-level of abstraction, allowing one to manipulate and query whole sets of data at once. This paper presents the OPA model that enhances object-oriented programming with array programming features. The goal of OPA is to determine a minimum set of modifications that must be made to the traditional object model in order to take advantage of the possibilities of array programming. It is based on a minimal extension of method invocation and the definition of a kernel of methods implementing fundamental array programming operations. The OPA model presents a generalization of traditional message passing in the sense that a message can be send to an entire set of objects. The model is validated in FS, a new scripting language.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Automatic detection and repair of errors in data structures
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
We present a system that accepts a specification of key data structure consistency constraints, then dynamically detects and repairs violations of these constraints, enabling the program to continue to execute productively even in the face of otherwise crippling errors. Our experience using our system indicates that the specifications are relatively easy to develop once one understands the data structures. Furthermore, for our set of benchmark applications, our system can effectively repair inconsistent data structures and enable the program to continue to operate successfully.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Language features, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, General programming languages, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
A first-class approach to genericity
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
This paper describes how to add first-class generic types---including mixins---to strongly-typed OO languages with nominal subtyping such as Java and C#. A generic type system is "first-class" if generic types can appear in any context where conventional types can appear. In this context, a mixin is simply a generic class that extends one of its type parameters, e.g., a class C&lt;T&gt; that extends T. Although mixins of this form are widely used in Cpp (via templates), they are clumsy and error-prone because Cpp treats mixins as macros, forcing each mixin instantiation to be separately compiled and type-checked. The abstraction embodied in a mixin is never separately analyzed.Our formulation of mixins using first-class genericity accommodates sound local (class-by-class) type checking. A mixin can be fully type-checked given symbol tables for each of the classes that it directly references---the same context in which Java performs incremental class compilation. To our knowledge, no previous formal analysis of first-class genericity in languages with nominal type systems has been conducted, which is surprising because nominal subtyping has become predominant in mainstream object-oriented programming languages.What makes our treatment of first-class genericity particularly interesting and important is the fact that it can be added to the existing Java language without any change to the underlying Java Virtual Machine. Moreover, the extension is backward compatible with legacy Java source and class files. Although our discussion of a practical implementation strategy focuses on Java, the same implementation techniques could be applied to other object-oriented languages such as C# or Eiffel that support incremental compilation, dynamic class loading, and nominal subtyping.
[Theory of computation, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Formal language definitions, Formal languages and automata theory, Software and its engineering]
A comparative study of language support for generic programming
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Many modern programming languages support basic generic programming, sufficient to implement type-safe polymorphic containers. Some languages have moved beyond this basic support to a broader, more powerful interpretation of generic programming, and their extensions have proven valuable in practice. This paper reports on a comprehensive comparison of generics in six programming languages: C++, Standard ML, Haskell, Eiffel, Java (with its proposed generics extension), and Generic C. By implementing a substantial example in each of these languages, we identify eight language features that support this broader view of generic programming. We find these features are necessary to avoid awkward designs, poor maintainability, unnecessary run-time checks, and painfully verbose code. As languages increasingly support generics, it is important that language designers understand the features necessary to provide powerful generics and that their absence causes serious difficulties for programmers.
[Constraints, General programming languages, Language features, Multiparadigm languages, Language types, Software notations and tools, Abstract data types, Software libraries and repositories, Software and its engineering, Polymorphism]
Lightweight confinement for featherweight java
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Confinement properties impose a structure on object graphs which can be used to enforce encapsulation properties essential to certain program optimizations, modular reasoning, and software assurance. This paper formalizes the notion of confined type in the context of Featherweight Java. A static type system that mirrors the informal rules of Grothoff et al [17] is proven sound. The definition of confined types is extended to confined instantiation of generic classes. This allows for confined collection types in Java and for classes that can be confined post hoc. Confinement type rules are given for Generic Featherweight Java, and proven sound.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Dynamic metrics for java
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
In order to perform meaningful experiments in optimizing compilation and run-time system design, researchers usually rely on a suite of benchmark programs of interest to the optimization technique under consideration. Programs are described as numeric, memory-intensive, concurrent, or object-oriented, based on a qualitative appraisal, in some cases with little justification. We believe it is beneficial to quantify the behaviour of programs with a concise and precisely defined set of metrics, in order to make these intuitive notions of program behaviour more concrete and subject to experimental validation. We therefore define and measure a set of unambiguous, dynamic, robust and architecture-independent metrics that can be used to categorize programs according to their dynamic behaviour in five areas: size, data structure, memory use, concurrency, and polymorphism. A framework computing some of these metrics for Java programs is presented along with specific results demonstrating how to use metric data to understand a program's behaviour, and both guide and evaluate compiler optimizations.
[Cross-computing tools and techniques, Metrics, General programming languages, Language features, Software notations and tools, General and reference, Software and its engineering]
How java programs interact with virtual machines at the microarchitectural level
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Java workloads are becoming increasingly prominent on various platforms ranging from embedded systems, over general-purpose computers to high-end servers. Understanding the implications of all the aspects involved when running Java workloads, is thus extremely important during the design of a system that will run such workloads. In other words, understanding the interaction between the Java application, its input and the virtual machine it runs on, is key to a succesful design. The goal of this paper is to study this complex interaction at the microarchitectural level, e.g., by analyzing the branch behavior, the cache behavior, etc. This is done by measuring a large number of performance characteristics using performance counters on an AMD K7 Duron microprocessor. These performance characteristics are measured for seven virtual machine configurations, and a collection of Java benchmarks with corresponding inputs coming from the SPECjvm98 benchmark suite, the SPECjbb2000 benchmark suite, the Java Grande Forum benchmark suite and an open-source raytracer, called Raja with 19 scene descriptions. This large amount of data is further analyzed using statistical data analysis techniques, namely principal components analysis and cluster analysis. These techniques provide useful insights in an understandable way.From our experiments, we conclude that (i) the behavior observed at the microarchitectural level is primarily determined by the virtual machine for small input sets, e.g., the SPECjvm98 s1 input set; (ii) the behavior can be quite different for various input sets, e.g., short-running versus long-running benchmarks; (iii) for long-running benchmarks with few hot spots, the behavior can be primarily determined by the Java program and not the virtual machine, i.e., all the virtual machines optimize the hot spots to similarly behaving native code; (iv) in general, the behavior of a Java application running on one virtual machine can be significantly different from running on another virtual machine. These conclusions warn researchers working on Java workloads to be careful when using a limited number of Java benchmarks or virtual machines since this might lead to biased conclusions.
[Design, Measurement, Cross-computing tools and techniques, Metrics, Performance, General and reference]
Effectiveness of cross-platform optimizations for a java just-in-time compiler
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
This paper describes the system overview of our Java Just-In-Time (JIT) compiler, which is the basis for the latest production version of IBM Java JIT compiler that supports a diversity of processor architectures including both 32-bit and 64-bit modes, CISC, RISC, and VLIW architectures. In particular, we focus on the design and evaluation of the cross-platform optimizations that are common across different architectures. We studied the effectiveness of each optimization by selectively disabling it in our JIT compiler on three different platforms: IA-32, IA-64, and PowerPC. Our detailed measurements allowed us to rank the optimizations in terms of the greatest performance improvements with the smallest compilation times. The identified set includes method inlining only for tiny methods, exception check eliminations using forward dataflow analysis and partial redundancy elimination, scalar replacement for instance and class fields using dataflow analysis, optimizations for type inclusion checks, and the elimination of merge points in the control flow graphs. These optimizations can achieve 90% of the peak performance for two industry-standard benchmark programs on these platforms with only 34% of the compilation time compared to the case for using all of the optimizations.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
HydroJ: object-oriented pattern matching for evolvable distributed systems
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
In an evolving software system, components must be able to change independently while remaining compatible with their peers. One obstacle to independent evolution is the brittle parameter problem: the ability of two components to communicate can depend on a number of inessential details of the types, structure, and/or contents of the values communicated. If these details change, then the components can no longer communicate, even if the essential parts of the message remain unaffected.We present HydroJ, an extension of Java that addresses this problem. In HydroJ, components communicate using self-describing, semi-structured messages, and programmers use pattern matching to define the handling of messages. This design stems from two central ideas: first, that self-describing messages reduce dependence on inessential message format details; and second, that object-oriented pattern matching naturally focuses on the essential information in a message and is insensitive to inessential information.We have developed these ideas in the context of Rain, a distributed, heterogeneous messaging system for ubiquitous computing. To evaluate the design, we have constructed a prototype HydroJ compiler, implemented some Rain services in HydroJ, studied the evolution of an existing Rain service over time, and formalized HydroJ's key features in a core language.
[General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Extra-functional properties, Interoperability, Software organization and properties, Software and its engineering]
Relaxed MultiJava: balancing extensibility and modular typechecking
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
We present the rationale, design, and implementation of Relaxed MultiJava (RMJ), a backward-compatible extension of Java that allows programmers to add new methods to existing classes and to write multimethods. Previous languages supporting these forms of extensibility either restrict their usage to a limited set of programming idioms that can be modularly typechecked (and modularly compiled) or simply forego modular typechecking altogether. In contrast, RMJ supports the new language features in a virtually unrestricted form while still providing mostly-modular static typechecking and fully-modular compilation. In some cases, the RMJ compiler will warn that the potential for a type error exists, but it will still complete compilation. In those cases, a custom class loader transparently performs load-time checking to verify that the potential error is never realized. RMJ's compiler and custom loader cooperate to keep load-time checking costs low. We report on qualitative and quantitative experience with our implementation of RMJ.
[Classes and objects, General programming languages, Language features, Software notations and tools, Software and its engineering, Compilers]
MJ: a rational module system for Java and its applications
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
While Java provides many software engineering benefits, it lacks a coherent module system and instead provides only packages (which are primarily a name space mechanism) and classloaders (which are very low-level). As a result, large Java applications suffer from unexpected interactions between independent components, require complex CLASSPATH definitions, and are often extremely complex to install and maintain. We have implemented a module system for Java called MJ that is implemented with class loaders, but provides a much higher-level interface. High-level properties can be specified in a module definition and are enforced by the module system as new modules are loaded. To experimentally validate the ability of MJ to properly handle the complex module inter-relationships found in large Java server systems, we replaced the classloader mechanisms of Apache Tomcat 4.1.18 [27] with 30 MJ modules. The modified Tomcat is functionally identical to the original, but requires no CLASSPATH definitions, and will operate correctly even if user code loads a different version of a module used by Tomcat, such as the Xerces XML parser [31]. Furthermore, by making a small change to the Java core libraries enabled by MJ, we obtained a 30% performance improvement in a servlet microbenchmark.
[General programming languages, Language features, Language types, Software notations and tools, Modules / packages, Software and its engineering]
Mostly concurrent garbage collection revisited
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
The mostly concurrent garbage collection was presented in the seminal paper of Boehm et al. With the deployment of Java as a portable, secure and concurrent programming language, the mostly concurrent garbage collector turned out to be an excellent solution for Java's garbage collection task. The use of this collector is reported for several modern production Java Virtual Machines and it has been investigated further in academia.In this paper, we present a modification of the mostly concurrent collector, which improves the throughput, the memory footprint, and the cache behavior of the collector without foiling the other good qualities (such as short pauses and high scalability). We implemented our solution on the IBM production JVM and obtained a performance improvement of up to 26.7%, a reduction in the heap consumption by up to 13.4%, and no substantial change in the (short) pause times. The modified algorithm was subsequently incorporated into the IBM production JVM.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
An on-the-fly mark and sweep garbage collector based on sliding views
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
With concurrent and garbage collected languages like Java and C# becoming popular, the need for a suitable non-intrusive, efficient, and concurrent multiprocessor garbage collector has become acute. We propose a novel mark and sweep on-the-fly algorithm based on the sliding views mechanism of Levanoni and Petrank. We have implemented our collector on the Jikes Java Virtual Machine running on a Netfinity multiprocessor and compared it to the concurrent algorithm and to the stop-the-world collector supplied with Jikes JVM. The maximum pause time that we measured with our benchmarks over all runs was 2ms. In all runs, the pause times were smaller than those of the stop-the-world collector by two orders of magnitude and they were also always shorter than the pauses of the Jikes concurrent collector. Throughput measurements of the new garbage collector show that it outperforms the Jikes concurrent collector by up to 60%. As expected, the stop-the-world does better than the on-the-fly collectors with results showing about 10% difference.On top of being an effective mark and sweep on-the-fly collector standing on its own, our collector may also be used as a backup collector (collecting cyclic data structures) for the Levanoni-Petrank reference counting collector. These two algorithms perfectly fit sharing the same allocator, a similar data structure, and a similar JVM interface.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Heap compression for memory-constrained Java environments
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Java is becoming the main software platform for consumer and embedded devices such as mobile phones, PDAs, TV set-top boxes, and in-vehicle systems. Since many of these systems are memory constrained, it is extremely important to keep the memory footprint of Java applications under control.The goal of this work is to enable the execution of Java applications using a smaller heap footprint than that possible using current embedded JVMs. We propose a set of memory management strategies to reduce heap footprint of embedded Java applications that execute under severe memory constraints. Our first contribution is a new garbage collector, referred to as the Mark-Compact-Compress (MCC) collector, that allows an application to run with a heap smaller than its footprint. An important characteristic of this collector is that it compresses objects when heap compaction is not sufficient for creating space for the current allocation request. In addition to employing compression, we also consider a heap management strategy and associated garbage collector, called MCL (Mark-Compact-Lazy Allocate), based on lazy allocation of object portions. This new collector operates like the conventional Mark-Compact (MC) collector, but takes advantage of the observation that many Java applications create large objects, of which only a small portion is actually used. In addition, we also combine MCC and MCL, and present MCCL (Mark-Compact-Compress-Lazy Al-locate), which outperforms both MCC and MCL.We have implemented these collectors using KVM, and performed extensive experiments using a set of ten embedded Java applications. We have found our new garbage collection strategies to be useful in two main aspects. First, they reduce the minimum heap size necessary to execute an application without out-of-memory exception. Second, our strategies reduce the heap occupancy. That is, at a given time, they reduce the heap memory requirement of the application being executed. We have also conducted experiments with a more aggressive object compression strategy and discussed its main advantages.
[Dynamic compilers, Operating systems, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Declaring and checking non-null types in an object-oriented language
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Distinguishing non-null references from possibly-null references at the type level can detect null-related errors in object-oriented programs at compile-time. This paper gives a proposal for retrofitting a language such as C# or Java with non-null types. It addresses the central complications that arise in constructors, where declared non-null fields may not yet have been initialized, but the partially constructed object is already accessible. The paper reports experience with an implementation for annotating and checking null-related properties in C# programs.
[Cross-computing tools and techniques, Software creation and management, Language features, Software functional properties, Software verification and validation, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Program reasoning, Formal software verification, Logic, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Object equality profiling
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
We present Object Equality Profiling (OEP), a new technique for helping programmers discover optimization opportunities in programs. OEP discovers opportunities for replacing a set of equivalent object instances with a single representative object. Such a set represents an opportunity for automatically or manually applying optimizations such as hash consing, heap compression, lazy allocation, object caching, invariant hoisting, and more. To evaluate OEP, we implemented a tool to help programmers reduce the memory usage of Java programs. Our tool performs a dynamic analysis that records all the objects created during a particular program run. The tool partitions the objects into equivalence classes, and uses collected timing information to determine when elements of an equivalence class could have been safely collapsed into a single representative object without affecting the behavior of that program run. We report the results of applying this tool to benchmarks, including two widely used Web application servers. Many benchmarks exhibit significant amounts of object equivalence, and in most benchmarks our profiler identifies optimization opportunities clustered around a small number of allocation sites. We present a case study of using our profiler to find simple manual optimizations that reduce the average space used by live objects in two SpecJVM benchmarks by 47% and 38% respectively.
[Software performance, Professional topics, Software notations and tools, Extra-functional properties, Contextual software domains, Operating systems, Discrete mathematics, Mathematics of computing, Social and professional topics, Software organization and properties, Software and its engineering, Garbage collection, Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Object oriented languages, Language types, Graph theory, General programming languages, Software management, Memory management, Graph algorithms, Performance, General and reference, Compilers]
Mark-copy: fast copying GC with less space overhead
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Copying garbage collectors have a number of advantages over non-copying collectors, including cheap allocation and avoiding fragmentation. However, in order to provide completeness (the guarantee to reclaim each garbage object eventually), standard copying collectors require space equal to twice the size of the maximum live data for a program. We present a mark-copy collection algorithm (MC) that extends generational copying collection and significantly reduces the heap space required to run a program. MC reduces space overhead by 75--85% compared with standard copying garbage collectors, increasing the range of applications that can use copying garbage collection. We show that when MC is given the same amount of space as a generational copying collector, it improves total execution time of Java benchmarks significantly in tight heaps, and by 5--10% in moderate size heaps. We also compare the performance of MC with a (non-generational) mark-sweep collector and a hybrid copying/mark-sweep generational collector. We find that MC can run in heaps comparable in size to the minimum heap space required by mark-sweep. We also find that for most benchmarks MC is significantly faster than mark-sweep in small and moderate size heaps. When compared with the hybrid collector, MC improves total execution time by about 5% for some benchmarks, partly by increasing the speed of execution of the application code.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Ulterior reference counting: fast garbage collection without a long wait
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
General purpose garbage collectors have yet to combine short pause times with high throughput. For example, generational collectors can achieve high throughput. They have modest average pause times, but occasionally collect the whole heap and consequently incur long pauses. At the other extreme, concurrent collectors, including reference counting, attain short pause times but with significant performance penalties. This paper introduces a new hybrid collector that combines copying generational collection for the young objects and reference counting the old objects to achieve both goals. It restricts copying and reference counting to the object demographics for which they perform well. Key to our algorithm is a generalization of deferred reference counting we call Ulterior Reference Counting. Ulterior reference counting safely ignores mutations to select heap objects. We compare a generational reference counting hybrid with pure reference counting, pure mark-sweep, and hybrid generational mark-sweep collectors. This new collector combines excellent throughput, matching a high performance generational mark-sweep hybrid, with low maximum pause times.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Connectivity-based garbage collection
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
We introduce a new family of connectivity-based garbage collectors (<sc>Cbgc</sc>) that are based on potential object-connectivity properties. The key feature of these collectors is that the placement of objects into partitions is determined by performing one of several forms of connectivity analyses on the program. This enables partial garbage collections, as in generational collectors, but without the need for any write barrier.The contributions of this paper are 1) a novel family of garbage collection algorithms based on object connectivity; 2) a detailed description of an instance of this family; and 3) an empirical evaluation of <sc>Cbgc</sc> using simulations. Simulations help explore a broad range of possibilities for <sc>Cbgc</sc>, ranging from simplistic ones that determine connectivity based on type information to oracular ones that use run-time information to determine connectivity. Our experiments with the oracular <sc>Cbgc</sc> configurations give an indication of the potential for <sc>Cbgc</sc> and also identify weaknesses in the realistic configurations. We found that even the simplistic implementations beat state-of-the-art generational collectors with respect to some metrics (pause times and memory footprint).
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Saving the world from bad beans: deployment-time confinement checking
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
The Enterprise JavaBeans (EJB) framework requires developers to preserve architectural integrity constraints when writing EJB components. Breaking these constraints allows components to violate the transaction protocol, bypass security mechanisms, disable object persistence, and be susceptible to malicious attacks from other EJBs. We present an object confinement discipline that allows static verification of components' integrity as they are deployed into an EJB server. The confinement rules are simple for developers to understand, require no annotation to the code of EJB components, and can be efficiently enforced in existing EJB servers.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Object oriented languages, Language types, Software notations and tools, Verification, Software verification, Software architectures, Program verification, Theory of computation, Software development process management, Software system structures, Semantics and reasoning, General programming languages, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Language support for lightweight transactions
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Concurrent programming is notoriously difficult. Current abstractions are intricate and make it hard to design computer systems that are reliable and scalable. We argue that these problems can be addressed by moving to a declarative style of concurrency control in which programmers directly indicate the safety properties that they require. In our scheme the programmer demarks sections of code which execute within lightweight software-based transactions that commit atomically and exactly once. These transactions can update shared data, instantiate objects, invoke library features and so on. They can also block, waiting for arbitrary boolean conditions to become true. Transactions which do not access the same shared memory locations can commit concurrently. Furthermore, in general, no performance penalty is incurred for memory accesses outside transactions.We present a detailed design of this proposal along with an implementation and evaluation. We argue that the resulting system (i) is easier for mainstream programmers to use, (ii) prevents lock-based priority-inversion and deadlock problems and (iii) can offer performance advantages.
[Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Theory of computation, Models of computation, General programming languages, Concurrency, Software and its engineering, Parallel computing models]
Lazy modular upgrades in persistent object stores
Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 38 ISSUE 11
2003
Persistent object stores require a way to automatically upgrade persistent objects, to change their code and storage representation. Automatic upgrades are a challenge for such systems. Upgrades must be performed in a way that is efficient both in space and time, and that does not stop application access to the store. In addition, however, the approach must be modular: it must allow programmers to reason locally about the correctness of their upgrades similar to the way they would reason about regular code. This paper provides solutions to both problems.The paper first defines upgrade modularity conditions that any upgrade system must satisfy to support local reasoning about upgrades. The paper then describes a new approach for executing upgrades efficiently while satisfying the upgrade modularity conditions. The approach exploits object encapsulation properties in a novel way. The paper also describes a prototype implementation and shows that our upgrade system imposes only a small overhead on application performance.
[Software maintenance, Software creation and management, Language features, Software verification and validation, Professional topics, Software notations and tools, Software verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Social and professional topics, Formal methods, Software organization and properties, Software and its engineering, Management of computing and information systems, Cross-computing tools and techniques, Software functional properties, Software post-development issues, Verification, Program verification, Software management, General programming languages, Formal software verification, General and reference]
Converting Java classes to use generics
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Generics offer significant software engineering benefits since they provide code reuse without compromising type safety. Thus generics will be added to the Java language in the next release. While this extension to Java will help programmers when they are writing new code, it will not help legacy code unless it is rewritten to use generics. In our experience, manually modifying existing programs to use generics is complex and can be error prone and labor intensive. We describe a system, Ilwith, that (i) converts non-generic classes to generic classes and (ii) rewrites their clients to use the newly generified classes. Our experiments with a number of Java container classes show that our system is effective in modifying legacy code to use generics.
[Management of computing and information systems, Software maintenance, Software creation and management, Software management, Professional topics, Software post-development issues, Social and professional topics, Software and its engineering]
Converting java programs to use generic libraries
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Java 1.5 will include a type system (called JSR-14) that supports &#60;i>parametric polymorphism&#60;/i>, or &#60;i>generic&#60;/i> classes. This will bring many benefits to Java programmers, not least because current Java practice makes heavy use of logically-generic classes, including container classes. Translation of Java source code into semantically equivalent JSR-14 source code requires two steps: parameterization (adding type parameters to class definitions) and instantiation (adding the type arguments at each use of a parameterized class). Parameterization need be done only once for a class, whereas instantiation must be performed for each client, of which there are potentially many more. Therefore, this work focuses on the instantiation problem. We present a technique to determine sound and precise JSR-14 types at each use of a class for which a generic type specification is available. Our approach uses a precise and context-sensitive pointer analysis to determine possible types at allocation sites, and a set-constraint-based analysis (that incorporates guarded, or conditional, constraints) to choose consistent types for both allocation and declaration sites. The technique handles all features of the JSR-14 type system, notably the raw types that provide backward compatibility. We have implemented our analysis in a tool that automatically inserts type parameters into Java code, and we report its performance when applied to a number of real-world Java programs.
[General programming languages, Object oriented languages, Language features, Data types and structures, Language types, Software notations and tools, Modules / packages, Software and its engineering]
A practical type system and language for reference immutability
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
This paper describes a type system that is capable of expressing and enforcing immutability constraints. The specific constraint expressed is that the abstract state of the object to which an immutable reference refers cannot be modified using that reference. The abstract state is (part of) the transitively reachable state: that is, the state of the object and all state reachable from it by following references. The type system permits explicitly excluding fields or objects from the abstract state of an object. For a statically type-safe language, the type system guarantees reference immutability. If the language is extended with immutability downcasts, then run-time checks enforce the reference immutability constraints. In order to better understand the usability and efficacy of the type system, we have implemented an extension to Java, called Javari, that includes all the features of our type system. Javari is interoperable with Java and existing JVMs. It can be viewed as a proposal for the semantics of the Java const keyword, though Javari's syntax uses readonly instead. This paper describes the design and implementation of Javari, including the type-checking rules for the language. This paper also discusses experience with 160,000 lines of Javari code. Javari was easy to use and provided a number of benefits, including detecting errors in well-tested code.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Object oriented languages, Data types and structures, Language types, Software notations and tools, Program reasoning, Logic, Software and its engineering]
A unified theory of garbage collection
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Tracing and reference counting are uniformly viewed as being fundamentally different approaches to garbage collection that possess very distinct performance properties. We have implemented high-performance collectors of both types, and in the process observed that the more we optimized them, the more similarly they behaved - that they seem to share some deep structure.  We present a formulation of the two algorithms that shows that they are in fact duals of each other. Intuitively, the difference is that tracing operates on live objects, or "matter", while reference counting operates on dead objects, or "anti-matter". For every operation performed by the tracing collector, there is a precisely corresponding anti-operation performed by the reference counting collector. Using this framework, we show that all high-performance collectors (for example, deferred reference counting and generational collection) are in fact hybrids of tracing and reference counting. We develop a uniform cost-model for the collectors to quantify the trade-offs that result from choosing different hybridizations of tracing and reference counting. This allows the correct scheme to be selected based on system performance requirements and the expected properties of the target application.
[Garbage collection, Dynamic compilers, Operating systems, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
The garbage collection advantage: improving program locality
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
As improvements in processor speed continue to outpace improvements in cache and memory speed, poor locality increasingly degrades performance. Because copying garbage collectors move objects, they have an opportunity to improve locality. However, no static copying order is guaranteed to match program traversal orders. This paper introduces &#60;i>online object reordering&#60;/i> (OOR) which includes a new dynamic, online class analysis for Java that detects program traversal patterns and exploits them in a copying collector. OOR uses run-time method sampling that drives just-in-time (JIT) compilation. For each &#60;i>hot&#60;/i> (frequently executed) method, OOR analysis identifies the hot field accesses. At garbage collection time, the OOR collector then copies referents of hot fields together with their parent. Enhancements include static analysis to exclude accesses in cold basic blocks, heuristics that decay heat to respond to phase changes, and a separate space for hot objects. The overhead of OOR is on average negligible and always less than 2% on Java benchmarks in Jikes RVM with MMTk. We compare program performance of OOR to static class-oblivious copying orders (e.g., breadth and depth first). Performance variation due to static orders is often low, but can be up to 25%. In contrast, OOR matches or improves upon the best static order since its history-based copying tunes memory layout to program traversal.
[Garbage collection, Operating systems, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Scalable extensibility via nested inheritance
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Inheritance is a useful mechanism for factoring and reusing code. However, it has limitations for building extensible systems. We describe &#60;i>nested inheritance&#60;/i>, a mechanism that addresses some of the limitations of ordinary inheritance and other code reuse mechanisms. Using our experience with an extensible compiler framework, we show how nested inheritance can be used to construct highly extensible software frameworks. The essential aspects of nested inheritance are formalized in a simple object-oriented language with an operational semantics and type system. The type system of this language is sound, so no run-time type checking is required to implement it and no run-time type errors can occur. We describe our implementation of nested inheritance as an unobtrusive extension of the Java language, called Jx. Our prototype implementation translates Jx code to ordinary Java code, without duplicating inherited code.
[Classes and objects, General programming languages, Object oriented languages, Language features, Inheritance, Frameworks, Language types, Software notations and tools, Modules / packages, Software and its engineering]
Super and inner: together at last!
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
In an object-oriented language, a derived class may declare a method with the same signature as a method in the base class. The meaning of the re-declaration depends on the language. Most commonly, the new declaration overrides the base declaration, perhaps completely replacing it, or perhaps using &#60;b>super&#60;/b> to invoke the old implementation. Another possibility is that the base class always controls the method implementation, and the new declaration merely augments the method in the case that the base method calls &#60;b>inner&#60;/b>. Each possibility has advantages and disadvantages. In this paper, we explain why programmers need both kinds of method redeclaration, and we present a language that integrates them. We also present a formal semantics for the new language, and we describe an implementation for MzScheme.
[General programming languages, Language features, Inheritance, Software notations and tools, Software and its engineering]
Object-oriented encapsulation for dynamically typed languages
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Encapsulation in object-oriented languages has traditionally been based on static type systems. As a consequence, dynamically-typed languages have only limited support for encapsulation. This is surprising, considering that encapsulation is one of the most fundamental and important concepts behind object-oriented programming and that it is essential for writing programs that are maintainable and reliable, and that remain robust as they evolve. In this paper we describe the problems that are caused by insufficient encapsulation mechanisms and then present object-oriented encapsulation, a simple and uniform approach that solves these problems by bringing state of the art encapsulation features to dynamically typed languages. We provide a detailed discussion of our design rationales and compare them and their consequences to the encapsulation approaches used for statically typed languages. We also describe an implementation of object-oriented encapsulation in Smalltalk. Benchmarks of this implementation show that extensive use of object-oriented encapsulation results in a slowdown of less than 15 percent.
[Classes and objects, General programming languages, Language features, Inheritance, Software notations and tools, Software and its engineering]
Measuring the dynamic behaviour of AspectJ programs
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
This paper proposes and implements a rigorous method for studying the dynamic behaviour of AspectJ programs. As part of this methodology several new metrics specific to AspectJ programs are proposed and tools for collecting the relevant metrics are presented. The major tools consist of: (1) a modified version of the AspectJ compiler that tags bytecode instructions with an indication of the cause of their generation, such as a particular feature of AspectJ; and (2) a modified version of the *J dynamic metrics collection tool which is composed of a JVMPI-based trace generator and an analyzer which propagates tags and computes the proposed metrics. This dynamic propagation is essential, and thus this paper contributes not only new metrics, but also non-trivial ways of computing them. We furthermore present a set of benchmarks that exercise a wide range of AspectJ's features, and the metrics that we measured on these benchmarks. The results provide guidance to AspectJ users on how to avoid efficiency pitfalls, to AspectJ implementors on promising areas for future optimization, and to tool builders on ways to understand the runtime behaviour of AspectJ.
[Cross-computing tools and techniques, Metrics, General programming languages, Language features, Software notations and tools, General and reference, Software and its engineering]
Decentralizing execution of composite web services
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Distributed enterprise applications today are increasingly being built from services available over the web. A unit of functionality in this framework is a web service, a software application that exposes a set of "typed'' connections that can be accessed over the web using standard protocols. These units can then be composed into a &#60;i>composite&#60;/i> web service. BPEL (Business Process Execution Language) is a high-level distributed programming language for creating composite web services. Although a BPEL program invokes services distributed over several servers, the &#60;i>orchestration&#60;/i> of these services is typically under centralized control. Because performance and throughput are major concerns in enterprise applications, it is important to remove the inefficiencies introduced by the centralized control. In a distributed, or decentralized orchestration, the BPEL program is partitioned into independent sub-programs that interact with each other without any centralized control. Decentralization can increase parallelism and reduce the amount of network traffic required for an application. This paper presents a technique to partition a composite web service written as a single BPEL program into an equivalent set of decentralized processes. It gives a new code partitioning algorithm to partition a BPEL program represented as a program dependence graph, with the goal of minimizing communication costs and maximizing the &#60;i>throughput&#60;/i> of multiple concurrent instances of the input program. In contrast, much of the past work on dependence-based partitioning and scheduling seeks to minimize the &#60;i>completion time&#60;/i> of a single instance of a program running in isolation. The paper also gives a cost model to estimate the throughput of a given code partition.
[Software notations and tools, Software and its engineering, Compilers]
Resolving feature convolution in middleware systems
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Middleware provides simplicity and uniformity for the development of distributed applications. However, the modularity of the architecture of middleware is starting to disintegrate and to become complicated due to the interaction of too many orthogonal concerns imposed from a wide range of application requirements. This is not due to bad design but rather due to the limitations of the conventional architectural decomposition methodologies. We introduce the principles of horizontal decomposition (HD) which addresses this problem with a mixed-paradigm middleware architecture. HD provides guidance for the use of conventional decomposition methods to implement the core functionalities of middleware and the use of aspect orientation to address its orthogonal properties. Our evaluation of the horizontal decomposition principles focuses on refactoring major middleware functionalities into aspects in order to modularize and isolate them from the core architecture. New versions of the middleware platform can be created through combining the core and the flexible selection of middleware aspects such as IDL data types, the oneway invocation style, the dynamic messaging style, and additional character encoding schemes. As a result, the primary functionality of the middleware is supported with a much simpler architecture and enhanced performance. Moreover, customization and configuration of the middleware for a wide-range of requirements becomes possible.
[Software system structures, Software architectures, Software organization and properties, Software and its engineering]
Transparent proxies for java futures
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
A &#60;i>proxy&#60;/i> object is a surrogate or placeholder that controls access to another target object. Proxies can be used to support distributed programming, lazy or parallel evaluation, access control, and other simple forms of behavioral reflection. However, &#60;i>wrapper proxies&#60;/i> (like &#60;i>futures&#60;/i> or &#60;i>suspensions&#60;/i> for yet-to-be-computed results) can require significant code changes to be used in statically-typed languages, while proxies more generally can inadvertently violate assumptions of transparency, resulting in subtle bugs. To solve these problems, we have designed and implemented a simple framework for proxy programming that employs a static analysis based on qualifier inference, but with additional novelties. Code for using wrapper proxies is automatically introduced via a classfile-to-classfile transformation, and potential violations of transparency are signaled to the programmer. We have formalized our analysis and proven it sound. Our framework has a variety of applications, including support for asynchronous method calls returning futures. Experimental results demonstrate the benefits of our framework: programmers are relieved of managing and/or checking proxy usage, analysis times are reasonably fast, overheads introduced by added dynamic checks are negligible, and performance improvements can be significant. For example, changing two lines in a simple RMI-based peer-to-peer application and then using our framework resulted in a large performance gain.
[Control structures, General programming languages, Language features, Frameworks, Concurrent programming structures, Software notations and tools, Software and its engineering]
An efficient parallel heap compaction algorithm
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
We propose a heap compaction algorithm appropriate for modern computing environments. Our algorithm is targeted at SMP platforms. It demonstrates high scalability when running in parallel but is also extremely efficient when running single-threaded on a uniprocessor. Instead of using the standard forwarding pointer mechanism for updating pointers to moved objects, the algorithm saves information for a pack of objects. It then does a small computation to process this information and determine each object's new location. In addition, using a smart parallel moving strategy, the algorithm achieves (almost) perfect compaction in the lower addresses of the heap, whereas previous algorithms achieved parallelism by compacting within several predetermined segments. Next, we investigate a method that trades compaction quality for a further reduction in time and space overhead. Finally, we propose a modern version of the two-finger compaction algorithm. This algorithm fails, thus, re-validating traditional wisdom asserting that retaining the order of live objects significantly improves the quality of the compaction. The parallel compaction algorithm was implemented on the IBM production Java Virtual Machine. We provide measurements demonstrating high efficiency and scalability. Subsequently, this algorithm has been incorporated into the IBM production JVM.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Finding your cronies: static analysis for dynamic object colocation
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
This paper introduces &#60;i>dynamic&#60;/i> object colocation, an optimization to reduce copying costs in generational and other incremental garbage collectors by allocating connected objects together in the same space. Previous work indicates that connected objects belong together because they often have similar lifetimes. Generational collectors, however, allocate all new objects in a &#60;i>nursery&#60;/i> space. If these objects are connected to data structures residing in the &#60;i>mature&#60;/i> space, the collector must copy them. Our solution is a cooperative optimization that exploits compiler analysis to make runtime allocation decisions. The compiler analysis discovers potential object connectivity for newly allocated objects. It then replaces these allocations with calls to &#60;i>coalloc&#60;/i>, which takes an extra parameter called the &#60;i>colocator&#60;/i> object. At runtime, coalloc determines the location of the colocator and allocates the new object together with it in either the nursery or mature space. Unlike pretenuring, colocation makes precise per-object allocation decisions and does not require lifetime analysis or allocation site homogeneity. Experimental results for SPEC Java benchmarks using Jikes RVM show colocation can reduce garbage collection time by 50% to 75%, and total performance by up to 1%.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Vertical profiling: understanding the behavior of object-priented applications
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Object-oriented programming languages provide a rich set of features that provide significant software engineering benefits. The increased productivity provided by these features comes at a justifiable cost in a more sophisticated runtime system whose responsibility is to implement these features efficiently. However, the virtualization introduced by this sophistication provides a significant challenge to understanding complete system performance, not found in traditionally compiled languages, such as C or C++. Thus, understanding system performance of such a system requires profiling that spans all levels of the execution stack, such as the hardware, operating system, virtual machine, and application. In this work, we suggest an approach, called &#60;i>vertical profiling&#60;/i>, that enables this level of understanding. We illustrate the efficacy of this approach by providing deep understandings of performance problems of Java applications run on a VM with vertical profiling support. By incorporating vertical profiling into a programming environment, the programmer will be able to understand how their program interacts with the underlying abstraction levels, such as application server, VM, operating system, and hardware.
[Networks, Computer systems organization, Cross-computing tools and techniques, Hardware validation, Dependable and fault-tolerant systems and networks, Hardware, Performance, General and reference, Network performance evaluation]
Method-level phase behavior in java workloads
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Java workloads are becoming more and more prominent on various computing devices. Understanding the behavior of a Java workload which includes the interaction between the application and the virtual machine (VM), is thus of primary importance during performance analysis and optimization. Moreover, as contemporary software projects are increasing in complexity, automatic performance analysis techniques are indispensable. This paper proposes an off-line method-level phase analysis approach for Java workloads that consists of three steps. In the first step, the execution time is computed for each method invocation. Using an off-line tool, we subsequently analyze the dynamic call graph (that is annotated with the method invocations' execution times) to identify method-level phases. Finally, we measure performance characteristics for each of the selected phases. This is done using hardware performance monitors. As such, our approach allows for linking microprocessor-level information at the individual methods in the Java application's source code. This is extremely interesting information during performance analysis and optimization as programmers can use this information to optimize their code. We evaluate our approach in the Jikes RVM on an IA-32 platform using the SPECjvm98 and SPECjbb2000 benchmarks. This is done according to a number of important criteria: the overhead during profiling, the variability within and between the phases, its applicability in Java workload characterization (measuring performance characteristics of the various VM components) and application bottleneck identification.
[Design, Measurement, Cross-computing tools and techniques, Metrics, Performance, General and reference]
Instrumentation of standard libraries in object-oriented languages: the twin class hierarchy approach
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Code instrumentation is widely used for a range of purposes that include profiling, debugging, visualization, logging, and distributed computing. Due to their special status within the language infrastructure, the &#60;i>standard class libraries&#60;/i>, also known as &#60;i>system classes&#60;/i> provided by most contemporary object-oriented languages are difficult and sometimes impossible to instrument. If instrumented, the use of their rewritten versions within the instrumentation code is usually unavoidable. However, this is equivalent to `instrumenting the instrumentation', and thus may lead to erroneous results. Consequently, most systems avoid rewriting system classes. We present a novel instrumentation strategy that alleviates the above problems by renaming the instrumented classes. The proposed approach does not require any modifications to the language, compiler or runtime. It allows system classes to be instrumented both statically and dynamically. In fact, this is the first technique that enables dynamic instrumentation of Java system classes without modification of any runtime components. We demonstrate our approach by implementing two instrumentation-based systems: a memory profiler and a distributed runtime for Java.
[Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software post-development issues, Software reverse engineering, Software and its engineering]
Recovering binary class relationships: putting icing on the UML cake
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
A discontinuity exists between object-oriented modeling and programming languages. This discontinuity arises from ambiguous concepts in modeling languages and a lack of corresponding concepts in programming languages. It is particularly acute for binary class relationships---association, aggregation, and composition. It hinders the traceability between software implementation and design, thus hampering software analysis. We propose consensual definitions of the binary class relationships with four minimal properties---exclusivity, invocation site, lifetime, and multiplicity. We describe algorithms to detect automatically these properties in source code and apply these on several frameworks. Thus, we bridge the gap between implementation and design for the binary class relationships, easing software analysis.
[Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software post-development issues, Specification languages, Software reverse engineering, System description languages, Software and its engineering]
Refactoring class hierarchies with KABA
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
KABA is an innovative system for refactoring Java class hierar-chies. It uses the Snelting/Tip algorithm [13] in order to determine a behavior-preserving refactoring which is optimal with respect to a given set of client programs. KABA can be based on dynamic as well as static program analysis. The static variant will preserve program behavior for all possible input values; the dynamic version guarantees preservation of behavior for all runs in a given test suite. KABA offers automatic refactoring as well as manual refactoring using a dedicated editor. In this contribution, we recapitulate the Snelting/Tip algorithm, present the new dynamic version, and explain new extensions which allow to handle full Java. We then present five case studies which discuss the KABA refactoring proposals for programs such as javac and antlr. KABA proved that javac does not need refactoring, but generated semantics-based refactoring proposals for antlr.
[Software creation and management, Classes and objects, Language features, Inheritance, Software post-development issues, Software notations and tools, Program analysis, Theory of computation, Semantics and reasoning, General programming languages, Program semantics, Software reverse engineering, Program reasoning, Software and its engineering]
Mirrors: design principles for meta-level facilities of object-oriented programming languages
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
We identify three design principles for reflection and metaprogramming facilities in object oriented programming languages. &#60;i>Encapsulation&#60;/i>: meta-level facilities must encapsulate their implementation. &#60;i>Stratification&#60;/i>: meta-level facilities must be separated from base-level functionality. &#60;i>Ontological correspondence&#60;/i>: the ontology of meta-level facilities should correspond to the ontology of the language they manipulate. Traditional/mainstream reflective architectures do not follow these precepts. In contrast, reflective APIs built around the concept of &#60;i>mirrors&#60;/i> are characterized by adherence to these three principles. Consequently, mirror-based architectures have significant advantages with respect to distribution, deployment and general purpose metaprogramming.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Practical predicate dispatch
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
&#60;i>Predicate dispatch&#60;/i> is an object-oriented (OO) language mechanism for determining the method implementation to be invoked upon a message send. With predicate dispatch, each method implementation includes a predicate guard specifying the conditions under which the method should be invoked, and logical implication of predicates determines the method overriding relation. Predicate dispatch naturally unifies and generalizes several common forms of dynamic dispatch, including traditional OO dispatch, multimethod dispatch, and functional-style pattern matching. Unfortunately, prior languages supporting predicate dispatch have had several deficiencies that limit its utility in practice. We introduce JPred, a backward-compatible extension to Java supporting predicate dispatch. While prior languages with predicate dispatch have been extensions to toy or non-mainstream languages, we show how predicate dispatch can be naturally added to a traditional OO language. While prior languages with predicate dispatch have required the whole program to be available for type-checking and compilation, JPred retains Java's modular typechecking and compilation strategies. While prior languages with predicate dispatch have included special-purpose algorithms for reasoning about predicates, JPred employs general-purpose, off-the-shelf decision procedures. As a result, JPred's type system is more flexible, allowing several useful programming idioms that are spuriously rejected by those other languages. After describing the JPred language and type system, we present a case study illustrating the utility of JPred in a real-world application, including its use in the detection of several errors.
[Procedures, functions and subroutines, Classes and objects, General programming languages, Object oriented languages, Language features, Inheritance, Language types, Software notations and tools, Software and its engineering]
Concrete syntax for objects: domain-specific language embedding and assimilation without restrictions
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Application programmer's interfaces give access to domain knowledge encapsulated in class libraries without providing the appropriate notation for expressing domain composition. Since object-oriented languages are designed for extensibility and reuse, the language constructs are often sufficient for expressing domain abstractions at the semantic level. However, they do not provide the right abstractions at the syntactic level. In this paper we describe MetaBorg, a method for providing &#60;i>concrete syntax&#60;/i> for domain abstractions to application programmers. The method consists of &#60;i>embedding&#60;/i> domain-specific languages in a general purpose host language and &#60;i>assimilating&#60;/i> the embedded domain code into the surrounding host code. Instead of extending the implementation of the host language, the assimilation phase implements domain abstractions in terms of existing APIs leaving the host language undisturbed. Indeed, MetaBorg can be considered a method for promoting APIs to the language level. The method is supported by proven and available technology, i.e. the syntax definition formalism SDF and the program transformation language and toolset Stratego/XT. We illustrate the method with applications in three domains: code generation, XML generation, and user-interface construction.
[Software notations and tools, Software and its engineering, Compilers]
Object-oriented units of measurement
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Programs that manipulate physical quantities typically represent these quantities as raw numbers corresponding to the quantities' measurements in particular units (e.g., a length represented as a number of meters). This approach eliminates the possibility of catching errors resulting from adding or comparing quantities expressed in different units (as in the Mars Climate Orbiter error [11]), and does not support the safe comparison and addition of quantities of the same dimension. We show how to formulate dimensions and units as classes in a nominally typed object-oriented language through the use of statically typed metaclasses. Our formulation allows both parametric and inheritance poly-morphism with respect to both dimension and unit types. It also allows for integration of encapsulated measurement systems, dynamic conversion factors, declarations of scales (including nonlinear scales) with defined zeros, and nonconstant exponents on dimension types. We also show how to encapsulate most of the "magic machinery" that handles the algebraic nature of dimensions and units in a single meta-class that allows us to treat select static types as generators of a free abelian group.
[Theory of computation, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Formal language definitions, Formal languages and automata theory, Software and its engineering]
Pluggable verification modules: an extensible protection mechanism for the JVM
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
Through the design and implementation of a JVM that supports Pluggable Verification Modules (PVMs), the idea of an extensible protection mechanism is entertained. Link-time bytecode verification becomes a pluggable service that can be readily replaced, reconfigured and augmented. Application-specific verification services can be safely introduced into the dynamic linking process of the JVM. This feature is enabled by the adoption of a previously proposed modular verification architecture, Proof Linking [23, 24], which decouples bytecode verification from the dynamic linking process, rendering the verifier a replaceable module. The PVM mechanism has been implemented in an open source JVM, the Aegis VM [21]. To evaluate the software engineering and security engineering benefits of this extensible protection mechanism, an augmented type system JAC (Java Access Control) [37] has been successfully implemented as a PVM.
[Access control, Macro languages, Assembly languages, Access protection, Software and application security, Systems security, Software notations and tools, Security and privacy, Software organization and properties, Software and its engineering, Software functional properties, Object oriented languages, Context specific languages, Language types, Runtime environments, Correctness, Operating systems security, Software architectures, Domain specific languages, Software system structures, Software security engineering, General programming languages, Security services, Compilers]
Finding and preventing run-time error handling mistakes
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
It is difficult to write programs that behave correctly in the presence of run-time errors. Existing programming language features often provide poor support for executing clean-up code and for restoring invariants in such exceptional situations. We present a dataflow analysis for finding a certain class of error-handling mistakes: those that arise from a failure to release resources or to clean up properly along all paths. Many real-world programs violate such resource safety policies because of incorrect error handling. Our flow-sensitive analysis keeps track of outstanding obligations along program paths and does a precise modeling of control flow in the presence of exceptions. Using it, we have found over 800 error handling mistakes almost 4 million lines of Java code. The analysis is unsound and produces false positives, but a few simple filtering rules suffice to remove them in practice. The remaining mistakes were manually verified. These mistakes cause sockets, files and database handles to be leaked along some paths. We present a characterization of the most common causes of those errors and discuss the limitations of exception handling, finalizers and destructors in addressing them. Based on those errors, we propose a programming language feature that keeps track of obligations at run time and ensures that they are discharged. Finally, we present case studies to demonstrate that this feature is natural, efficient, and can improve reliability; for example, retrofitting a 34kLOC program with it resulted in a 0.5% code size decrease, a surprising 17% speed increase (from correctly deallocating resources in the presence of exceptions), and more consistent behavior.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Language features, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, General programming languages, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Chianti: a tool for change impact analysis of java programs
Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 39 ISSUE 10
2004
This paper reports on the design and implementation of Chianti, a change impact analysis tool for Java that is implemented in the context of the Eclipse environment. Chianti analyzes two versions of an application and decomposes their difference into a set of atomic changes. Change impact is then reported in terms of affected (regression or unit) tests whose execution behavior may have been modified by the applied changes. For each affected test, Chianti also determines a set of affecting changes that were responsible for the test's modified behavior. This latter step of isolating the changes that induce the failure of one specific test from those changes that only affect other tests can be used as a debugging technique in situations where a test fails unexpectedly after a long editing session. We evaluated Chianti on a year (2002) of CVS data from M. Ernst's Daikon system, and found that, on average, 52% of Daikon's unit tests are affected. Furthermore, each affected unit test, on average, is affected by only 3.95% of the atomic changes. These findings suggest that our change impact analysis is a promising technique for assisting developers with program understanding and debugging.
[Software defect analysis, Software creation and management, Software verification and validation, Software notations and tools, Program analysis, Development frameworks and environments, Theory of computation, Software testing and debugging, Semantics and reasoning, Program semantics, Program reasoning, Software and its engineering]
Associated types and constraint propagation for mainstream object-oriented generics
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Support for object-oriented programming has become an integral part of mainstream languages, and more recently generic programming has gained widespread acceptance as well. A natural question is how these two paradigms, and their underlying language mechanisms, should interact. One particular design option, that of using subtyping to constrain the type parameters of generic functions, has been chosen in the generics of Java and those planned for a future revision of C#.Certain shortcomings have previously been identified in using subtyping for constraining parametric polymorphism in the context of generic programming.To address these, we propose extending object-oriented interfaces and subtyping to include associated types and constraint propagation.Associated types are type members of interfaces and classes. Constraint propagation allows certain constraints on type parameters to be inferred from other constraints on those parameters and their use in base class type expressions.The paper demonstrates these extensions in the context of C# (with generics), describes a translation of the extended features to C#, and presents a formalism proving their safety. The formalism is applicable to other mainstream object-oriented languages supporting F-bounded polymorphism, such as Java.
[Classes and objects, General programming languages, Language features, Language types, Software notations and tools, Software and its engineering, Polymorphism]
Generalized algebraic data types and object-oriented programming
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Generalized algebraic data types (GADTs) have received much attention recently in the functional programming community. They generalize the (type) parameterized algebraic datatypes (PADTs) of ML and Haskell by permitting value constructors to return specific, rather than parametric, type-instantiations of their own datatype. GADTs have a number of applications, including strongly-typed evaluators, generic pretty-printing, generic traversals and queries, and typed LR parsing. We show that existing object-oriented programming languages such as Java and C# can express GADT definitions, and a large class of GADT-manipulating programs, through the use of generics, subclassing, and virtual dispatch. However, some programs can be written only through the use of redundant runtime casts. Moreover, instantiation-specific, yet safe, operations on ordinary PADTs only admit indirect cast-free implementations, via higher-order encodings. We propose a generalization of the type constraint mechanisms of C# and Java to both avoid the need for casts in GADT programs and higher-order contortions in PADT programs; we present a Visitor pattern for GADTs, and describe a refined switch construct as an alternative to virtual dispatch on datatypes. We formalize both extensions and prove type soundness.
[Classes and objects, Language features, Inheritance, Software notations and tools, Program constructs, Object oriented constructs, Theory of computation, Constraints, Semantics and reasoning, General programming languages, Data types and structures, Type structures, Software and its engineering, Polymorphism]
Scalable component abstractions
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
We identify three programming language abstractions for the construction of reusable components: abstract type members, explicit selftypes, and modular mixin composition. Together, these abstractions enable us to transform an arbitrary assembly of static program parts with hard references between them into a system of reusable components. The transformation maintains the structure of the original system. We demonstrate this approach in two case studies, a subject/observer framework and a compiler front-end.
[Classes and objects, General programming languages, Language features, Inheritance, Software notations and tools, Modules / packages, Recursion, Software and its engineering, Polymorphism]
Demand-driven points-to analysis for Java
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
We present a points-to analysis technique suitable for environments with small time and memory budgets, such as just-in-time (JIT) compilers and interactive development environments (IDEs). Our technique is demand-driven, performing only the work necessary to answer each query (a request for a variable's points-to information) issued by a client. In cases where even the demand-driven approach exceeds the time budget for a query, we employ early termination, i.e., stopping the analysis prematurely and returning an over-approximated result to the client. Our technique improves on previous demand-driven points-to analysis algorithms [17, 33] by achieving much higher precision under small time budgets and early termination.We formulate Andersen's analysis [5] for Java as a CFL-reachability problem [33]. This formulation shows that Andersen's analysis for Java is a balanced-parentheses problem, an insight that enables our new techniques. We exploit the balanced parentheses structure to approximate Andersen's analysis by regularizing the CFL-reachability problem, yielding an asymptotically cheaper algorithm. We also show how to regain most of the precision lost in the regular approximation as needed through refinement. Our evaluation shows that our regularization and refinement approach achieves nearly the precision of field-sensitive Andersen's analysis in time budgets as small as 2ms per query. Our technique can yield speedups of up to 16x over computing an exhaustive Andersen's analysis for some clients, with little to no precision loss.
[Software notations and tools, Development frameworks and environments, Software and its engineering, Compilers]
Deriving object typestates in the presence of inter-object references
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
We are interested in static analysis of Java classes with the goal of discovering the preconditions under which a certain program point within a method may be reached, taking into account the effects of previous method calls on an object of that class. The information pertinent to this computation is represented as the object's typestate, which is a finite set of relevant predicates that abstract the object's actual state. The execution of a method depends on an object's current typestate as well as other input parameters; the object may transition to a different typestate during the method's execution.It is common for objects to contain references to other ob-jects. In such cases, an object's behavior may depend on, in addition to its own state, the state of objects it has a refer-ence to. The main contribution of this paper is to discover relevant object typestates, as well as transitions between typestates, in the presence of inter-object references. Our analysis first performs a combined predicate discovery and predicate abstraction to derive "boolean" versions of Java classes given as input. It then uses abstract interpretation to compute the typestate transitions caused by method calls. A novel aspect of this work is that a set of Java classes is analyzed in isolation, without any client program being pro-vided. To do this, the analysis simulates all possible client's actions via a synthetic heap, all of whose interesting config-urations are explored by our analysis.The information we compute can be put to use in several ways. It can be used in checking whether a given client code erroneously uses a set of Java classes in a way that can throw an exception. It can also be used in creating test drivers for Java classes in order to exercise all relevant code paths in the corresponding methods.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
ArchMatE: from architectural styles to object-oriented models through exploratory tool support
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Given the difficulties of conventional object technologies to deal with quality-attribute concerns, software architectures appear as an interesting approach to manage them better. A problem to make this approach feasible is the gap between architectural and object models. Succeeding in bridging these two worlds implies that those design decisions about quality attributes made at the architectural level should be reflected at the object level. Nonetheless, a given architecture usually admits multiple, different materializations. Furthermore, any materialization requires considerable design background and experience from the developer. In this paper, we describe a tool approach, called ArchMatE, to assist developers in the exploration of object-oriented solutions for grounding specific architectural models. An important aspect of the approach is that the materializations are accomplished by means of quality-oriented strategies, so that those concerns prescribed by the original architecture are mostly preserved.
[Software creation and management, Language features, Software notations and tools, Object oriented frameworks, Client-server architectures, Software architectures, Development frameworks and environments, Software development techniques, Distributed systems organizing principles, Software system structures, General programming languages, Object oriented development, Patterns, Software organization and properties, Software and its engineering]
Modeling architectural patterns using architectural primitives
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Architectural patterns are a key point in architectural documentation. Regrettably, there is poor support for modeling architectural patterns, because the pattern elements are not directly matched by elements in modeling languages, and, at the same time, patterns support an inherent variability that is hard to model using a single modeling solution. This paper proposes tackling this problem by finding and representing architectural primitives, as the participants in the solutions that patterns convey. In particular, we examine a number of architectural patterns to discover those primitive abstractions that are common among the patterns, and at the same time demonstrate a degree of variability in each pattern. These abstractions belong in the components and connectors architectural view, though more abstractions can be found in other views. We have selected UML 2 as the language for representing these primitive abstractions as extensions of the standard UML elements. The added value of this approach is twofold: it proposes a generic and extensible approach for modeling architectural patterns by means of architectural primitives; it demonstrates an initial set of primitives that participate in several well-known architectural patterns.
[Software system structures, Designing software, Software creation and management, Software architectures, Software organization and properties, Software and its engineering]
Parametric polymorphism for software component architectures
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Parametric polymorphism has become a common feature of mainstream programming languages, but software component architectures have lagged behind and do not support it. We examine the problem of providing parametric polymorphism with components combined from different programming languages. We have investigated how to resolve different binding times and parametrization semantics in a range of representative languages and have identified a common ground that can be suitably mapped to different language bindings. We present a generic component architecture extension that provides support for parameterized components and that can be easily adapted to work on top of various software component architectures in use today (e.g., <sc>corba</sc>, <sc>dcom</sc>, <sc>jni</sc>). We have implemented and tested this architecture on top of <sc>corba</sc>. We also present Generic Interface Definition Language (<sc>gidl</sc>), an extension to <sc>corba</sc>-<sc>idl</sc> supporting generic types and we describe language bindings for C++, Java and Aldor. We explain our implementation of <sc>gidl</sc>, consisting of a <sc>gidl</sc> to <sc>idl</sc> compiler and tools for generating linkage code under the language bindings. We demonstrate how this architecture can be used to access C++'s <sc>stl</sc> and Aldor's BasicMath libraries in a multi-language environment and discuss our mappings in the context of automatic library interface generation.
[Object oriented languages, Language features, Language types, Software notations and tools, Extra-functional properties, Modules / packages, Software architectures, Interoperability, Software system structures, General programming languages, Software libraries and repositories, Software organization and properties, Software and its engineering]
Using dependency models to manage complex software architecture
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
An approach to managing the architecture of large software systems is presented. Dependencies are extracted from the code by a conventional static analysis, and shown in a tabular form known as the 'Dependency Structure Matrix' (DSM). A variety of algorithms are available to help organize the matrix in a form that reflects the architecture and highlights patterns and problematic dependencies. A hierarchical structure obtained in part by such algorithms, and in part by input from the user, then becomes the basis for 'design rules' that capture the architect's intent about which dependencies are acceptable. The design rules are applied repeatedly as the system evolves, to identify violations, and keep the code and its architecture in conformance with one another. The analysis has been implemented in a tool called LDM which has been applied in several commercial projects; in this paper, a case study application to Haystack, an information retrieval system, is described.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software system structures, Software creation and management, Software development methods, Software architectures, Software organization and properties, Software and its engineering]
Classbox/J: controlling the scope of change in Java
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Unanticipated changes to complex software systems can introduce anomalies such as duplicated code, suboptimal inheritance relationships and a proliferation of run-time downcasts. Refactoring to eliminate these anomalies may not be an option, at least in certain stages of software evolution. Classboxes are modules that restrict the visibility of changes to selected clients only, thereby offering more freedom in the way unanticipated changes may be implemented, and thus reducing the need for convoluted design anomalies. In this paper we demonstrate how classboxes can be implemented in statically-typed languages like Java. We also present an extended case study of Swing, a Java GUI package built on top of AWT, and we document the ensuing anomalies that Swing introduces. We show how Classbox/J, a prototype implementation of classboxes for Java, is used to provide a cleaner implementation of Swing using local refinement rather than subclassing.
[General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Interaction-based programming with classages
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
This paper presents Classages, a novel interaction-centric object-oriented language. Classes and objects in Classages are fully encapsulated, with explicit interfaces for all interactions they might be involved in. The design of Classages touches upon a wide range of language design topics, including encapsulation, object relationship representation, and object confinement. An encoding of Java's OO model in Classages is provided, showing how standard paradigms are supported. A prototype Classages compiler is described.
[Classes and objects, General programming languages, Language features, Software notations and tools, Software and its engineering]
Javari: adding reference immutability to Java
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
This paper describes a type system that is capable of expressing and enforcing immutability constraints. The specific constraint expressed is that the abstract state of the object to which an immutable reference refers cannot be modified using that reference. The abstract state is (part of) the transitively reachable state: that is, the state of the object and all state reachable from it by following references. The type system permits explicitly excluding fields from the abstract state of an object. For a statically type-safe language, the type system guarantees reference immutability. If the language is extended with immutability downcasts, then run-time checks enforce the reference immutability constraints.This research builds upon previous research in language support for reference immutability. Improvements that are new in this paper include distinguishing the notions of assignability and mutability; integration with Java 5's generic types and with multi-dimensional arrays; a mutability polymorphism approach to avoiding code duplication; type-safe support for reflection and serialization; and formal type rules and type soundness proof for a core calculus. Furthermore, it retains the valuable features of the previous dialect, including usability by humans (as evidenced by experience with 160,000 lines of Javari code) and interoperability with Java and existing JVMs.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Object oriented languages, Data types and structures, Language types, Software notations and tools, Program reasoning, Logic, Software and its engineering]
Fine-grained interoperability through mirrors and contracts
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
As a value flows across the boundary between interoperating languages, it must be checked and converted to fit the types and representations of the target language. For simple forms of data, the checks and coercions can be immediate; for higher order data, such as functions and objects, some must be delayed until the value is used in a particular way. Typically, these coercions and checks are implemented by an ad-hoc mixture of wrappers, reflection, and dynamic predicates. We observe that 1) the wrapper and reflection operations fit the profile of mirrors, 2) the checks correspond to contracts, and 3) the timing and shape of mirror operations coincide with the timing and shape of contract operations. Based on these insights, we present a new model of interoperability that builds on the ideas of mirrors and contracts, and we describe an interoperable implementation of Java and Scheme that is guided by the model.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Pluggable AOP: designing aspect mechanisms for third-party composition
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Studies of Aspect-Oriented Programming (AOP) usually focus on a language in which a specific aspect extension is integrated with a base language. Languages specified in this manner have a fixed, non-extensible AOP functionality. This paper argues the need for AOP to support the integration and use of multiple domain-specific aspect extensions together. We study the more general case of integrating a base language with a set of third-party aspect extensions for that language. We present a general mixin-based semantic framework for implementing dynamic aspect extensions in such a way that multiple, independently developed aspect mechanisms can be subject to third-party composition and work collaboratively. Principles governing the design of a collaborative aspect mechanism are aspectual effect exposure and implementation hiding.
[Software creation and management, Object oriented languages, Language types, Extra-functional properties, Software notations and tools, Formal languages and automata theory, Interoperability, Theory of computation, Designing software, Semantics and reasoning, General programming languages, Program semantics, Formal language definitions, Software organization and properties, Software and its engineering]
Refactoring support for class library migration
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
As object-oriented class libraries evolve, classes are occasionally deprecated in favor of others with roughly the same functionality. In Java's standard libraries, for example, class Hashtable has been superseded by HashMap, and Iterator is now preferred over Enumeration. Migrating client applications to use the new idioms is often desirable, but making the required changes to declarations and allocation sites can be quite labor-intensive. Moreover, migration becomes complicated---and sometimes impossible---if an application interacts with external components, if a legacy class is not completely equivalent to its replacement, or if multiple interdependent classes must be migrated simultaneously. We present an approach in which mappings between legacy classes and their replacements are specified by the programmer. Then, an analysis based on type constraints determines where declarations and allocation sites can be updated. The method was implemented in Eclipse, and evaluated on a number of Java applications. On average, our tool could migrate more than 90% of the references to legacy classes.
[Software creation and management, Software post-development issues, Software reverse engineering, Software and its engineering]
Automating vertical profiling
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Last year at OOPSLA we presented a methodology, vertical profiling, for understanding the performance of object-oriented programs. The key insight behind this methodology is that modern programs run on top of many layers (virtual machine, middleware, etc) and thus we need to collect and combine information from all layers in order to understand system performance. Although our methodology was able to explain previously unexplained performance phenomena, it was extremely labor intensive. In this paper we describe and evaluate techniques for automating two significant activities of vertical profiling: trace alignment and correlation. Trace alignment aligns traces obtained from separate runs so that one can reason across the traces. We are not aware of any prior approach that effectively and automatically aligns traces. Correlation sifts through hundreds of metrics to find ones that have a bearing on a performance anomaly of interest. In prior work we found that statistical correlation was only sometimes effective. We have identified highly-effective approaches for both activities.For aligning traces we explore dynamic time warping, and for correlation we explore eight correlators based on statistical correlation, distance measures, and piecewise linear segmentation. Although we explore these activities in the context of vertical profiling, both activities are widely applicable in the performance analysis area.
[Measurement, Cross-computing tools and techniques, Metrics, Hardware validation, Hardware, Performance, General and reference]
Improving virtual machine performance using a cross-run profile repository
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Virtual machines for languages such as the Java programming language make extensive use of online profiling and dynamic optimization to improve program performance. But despite the important role that profiling plays in achieving high performance, current virtual machines discard a program's profile data at the end of execution, wasting the opportunity to use past knowledge to improve future performance. In this paper, we present a fully automated architecture for exploiting cross-run profile data in virtual machines. Our work addresses a number of challenges that previously limited the practicality of such an approach.We apply this architecture to address the problem of selective optimization, and describe our implementation in IBM's J9 Java virtual machine. Our results demonstrate substantial performance improvements on a broad suite of Java programs, with the average performance ranging from 8.8% -- 16.6% depending on the execution scenario.
[Software notations and tools, Software and its engineering, Compilers]
Quantifying the performance of garbage collection vs. explicit memory management
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Garbage collection yields numerous software engineering benefits, but its quantitative impact on performance remains elusive. One can compare the cost of conservative garbage collection to explicit memory management in C/C++ programs by linking in an appropriate collector. This kind of direct comparison is not possible for languages designed for garbage collection (e.g., Java), because programs in these languages naturally do not contain calls to free. Thus, the actual gap between the time and space performance of explicit memory management and precise, copying garbage collection remains unknown.We introduce a novel experimental methodology that lets us quantify the performance of precise garbage collection versus explicit memory management. Our system allows us to treat unaltered Java programs as if they used explicit memory management by relying on oracles to insert calls to free. These oracles are generated from profile information gathered in earlier application runs. By executing inside an architecturally-detailed simulator, this "oracular" memory manager eliminates the effects of consulting an oracle while measuring the costs of calling malloc and free. We evaluate two different oracles: a liveness-based oracle that aggressively frees objects immediately after their last use, and a reachability-based oracle that conservatively frees objects just after they are last reachable. These oracles span the range of possible placement of explicit deallocation calls.We compare explicit memory management to both copying and non-copying garbage collectors across a range of benchmarks using the oracular memory manager, and present real (non-simulated) runs that lend further validity to our results. These results quantify the time-space tradeoff of garbage collection: with five times as much memory, an Appel-style generational collector with a non-copying mature space matches the performance of reachability-based explicit memory management. With only three times as much memory, the collector runs on average 17% slower than explicit memory management. However, with only twice as much memory, garbage collection degrades performance by nearly 70%. When physical memory is scarce, paging causes garbage collection to run an order of magnitude slower than explicit memory management.
[Garbage collection, Dynamic compilers, Operating systems, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Runtime specialization with optimistic heap analysis
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
We describe a highly practical program specializer for Java programs. The specializer is powerful, because it specializes optimistically, using (potentially transient) constants in the heap; it is precise, because it specializes using data structures that are only partially invariant; it is deployable, because it is hidden in a JIT compiler and does not require any user annotations or offline preprocessing; it is simple, because it uses existing JIT compiler ingredients; and it is fast, because it specializes programs in under 1s.These properties are the result of (1) a new algorithm for selecting specializable code fragments, based on a notion of influence; (2) a precise store profile for identifying constant heap locations; and (3) an efficient invalidation mechanism for monitoring optimistic assumptions about heap constants. Our implementation of the specializer in the Jikes RVM has low overhead, selects specialization points that would be chosen manually, and produces speedups ranging from a factor of 1.2 to 6.4, comparable with annotation-guided specializers.
[General programming languages, Software notations and tools, Software and its engineering]
Adding trace matching with free variables to AspectJ
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
An aspect observes the execution of a base program; when certain actions occur, the aspect runs some extra code of its own. In the AspectJ language, the observations that an aspect can make are confined to the current action: it is not possible to directly observe the history of a computation.Recently, there have been several interesting proposals for new history-based language features, most notably by Douence et al. and by Walker and Viggers. In this paper, we present a new history-based language feature called tracematches that enables the programmer to trigger the execution of extra code by specifying a regular pattern of events in a computation trace. We have fully designed and implemented tracematches as a seamless extension of AspectJ.A key innovation in our tracematch approach is the introduction of free variables in the matching patterns. This enhancement enables a whole new class of applications in which events can be matched not only by the event kind, but also by the values associated with the free variables. We provide several examples of applications enabled by this feature.After introducing and motivating the idea of tracematches via examples, we present a detailed semantics of our language design, and we derive an implementation from that semantics. The implementation has been realised as an extension of the abc compiler for AspectJ.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Finding application errors and security flaws using PQL: a program query language
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
A number of effective error detection tools have been built in recent years to check if a program conforms to certain design rules. An important class of design rules deals with sequences of events asso-ciated with a set of related objects. This paper presents a language called PQL (Program Query Language) that allows programmers to express such questions easily in an application-specific context. A query looks like a code excerpt corresponding to the shortest amount of code that would violate a design rule. Details of the tar-get application's precise implementation are abstracted away. The programmer may also specify actions to perform when a match is found, such as recording relevant information or even correcting an erroneous execution on the fly.We have developed both static and dynamic techniques to find solutions to PQL queries. Our static analyzer finds all potential matches conservatively using a context-sensitive, flow-insensitive, inclusion-based pointer alias analysis. Static results are also use-ful in reducing the number of instrumentation points for dynamic analysis. Our dynamic analyzer instruments the source program to catch all violations precisely as the program runs and to optionally perform user-specified actions.We have implemented the techniques described in this paper and found 206 errors in 6 large real-world open-source Java applica-tions containing a total of nearly 60,000 classes. These errors are important security flaws, resource leaks, and violations of consis-tency invariants. The combination of static and dynamic analysis proves effective at addressing a wide range of debugging and pro-gram comprehension queries. We have found that dynamic analysis is especially suitable for preventing errors such as security vulner-abilities at runtime.
[Traceability, Software creation and management, Software verification and validation, Process validation, Software and its engineering]
Relational queries over program traces
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Instrumenting programs with code to monitor runtime behavior is a common technique for profiling and debugging. In practice, instrumentation is either inserted manually by programmers, or automatically by specialized tools that monitor particular properties. We propose Program Trace Query Language (PTQL), a language based on relational queries over program traces, in which programmers can write expressive, declarative queries about program behavior. We also describe our compiler, <sc>Partiqle</sc>. Given a PTQL query and a Java program, <sc>Partiqle</sc> instruments the program to execute the query on-line. We apply several PTQL queries to a set of benchmark programs, including the Apache Tomcat Web server. Our queries reveal significant performance bugs in the jack SpecJVM98 benchmark, in Tomcat, and in the IBM Java class library, as well as some correct though uncomfortably subtle code in the Xerces XML parser. We present performance measurements demonstrating that our prototype system has usable performance.
[Middleware for databases, Distributed transaction monitors, Context specific languages, Software notations and tools, Contextual software domains, Specialized application languages, Information systems, Operating systems, Data management systems, Monitors, Software organization and properties, Software and its engineering, Process management]
Formalising Java RMI with explicit code mobility
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
This paper presents a Java-like core language with primitives for object-oriented distribution and explicit code mobility. We apply our formulation to prove the correctness of several optimisations for distributed programs. Our language captures crucial but often hidden aspects of distributed object-oriented programming, including object serialisation, dynamic class downloading and remote method invocation. It is defined in terms of an operational semantics that concisely models the behaviour of distributed programs using machinery from calculi of mobile processes. Type safety is established using invariant properties for distributed runtime configurations. We argue that primitives for explicit code mobility offer a programmer fine-grained control of type-safe code distribution, which is crucial for improving the performance and safety of distributed object-oriented applications.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Program semantics, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
Lifting sequential graph algorithms for distributed-memory parallel computation
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
This paper describes the process used to extend the Boost Graph Library (BGL) for parallel operation with distributed memory. The BGL consists of a rich set of generic graph algorithms and supporting data structures, but it was not originally designed with parallelism in mind. In this paper, we revisit the abstractions comprising the BGL in the context of distributed-memory parallelism, lifting away the implicit requirements of sequential execution and a single shared address space. We illustrate our approach by describing the process as applied to one of the core algorithms in the BGL, breadth-first search. The result is a generic algorithm that is unchanged from the sequential algorithm, requiring only the introduction of external (distributed) data structures for parallel execution. More importantly, the generic implementation retains its interface and semantics, such that other distributed algorithms can be built upon it, just as algorithms are layered in the sequential case. By characterizing these extensions as well as the extension process, we develop general principles and patterns for using (and reusing) generic, object-oriented parallel software libraries. We demonstrate that the resulting algorithm implementations are both efficient and scalable with performance results for several algorithms.
[Software creation and management, Computing methodologies, Language types, Software notations and tools, Object oriented frameworks, Distributed computing methodologies, Development frameworks and environments, Software development techniques, Distributed programming languages, General programming languages, Object oriented development, Software libraries and repositories, Software and its engineering]
Safe futures for Java
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
A future is a simple and elegant abstraction that allows concurrency to be expressed often through a relatively small rewrite of a sequential program. In the absence of side-effects, futures serve as benign annotations that mark potentially concurrent regions of code. Unfortunately, when computation relies heavily on mutation as is the case in Java, its meaning is less clear, and much of its intended simplicity lost.This paper explores the definition and implementation of safe futures for Java. One can think of safe futures as truly transparent annotations on method calls, which designate opportunities for concurrency. Serial programs can be made concurrent simply by replacing standard method calls with future invocations. Most significantly, even though some parts of the program are executed concurrently and may indeed operate on shared data, the semblance of serial execution is nonetheless preserved. Thus, program reasoning is simplified since data dependencies present in a sequential program are not violated in a version augmented with safe futures.Besides presenting a programming model and API for safe futures, we formalize the safety conditions that must be satisfied to ensure equivalence between a sequential Java program and its future-annotated counterpart. A detailed implementation study is also provided. Our implementation exploits techniques such as object versioning and task revocation to guarantee necessary safety conditions. We also present an extensive experimental evaluation of our implementation to quantify overheads and limitations. Our experiments indicate that for programs with modest mutation rates on shared data, applications can use futures to profitably exploit parallelism, without sacrificing safety.
[Procedures, functions and subroutines, Language features, Object oriented languages, Concurrent programming structures, Language types, Software notations and tools, Parallel programming languages, Control structures, Distributed programming languages, General programming languages, Concurrent programming languages, Software and its engineering]
Combining the robustness of checked exceptions with the flexibility of unchecked exceptions using anchored exception declarations
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Ever since their invention 30 years ago, checked exceptions have been a point of much discussion. On the one hand, they increase the robustness of software by preventing the manifestation of unanticipated checked exceptions at run-time. On the other hand, they decrease the adaptability of software because they must be propagated explicitly, and must often be handled even if they cannot be signalled.We show that the problems with checked exceptions are caused by a lack of expressiveness of the exceptional return type of a method, which currently dictates a copy & paste style. We add the required expressiveness by introducing anchored exception declarations, which allow the exceptional behavior of a method to be declared relative to that of others. We present the formal semantics of anchored exception declarations, along with the necessary rules for ensuring compile-time safety, and give a proof of soundness. We show that anchored exception declarations do not violate the principle of information hiding when used properly, and provide a guideline for when to use them.We have implemented anchored exception declarations in Cappuccino, which is an extension to the ClassicJava programming language.
[Software creation and management, Language features, Software notations and tools, Software development techniques, Theory of computation, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Error handling and recovery, Software and its engineering]
Incrementalization across object abstraction
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Object abstraction supports the separation of what operations are provided by systems and components from how the operations are implemented, and is essential in enabling the construction of complex systems from components. Unfortunately, clear and modular implementations have poor performance when expensive query operations are repeated, while efficient implementations that incrementally maintain these query results are much more difficult to develop and to understand, because the code blows up significantly, and is no longer clear or modular.This paper describes a powerful and systematic method that first allows the "what" of each component to be specified in a clear and modular fashion and implemented straightforwardly in an object-oriented language; then analyzes the queries and updates, across object abstraction, in the straightforward implementation; and finally derives the sophisticated and efficient "how" of each component by incrementally maintaining the results of repeated expensive queries with respect to updates to their parameters. Our implementation and experimental results for example applications in query optimization, role-based access control, etc. demonstrate the effectiveness and benefit of the method.
[Source code generation, Software creation and management, Very high level languages, Reusability, Software notations and tools, Invariants, Theory of computation, Software implementation planning, Software development process management, Semantics and reasoning, Program reasoning, Software organization and properties, Software and its engineering, Software design techniques, Object oriented languages, Language types, Program analysis, Software architectures, Software development techniques, Software system structures, Designing software, General programming languages, Program semantics, Software libraries and repositories, Compilers]
PolyD: a flexible dispatching framework
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
The standard dispatching mechanisms built into programming languages are sometimes inadequate to the needs of the programmer. In the case of Java, the need for more flexibility has led to the development of a number of tools, including visitors and multi-method extensions, that each add some particular functionality, but lack the generality necessary to support user-defined dispatching mechanisms. In this paper we advocate a more modular approach to dispatching, and we present a tool, PolyD, that allows the programmer to design custom dispatching strategies and to parametrize many aspects of the dispatching process. PolyD exhibits excellent performance and compares well against existing tools.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Patterns, Software and its engineering]
Subtext: uncovering the simplicity of programming
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
Representing programs as text strings makes programming harder then it has to be. The source text of a program is far removed from its behavior. Bridging this conceptual gulf is what makes programming so inhumanly difficult -- we are not compilers. Subtext is a new medium in which the representation of a program is the same thing as its execution. Like a spreadsheet, a program is visible and alive, constantly executing even as it is edited. Program edits are coherent semantic transformations.The essence of this new medium is copying. Programs are constructed by copying and executed by copy flow: the projection of changes through copies. The simple idea of copying develops into a rich theory of higher-order continual copying of trees. Notably absent are symbolic names, the workhorse of textual notation, replaced by immediately-bound explicit relationships. Subtext unifies traditionally distinct programming tools and concepts, and enables some novel ones. Ancestral structures are a new primitive data type that combines the features of lists and records, along with unproblematic multiple inheritance. Adaptive conditionals use first-class program edits to dynamically adapt behavior.A prototype implementation shows promise, but calls for much further research. Subtext suggests that we can make programming radically easier, if we are willing to be radical.
[Visual languages, Context specific languages, Human-centered computing, Language types, Software notations and tools, Human computer interaction (HCI), Development frameworks and environments, Integrated and visual development environments, General programming languages, Functional languages, Interaction paradigms, Software and its engineering]
X10: an object-oriented approach to non-uniform cluster computing
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
It is now well established that the device scaling predicted by Moore's Law is no longer a viable option for increasing the clock frequency of future uniprocessor systems at the rate that had been sustained during the last two decades. As a result, future systems are rapidly moving from uniprocessor to multiprocessor configurations, so as to use parallelism instead of frequency scaling as the foundation for increased compute capacity. The dominant emerging multiprocessor structure for the future is a Non-Uniform Cluster Computing (NUCC) system with nodes that are built out of multi-core SMP chips with non-uniform memory hierarchies, and interconnected in horizontally scalable cluster configurations such as blade servers. Unlike previous generations of hardware evolution, this shift will have a major impact on existing software. Current OO language facilities for concurrent and distributed programming are inadequate for addressing the needs of NUCC systems because they do not support the notions of non-uniform data access within a node, or of tight coupling of distributed nodes.We have designed a modern object-oriented programming language, X10, for high performance, high productivity programming of NUCC systems. A member of the partitioned global address space family of languages, X10 highlights the explicit reification of locality in the form of places}; lightweight activities embodied in async, future, foreach, and ateach constructs; a construct for termination detection (finish); the use of lock-free synchronization (atomic blocks); and the manipulation of cluster-wide global data structures. We present an overview of the X10 programming model and language, experience with our reference implementation, and results from some initial productivity comparisons between the X10 and Java&#8482; languages.
[Language features, Object oriented languages, Concurrent programming structures, Computing methodologies, Language types, Parallel computing methodologies, Software notations and tools, Parallel programming languages, Distributed computing methodologies, Distributed programming languages, General programming languages, Concurrent programming languages, Software and its engineering]
A simple model of agile software processes -- or -- extreme programming annealed
Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications
ACM SIGPLAN Notices VOLUME 40 ISSUE 10
2005
None
[Software development process management, Software creation and management, Collaboration in software development, Programming teams, Software and its engineering]
Eliminating distinctions of class: using prototypes to model virtual classes
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
In mainstream OO languages, inheritance can be used to add new methods, or to override existing methods. Virtual classes and feature oriented programming are techniques which extend the mechanism of inheritance so that it is possible to refine nested classes as well. These techniques are attractive for programming in the large, because inheritance becomes a tool for manipulating whole class hierarchies rather than individual classes. Nevertheless, it has proved difficult to design static type systems for virtual classes, because virtual classes introduce dependent types. The compile-time type of an expression may depend on the run-time values of objects in that expression.We present a formal object calculus which implements virtual classes in a type-safe manner. Our type system uses a novel technique based on prototypes, which blur the distinction between compile-time and run-time. At run-time, prototypes act as objects, and they can be used in ordinary computations. At compile-time, they act as types. Prototypes are similar in power to dependent types, and subtyping is shown to be a form of partial evaluation. We prove that prototypes are type-safe but undecidable, and briefly outline a decidable semi-algorithm for dealing with them.
[Theory of computation, Semantics and reasoning, Program semantics, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
J&amp;: nested intersection for scalable software composition
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
This paper introduces a programming language that makes it convenient to compose large software systems, combining their features in a modular way. J& supports nested intersection, building on earlier work on nested inheritance in the language Jx. Nested inheritance permits modular, type-safe extension of a package (including nested packages and classes), while preserving existing type relationships. Nested intersection enables composition and extension of two or more packages, combining their types and behavior while resolving conflicts with a relatively small amount of code. The utility of J& is demonstrated by using it to construct two composable, extensible frameworks: a compiler framework for Java, and a peer-to-peer networking system. Both frameworks support composition of extensions. For example, two compilers adding different, domain-specific features to Java can be composed to obtain a compiler for a language that supports both sets of features.
[Classes and objects, General programming languages, Object oriented languages, Language features, Inheritance, Frameworks, Language types, Software notations and tools, Modules / packages, Software and its engineering]
Statically scoped object adaptation with expanders
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
This paper introduces the expander, a new object-oriented (OO) programming language construct designed to support object adaptation. Expanders allow existing classes to be noninvasively updated with new methods, fields, and superinterfaces. Each client can customize its view of a class by explicitly importing any number of expanders. This view then applies to all instances of that class, including objects passed to the client from other components. A form of expander overriding allows expanders to interact naturally with OO-style inheritance.We describe the design, implementation, and evaluation of eJava, an extension to Java supporting expanders. We illustrate eJava's syntax and semantics through several examples. The statically scoped nature of expander usage allows for a modular static type system that prevents several important classes of errors. We describe this modular static type system informally, formalize eJava and its type system in an extension to Featherweight Java, and prove a type soundness theorem for the formalization. We also describe a modular compilation strategy for eJava, which we have implemented using the Polyglot extensible compiler framework. Finally, we illustrate the practical benefits of eJava by using this compiler in two experiments.
[Classes and objects, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
A framework for implementing pluggable type systems
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Pluggable types have been proposed to support multiple type systems in the same programming language. We have designed and implemented J<sc>ava</sc>COP, a program constraint system for implementing practical pluggable type systems for Java. J<sc>ava</sc>COP enforces user-defined typing constraints written in a declarative and expressive rule language. We have validated our design by (re)implementing a range of type systems and program checkers. By using a program constraint system to implement pluggable types, programmers are able to check that their programs will operate correctly in restricted environments, adhere to strict programming rules, avoid null pointer errors or scoped memory exceptions, and meet style guidelines, while programming language researchers can easily experiment with novel type systems.
[Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
Design fragments make using frameworks easier
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Object oriented frameworks impose additional burdens on programmers that libraries did not, such as requiring the programmer to understand the method callback sequence, respecting behavior constraints within these methods, and devising solutions within a constrained solution space. To overcome these burdens, we express the repeated patterns of engagement with the framework as a design fragment. We analyzed the 20 demo applets provided by Sun and created a representative catalog of design fragments of conventional best practice. By evaluating 36 applets pulled from the internet we show that these design fragments are common, many applets copied the structure of the Sun demos, and that creation of a catalog of design fragments is practical. Design fragments give programmers immediate benefit through tool-based conformance assurance and long-term benefit through expression of design intent.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Reusability, Software notations and tools, Software development techniques, Software libraries and repositories, Software and its engineering]
Adapting virtual machine techniques for seamless aspect support
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Current approaches to compiling aspect-oriented programs are inefficient. This inefficiency has negative effects on the productivity of the development process and is especially prohibitive for dynamic aspect deployment. In this work, we present how well-known virtual machine techniques can be used with only slight modifications to support fast aspect deployment while retaining runtime performance. Our implementation accelerates dynamic aspect deployment by several orders of magnitude relative to mainstream aspect-oriented environments. We also provide a detailed comparison of alternative implementations of execution environments with support for dynamic aspect deployment.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Efficient control flow quantification
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Aspect-oriented programming (AOP) is increasingly gaining in popularity. However, the focus of aspect-oriented language research has been mostly on language design issues; efficient implementation techniques have been less popular. As a result, the performance of certain AOP constructs is still poor. This is in particular true for constructs that rely on dynamic properties of the execution (e.g., the cflow construct).In this paper, we present efficient implementation techniques for cflow that exploit direct access to internal structures of the virtual machine running an application, such as the call stack, as well as the integration of these techniques into the just-in-time compiler code generation process.Our results show that AOP has the potential to make programs that need to define control flow-dependent behavior not only more modular but also more efficient. By making means for control flow-dependent behavior part of the language, AOP opens the possibility of applying sophisticated compiler optimizations that are out of reach for application programmers.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Uniform proxies for Java
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
The proxy abstraction has a longlasting tradition in object settings. From design pattern to inherent language support, from remote method invocations to simple forms of behavioral reflection - incarnations as well as applications of proxies are innumerable.Since version 1.3, Java supports the concept of dynamic proxy. Such an object conforms to a set of types specified by the program and can be used wherever an expression of any of these types is expected, yet reifies invocations performed on it. Dynamic proxies have been applied to implement paradigms as diverse as behavioral reflection, structural conformance, or multi-methods. Alas, these proxies are only available "for interfaces". The case of creating dynamic proxies for a set of types including a class type has not been considered, meaning that it is currently not possible to create a dynamic proxy mimicking an instance of a given class. This weakness strongly limits any application of dynamic proxies.In this paper we unfold the current support for dynamic proxies in Java, assessing it in the light of a set of generic criteria for proxy implementations. We present an approach to supporting dynamic proxies "for classes" in Java, consisting in transformations performed on classes at load-time, including a generic scheme for enforcing encapsulation upon field accesses. These transformations seemlessly extend the scope of the current support for dynamic proxies. We discuss the precise benefits and costs of our extension in terms of the criteria introduced, and illustrate the usefulness of uniformly available proxies by implementing future method invocations both safely and transparently.
[Classes and objects, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Javana: a system for building customized Java program analysis tools
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Understanding the behavior of applications running on high-level language virtual machines, as is the case in Java, is non-trivial because of the tight entanglement at the lowest execution level between the application and the virtual machine. This paper proposes Javana, a system for building Java program analysis tools. Javana provides an easy-to-use instrumentation infrastructure that allows for building customized profiling tools very quickly.Javana runs a dynamic binary instrumentation tool underneath the virtual machine. The virtual machine communicates with the instrumentation layer through an event handling mechanism for building a vertical map that links low-level native instruction pointers and memory addresses to high-level language concepts such as objects, methods, threads, lines of code, etc. The dynamic binary instrumentation tool then intercepts all memory accesses and instructions executed and provides the Javana end user with high-level language information for all memory accesses and natively executed instructions.We demonstrate the power of Javana through a number of applications: memory address tracing, vertical cache simulation and object lifetime computation. For each of these applications, the instrumentation specification requires only a small number of lines of code. Developing similarly powerful profiling tools within a virtual machine (as done in current practice) is both time-consuming and error-prone; in addition, the accuracy of the obtained profiling results might be questionable as we show in this paper.
[Traceability, Software creation and management, Software verification and validation, Process validation, Software notations and tools, Runtime environments, Software and its engineering, Compilers]
The DaCapo benchmarks: java benchmarking development and analysis
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Since benchmarks drive computer science research and industry product development, which ones we use and how we evaluate them are key questions for the community. Despite complex runtime tradeoffs due to dynamic compilation and garbage collection required for Java programs, many evaluations still use methodologies developed for C, C++, and Fortran. SPEC, the dominant purveyor of benchmarks, compounded this problem by institutionalizing these methodologies for their Java benchmark suite. This paper recommends benchmarking selection and evaluation methodologies, and introduces the DaCapo benchmarks, a set of open source, client-side Java benchmarks. We demonstrate that the complex interactions of (1) architecture, (2) compiler, (3) virtual machine, (4) memory management, and (5) application require more extensive evaluation than C, C++, and Fortran which stress (4) much less, and do not require (3). We use and introduce new value, time-series, and statistical metrics for static and dynamic properties such as code complexity, code size, heap composition, and pointer mutations. No benchmark suite is definitive, but these metrics show that DaCapo improves over SPEC Java in a variety of ways, including more complex code, richer object behaviors, and more demanding memory system requirements. This paper takes a step towards improving methodologies for choosing and evaluating benchmarks to foster innovation in system design and implementation for Java and other managed languages.
[Measurement, Cross-computing tools and techniques, Metrics, General and reference]
Virgil: objects on the head of a pin
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Embedded microcontrollers are becoming increasingly prolific, serving as the primary or auxiliary processor in products and research systems from microwaves to sensor networks. Microcontrollers represent perhaps the most severely resource-constrained embedded processors, often with as little as a few bytes of memory and a few kilobytes of code space. Language and compiler technology has so far been unable to bring the benefits of modern object-oriented languages to such processors. In this paper, I will present the design and implementation of Virgil, a lightweight object-oriented language designed with careful consideration for resource-limited domains. Virgil explicitly separates initialization time from runtime, allowing an application to build complex data structures during compilation and then run directly on the bare hardware without a virtual machine or any language runtime. This separation allows the entire program heap to be available at compile time and enables three new data-sensitive optimizations: reachable members analysis, reference compression, and ROM-ization. Experi-mental results demonstrate that Virgil is well suited for writing microcontroller programs, with five demonstrative applications fitting in less than 256 bytes of RAM with fewer than 50 bytes of metadata. Further results show that the optimizations presented in this paper reduced code size between 20% and 80% and RAM size by as much as 75%.
[Classes and objects, Language features, Inheritance, Software notations and tools, Contextual software domains, Dynamic compilers, Operating systems, General programming languages, Memory management, Software organization and properties, Software and its engineering, Compilers]
Declarative, formal, and extensible syntax definition for aspectJ
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Aspect-Oriented Programming (AOP) is attracting attention from both research and industry, as illustrated by the ever-growing popularity of AspectJ, the de facto standard AOP extension of Java. From a compiler construction perspective AspectJ is interesting as it is a typical example of compositional language, ie a language composed of a number of separate languages with different syntactical styles: in addition to plain Java, AspectJ includes a language for defining pointcuts and one for defining advices. Language composition represents a non-trivial challenge for conventional parsing techniques. First, combining several languages with different lexical syntax leads to considerable complexity in the lexical states to processed. Second, as new language features for AOP are being explored, many research proposals are concerned with further extending the AspectJ language, resulting in a need for an extensible syntax definition.This paper shows how scannerless parsing elegantly addresses the issues encountered by conventional techniques when parsing AspectJ . We present the design of a modular, extensible, and formal definition of the lexical and context-free aspects of the AspectJ syntax in the Syntax Definition Formalism SDF, which is implemented by a scannerless, generalized-LR parser (SGLR). We introduce grammar mixins as a novel application of SDF's modularity features, which allows the declarative definition of different keyword policies and combination of extensions. We illustrate the modular extensibility of our definition with syntax extensions taken from current research on aspect languages. Finally, benchmarks show the reasonable performance of scannerless generalized-LR parsing for this grammar.
[Theory of computation, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering, Compilers]
Method-specific dynamic compilation using logistic regression
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Determining the best set of optimizations to apply to a program has been a long standing problem for compiler writers. To reduce the complexity of this task, existing approaches typically apply the same set of optimizations to all procedures within a program, without regard to their particular structure. This paper develops a new method-specific approach that automatically selects the best optimizations on a per method basis within a dynamic compiler. Our approach uses the machine learning technique of logistic regression to automatically derive a predictive model that determines which optimizations to apply based on the features of a method. This technique is implemented in the Jikes RVM Java JIT compiler. Using this approach we reduce the average total execution time of the SPECjvm98 benchmarks by 29%. When the same heuristic is applied to the DaCapo+ benchmark suite, we obtain an average 33% reduction over the default level O2 setting.
[Logical and relational learning, Inductive logic learning, General programming languages, Machine learning, Computing methodologies, Machine learning approaches, Software notations and tools, Software and its engineering, Compilers]
Replay compilation: improving debuggability of a just-in-time compiler
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
The performance of Java has been tremendously improved by the advance of Just-in-Time (JIT) compilation technologies. However, debugging such a dynamic compiler is much harder than a static compiler. Recompiling the problematic method to produce a diagnostic output does not necessarily work as expected, because the compilation of a method depends on runtime information at the time of compilation.In this paper, we propose a new approach, called replay JIT compilation, which can reproduce the same compilation remotely by using two compilers, the state-saving compiler and the replaying compiler. The state-saving compiler is used in a normal run, and, while compiling a method, records into a log all of the input for the compiler. The replaying compiler is then used in a debugging run with the system dump, to recompile a method with the options for diagnostic output. We reduced the overhead to save the input by using the system dump and by categorizing the input based on how its value changes. In our experiment, the increase of the compilation time for saving the input was only 1%, and the size of the additional memory needed for saving the input was only 10% of the compiler-generated code.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software notations and tools, Software and its engineering, Compilers]
A flexible framework for implementing software transactional memory
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
We describe DSTM2, a Java&#8482; software library that provides a flexible framework for implementing object-based software transactional memory (STM). The library uses transactional factories to transform sequential (unsynchronized) classes into atomic (transactionally synchronized) ones, providing a substantial improvement over the awkward programming interface of our previous DSTM library. Furthermore, researchers can experiment with alternative STM mechanisms by providing their own factories. We demonstrate this flexibility by presenting two factories: one that uses essentially the same mechanisms as the original DSTM (with some enhancements),and another that uses a completely different approach.Because DSTM2 is packaged as a Java library, a wide range of programmers can easily try it out, and the community can begin to gain experience with transactional programming. Furthermore, researchers will be able to use the body of transactional programs that arises from this community experience to test and evaluate different STM mechanisms simply by supplying new transactional factories. We believe that this flexible approach will help to build consensus about the best ways to implement transactions, and will avoid the premature "lock-in" that may arise if STM mechanisms are baked into compilers before such experimentation is done.
[Language features, Object oriented languages, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software architectures, Theory of computation, Models of computation, Software system structures, General programming languages, Concurrency, Software organization and properties, Software and its engineering, Parallel computing models]
Eliminating synchronization-related atomic operations with biased locking and bulk rebiasing
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
The Java&#8482; programming language contains built-in synchronization primitives for use in constructing multithreaded programs. Efficient implementation of these synchronization primitives is necessary in order to achieve high performance.Recent research [9, 12, 10, 3, 7] has focused on the run-time elimination of the atomic operations required to implement object monitor synchronization primitives. This paper describes a novel technique called store-free biased locking which eliminates all synchronization-related atomic operations on uncontended object monitors. The technique supports the bulk transfer of object ownership from one thread to another, and the selective disabling of the optimization where unprofitable, using epoch-based bulk rebiasing and revocation. It has been implemented in the production version of the Java HotSpot&#8482;VM and has yielded significant performance improvements on a range of benchmarks and applications. The technique is applicable to any virtual machine-based programming language implementation with mostly block-structured locking primitives.
[Software notations and tools, Software and its engineering, Compilers]
A flow-based approach for variant parametric types
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
A promising approach for type-safe generic codes in the object-oriented paradigm is variant parametric type, which allows covariant and contravariant subtyping on fields where appropriate. Previous approaches formalise variant type as a special case of the existential type system. In this paper, we present a new framework based on flow analysis and modular type checking to provide a simple but accurate model for capturing generic types. Our scheme stands to benefit from past (and future) advances in flow analysis and subtyping constraints. Furthermore, it fully supports casting for variant types with a special reflection mechanism, called cast capture, to handle objects with unknown types. We have built a constraint-based type checker and have proven its soundness. We have also successfully annotated a suite of Java libraries and client code with our flow-based variant type system.
[Classes and objects, Language features, Object oriented languages, Language types, Software notations and tools, Formal languages and automata theory, Program constructs, Object oriented constructs, Theory of computation, Semantics and reasoning, Constraints, General programming languages, Formal language definitions, Type structures, Software and its engineering, Polymorphism]
Concepts: linguistic support for generic programming in C++
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Generic programming has emerged as an important technique for the development of highly reusable and efficient software libraries. In C++, generic programming is enabled by the flexibility of templates, the C++ type parametrization mechanism. However, the power of templates comes with a price: generic (template) libraries can be more difficult to use and develop than non-template libraries and their misuse results in notoriously confusing error messages. As currently defined in C++98, templates are unconstrained, and type-checking of templates is performed late in the compilation process, i.e., after the use of a template has been combined with its definition. To improve the support for generic programming in C++, we introduce concepts to express the syntactic and semantic behavior of types and to constrain the type parameters in a C++ template. Using concepts, type-checking of template definitions is separated from their uses, thereby making templates easier to use and easier to compile. These improvements are achieved without limiting the flexibility of templates or decreasing their performance - in fact their expressive power is increased. This paper describes the language extensions supporting concepts, their use in the expression of the C++ Standard Template Library, and their implementation in the ConceptGCC compiler. Concepts are candidates for inclusion in the upcoming revision of the ISO C++ standard, C++0x.
[General programming languages, Language features, Software notations and tools, Abstract data types, Software libraries and repositories, Software and its engineering, Polymorphism]
Generic ownership for generic Java
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Ownership types enforce encapsulation in object-oriented programs by ensuring that objects cannot be leaked beyond object(s) that own them. Existing ownership programming languages either do not support parametric polymorphism (type genericity) or attempt to add it on top of ownership restrictions. Generic Ownership provides per-object ownership on top of a sound generic imperative language. The resulting system not only provides ownership guarantees comparable to established systems, but also requires few additional language mechanisms due to full reuse of parametric polymorphism. We formalise the core of Generic Ownership, highlighting that only restriction of this calls and owner subtype preservation are required to achieve deep ownership. Finally we describe how Ownership Generic Java (OGJ) was implemented as a minimal extension to Generic Java in the hope of bringing ownership types into mainstream programming.
[Classes and objects, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering, Polymorphism]
A formal framework for component deployment
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Software deployment is a complex process, and industrial-strength frameworks such as .NET, Java, and CORBA all provide explicit support for component deployment. However, these frameworks are not built around fundamental principles as much as they are engineering efforts closely tied to particulars of the respective systems. Here we aim to elucidate the fundamental principles of software deployment, in a platform-independent manner. Issues that need to be addressed include deployment unit design, when, where and how to wire components together, versioning, version dependencies, and hot-deployment of components. We define the application buildbox as the place where software is developed and deployed, and define a formal Labeled Transition System (LTS) on the buildbox with transitions for deployment operations that include build, install, ship, and update. We establish formal properties of the LTS, including the fact that if a component is shipped with a certain version dependency, then at run time that dependency must be satisfied with a compatible version. Our treatment of deployment is both platform- and vendor-independent, and we show how it models the core mechanisms of the industrial-strength deployment frameworks.
[Theory of computation, Software configuration management and version control systems, Software creation and management, Software version control, Formal language definitions, Software notations and tools, Software post-development issues, Formal languages and automata theory, Software and its engineering]
An operational semantics and type safety prooffor multiple inheritance in C++
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
We present an operational semantics and type safety proof for multiple inheritance in C++. The semantics models the behaviour of method calls, field accesses, and two forms of casts in C++ class hierarchies exactly, and the type safety proof was formalized and machine-checked in Isabelle/HOL. Our semantics enables one, for the first time, to understand the behaviour of operations on C++ class hierarchies without referring to implementation-level artifacts such as virtual function tables. Moreover, it can - as the semantics is executable - act as a reference for compilers, and it can form the basis for more advanced correctness proofs of, e.g., automated program transformations. The paper presents the semantics and type safety proof, and a discussion of the many subtleties that we encountered in modeling the intricate multiple inheritance model of C++.
[Operational semantics, Language features, Inheritance, Software notations and tools, Program constructs, Theory of computation, Semantics and reasoning, Semantics, General programming languages, Program semantics, Formal language definitions, Type structures, Software and its engineering]
Efficient software model checking of data structure properties
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
This paper presents novel language and analysis techniques that significantly speed up software model checking of data structure properties. Consider checking a red-black tree implementation. Traditional software model checkers systematically generate all red-black tree states (within some given bounds) and check every red-black tree operation (such as insert, delete, or lookup) on every red-black tree state. Our key idea is as follows. As our checker checks a red-black tree operation o on a red-black tree state s, it uses program analysis techniques to identify other red-black tree states s'<sub>1</sub>, s'<sub>2</sub>, ..., s'<sub>k</sub> on which the operation o behaves similarly. Our analyses guarantee that if o executes correctly on s, then o will execute correctly on every s'<sub>i</sub>. Our checker therefore does not need to check o on any s'<sub>i</sub> once it checks o on s. It thus safely prunes those state transitions from its search space, while still achieving complete test coverage within the bounded domain. Our preliminary results show orders of magnitude improvement over previous approaches. We believe our techniques can make model checking significantly faster, and thus enable checking of much larger programs and complex program properties than currently possible.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Isolating and relating concerns in requirements using latent semantic analysis
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Aspect-oriented requirements analysis involves the identification of concerns that behaviorally influence other concerns. Such concerns are described in requirements called emphaspectual requirements: requirements that detail the influence of one concern over another. The current state of the art for aspect-oriented requirements analysis is Theme/Doc, which allows lexical analysis of requirements based on a set of developer-chosen keywords. It provides a graphical depiction of how concerns relate to requirements, and affords identification of potential aspectual requirements. In addition, clusters of requirements and concerns are identified to arrive at a more useful set of concerns than those initially identified.Because of the lexical nature of the Theme/Doc approach, aspectual requirements are missed, or wrongly identified. Additionally, requirements may be wrongly clustered if they contain ambiguous terms.In this work we explored whether the use of a statistical approach for textual analysis, Latent Semantic Analysis (LSA), would improve upon the lexical approach used by Theme/Doc. We found that LSA helps identify useful concern clusters, and helps reduce the number of falsely identified aspectual requirements.
[Designing software, Requirements analysis, Software creation and management, Software and its engineering]
Understanding the shape of Java software
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Large amounts of Java software have been written since the language's escape into unsuspecting software ecology more than ten years ago. Surprisingly little is known about the structure of Java programs in the wild: about the way methods are grouped into classes and then into packages, the way packages relate to each other, or the way inheritance and composition are used to put these programs together. We present the results of the first in-depth study of the structure of Java programs. We have collected a number of Java programs and measured their key structural attributes. We have found evidence that some relationships follow power-laws, while others do not. We have also observed variations that seem related to some characteristic of the application itself. This study provides important information for researchers who can investigate how and why the structural relationships we find may have originated, what they portend, and how they can be managed.
[Software creation and management, Reusability, General programming languages, Object oriented languages, Language types, Software notations and tools, Software product lines, Software development techniques, Software and its engineering]
XSnippet: mining For sample code
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
It is common practice for software developers to use examples to guide development efforts. This largely unwritten, yet standard, practice of "develop by example" is often supported by examples bundled with library or framework packages, provided in textbooks, and made available for download on both official and unofficial web sites. However, the vast number of examples that are embedded in the billions of lines of already developed library and framework code are largely untapped. We have developed XSnippet, a context-sensitive code assistant framework that allows developers to query a sample repository for code snippets that are relevant to the programming task at hand. In particular, our work makes three primary contributions. First, a range of queries is provided to allow developers to switch between a context-independent retrieval of code snippets to various degrees of context-sensitive retrieval for object instantiation queries. Second, a novel graph-based code mining algorithm is provided to support the range of queries and enable mining within and across method boundaries. Third, an innovative context-sensitive ranking heuristic is provided that has been experimentally proven to provide better ranking for best-fit code snippets than context-independent heuristics such as shortest path and frequency. Our experimental evaluation has shown that XSnippet has significant potential to assist developers, and provides better coverage of tasks and better rankings for best-fit snippets than other code assistant systems.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Development frameworks and environments, Software and its engineering]
Conscientious software
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Software needs to grow up and become responsible for itself and its own future by participating in its own installation and customization, maintaining its own health, and adapting itself to new circumstances, new users, and new uses. To create such software will require us to change some of our underlying assumptions about how we write programs. A promising approach seems to be to separate software that does the work (allopoietic)from software that keeps the system alive (autopoietic).
[Software system structures, Software creation and management, General programming languages, Human-centered computing, Error handling and recovery, Software notations and tools, Human computer interaction (HCI), Software development techniques, Software architectures, Software organization and properties, Software and its engineering]
Intentional software
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Wysiwyg editors simplified document creation by separating the document contents from the looks and by automating the re-application of the looks to changing contents. In the same way Intentional Software simplifies software creation by separating the software contents in terms of their various domains from the implementation of the software and by enabling automatic re-generation of the software as the contents change. This way, domain experts can work in parallel with programmers in their respective areas of expertise; and the repeated intermingling can be automated. Intentional Software is supported by a Domain Workbench tool where multiple domains can be defined, created, edited, transformed and integrated during software creation. Key features include a uniform representation of multiple interrelated domains, the ability to project the domains in multiple editable notations, and simple access for a program generator.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, General programming languages, Language features, Software notations and tools, Software and its engineering]
On system design
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
In this essay, I consider some of the factors that are making it more and more difficult to expend the effort necessary to do system design. Because of changes in the economics of the field in both industry and research, we have become less able to take the time needed to do real system design, and to train the next generation of designers. Because of the intellectual property landscape, we are less able to discuss system design. The end result is that we do less good system design than we used to, at least in those environments where system design used to be most common. But there are reasons to be optimistic about the future of system design, which appears to be happening in non-traditional ways and in non-traditional venues.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software system structures, Software creation and management, Software architectures, Software organization and properties, Software and its engineering]
The paradoxical success of aspect-oriented programming
Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications
ACM SIGPLAN Notices VOLUME 41 ISSUE 10
2006
Aspect-oriented programming is considered a promising new technology. As object-oriented programming did before, it is beginning to pervade all areas of software engineering. With its growing popularity, practitioners and academics alike are wondering whether they should start looking into it, or otherwise risk having missed an important development. The author of this essay finds that much of aspect-oriented programming's success seems to be based on the conception that it improves both modularity and the structure of code, while in fact, it works against the primary purposes of the two, namely independent development and understandability of programs. Not seeing any way of fixing this situation, he thinks the success of aspect-oriented programming to be paradoxical.
[Control structures, Procedures, functions and subroutines, General programming languages, Language features, Multiparadigm languages, Language types, Software notations and tools, Modules / packages, Software and its engineering]
The jastadd extensible java compiler
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
The JastAdd Extensible Java Compiler is a high quality Java compiler that is easy to extend in order to build static analysis tools for Java, and to extend Java with new language constructs. It is built modularly, with a Java 1.4 compiler that is extended to a Java 5 compiler. Example applications that are built as extensions include an alternative backend that generates Jimple, an extension of Java with AspectJ constructs, and the implementation of a pluggable type system for non-null checking and inferenc. The system is implemented using JastAdd, a declarative Java-like language. We describe the compiler architecture, the major design ideas for building and extending the compiler, in particular, for dealing with complex extensions that affect name and type analysis. Our extensible compiler compares very favorably concerning quality, speed and size with other extensible Java compiler frameworks. It also compares favorably in quality and size compared with traditional non-extensible Java compilers, and it runs within a factor of three compared to javac.
[Software notations and tools, Software and its engineering, Compilers]
Jeannie: granting java native interface developers their wishes
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Higher-level languages interface with lower-level languages such as C to access platform functionality, reuse legacy libraries, or improve performance. This raises the issue of how to best integrate different languages while also reconciling productivity, safety, portability, and efficiency. This paper presents Jeannie, a new language design for integrating Java with C. In Jeannie, both Javaand C code are nested within each other in the same file and compile down to JNI, the Java platform's standard foreign function interface. By combining the two languages' syntax and semantics, Jeannie eliminates verbose boiler-plate code, enables static error detection across the language boundary, and simplifies dynamic resource management. We describe the Jeannie language and its compiler, while also highlighting lessons from composing two mature programming languages.
[General programming languages, Language features, Software notations and tools, Extra-functional properties, Interoperability, Software organization and properties, Software and its engineering, Compilers]
Ilea: inter-language analysis across java and c
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Java bug finders perform static analysis to find implementation mistakes that can lead to exploits and failures; Java compilers perform static analysis for optimization.allIf Java programs contain foreign function calls to C libraries, however, static analysis is forced to make either optimistic or pessimistic assumptions about the foreign function calls, since models of the C libraries are typically not available. We propose ILEA (stands for Inter-LanguagE Analysis), which is a framework that enables existing Java analyses to understand the behavior of C code. Our framework includes: (1) a novel specification language, which extends the Java Virtual Machine Language (JVML) with a few primitives that approximate the effects that the C code might have; (2) an automatic specification extractor, which builds models of the C code. Comparing to other possible specification languages, our language is expressive, yet facilitates construction of automatic specification extractors. Furthermore, because the specification language is based on the JVML, existing Java analyses can be easily migrated to utilize specifications in the language. We also demonstrate the utility of the specifications generated, by modifying an existing non-null analysis to identify null-related bugs in Java applications that contain C libraries. Our preliminary experiments identified dozens of null-related bugs.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering, Compilers]
Statistically rigorous java performance evaluation
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Java performance is far from being trivial to benchmark because it is affected by various factors such as the Java application, its input, the virtual machine, the garbage collector, the heap size, etc. In addition, non-determinism at run-time causes the execution time of a Java program to differ from run to run. There are a number of sources of non-determinism such as Just-In-Time (JIT) compilation and optimization in the virtual machine (VM) driven by timer-based method sampling, thread scheduling, garbage collection, and various. There exist a wide variety of Java performance evaluation methodologies usedby researchers and benchmarkers. These methodologies differ from each other in a number of ways. Some report average performance over a number of runs of the same experiment; others report the best or second best performance observed; yet others report the worst. Some iterate the benchmark multiple times within a single VM invocation; others consider multiple VM invocations and iterate a single benchmark execution; yet others consider multiple VM invocations and iterate the benchmark multiple times. This paper shows that prevalent methodologies can be misleading, and can even lead to incorrect conclusions. The reason is that the data analysis is not statistically rigorous. In this paper, we present a survey of existing Java performance evaluation methodologies and discuss the importance of statistically rigorous data analysis for dealing with non-determinism. We advocate approaches to quantify startup as well as steady-state performance, and, in addition, we provide the JavaStats software to automatically obtain performance numbers in a rigorous manner. Although this paper focuses on Java performance evaluation, many of the issues addressed in this paper also apply to other programming languages and systems that build on a managed runtime system.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software notations and tools, Runtime environments, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering, Compilers]
Microphase: an approach to proactively invoking garbage collection for improved performance
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
To date, the most commonly used criterion for invoking garbage collection (GC) is based on heap usage; that is, garbage collection is invoked when the heap or an area inside the heap is full. This approach can suffer from two performance shortcomings: untimely garbage collection invocations and large volumes of surviving objects. In this work, we explore a new GC triggering approach called MicroPhase that exploits two observations: (i) allocation requests occur in phases and (ii) phase boundaries coincide with times when most objects also die. Thus, proactively invoking garbage collection at these phase boundaries can yield high efficiency. We extended the HotSpot virtual machine from Sun Microsystems to support MicroPhase and conducted experiments using 20 benchmarks. The experimental results indicate that our technique can reduce the GC times in 19 applications. The differences in GC overhead range from an increase of 1% to a decrease of 26% when the heap is set to twice the maximum live-size. As a result, MicroPhase can improve the overall performance of 13 benchmarks. The performance differences range from a degradation of 2.5% to an improvement of 14%.
[Garbage collection, Operating systems, Memory management, Software notations and tools, Runtime environments, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Variant path types for scalable extensibility
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Much recent work in the design of object-oriented programming languages has been focusing on identifying suitable features to support so-called scalable extensibility, where the usual extension mechanism by inheritance works in different scales of software components-that is, classes, groups of classes, groups of groups and so on. Its typing issues has usually been addressed by means of dependent type systems, where nested types are seen as properties of objects. In this work, we seek instead for a different solution, which can bemore easily applied to Java-like languages, in which nested types are considered properties of classe. We introduce the mechanism of variant path types, which provide a flexible means to express intra-group relationship (among classes) that has to be preserved through extension. In particular, improving and extending existing works on groups and exact types, we feature the new notions of exact and inexact qualifications, providing rich abstractions to express various kinds of set of objects, with a flexible subtyping scheme. We formalize a safe type system for variant path types on top of Feather weight Java. Our development results in a complete solution for scalable extensibility, similarly to previous attempts based on dependent type systems.
[Classes and objects, Language features, Object oriented languages, Language types, Software notations and tools, Program constructs, Object oriented constructs, Theory of computation, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Type structures, Software and its engineering, Polymorphism]
Dependent classes
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Virtual classes allow nested classes to be refined in subclasses. In this way nested classes can be seen as dependent abstractions of the objects of the enclosing classes. Expressing dependency via nesting, however, has two limitations: Abstractions that depend on more than one object cannot be modeled and a class must know all classes that depend on its objects. This paper presents dependent classes, a generalization of virtual classes that expresses similar semantics by parameterization rather than by nesting. This increases expressivity of class variations as well as the flexibility of their modularization. Besides, dependent classes complement multimethods in scenarios where multi-dispatched abstractions rather than multi-dispatched methods are needed. They can also be used to express more precise signatures of multimethods and even extend their dispatch semantics. We present a formal semantics of dependent classes and a machine-checked type soundness proof in Isabelle/HOL [29], the first of this kind for a language with virtual classes and path-dependent types.
[Theory of computation, Classes and objects, Semantics and reasoning, Operational semantics, General programming languages, Language features, Program semantics, Software notations and tools, Software and its engineering, Polymorphism]
Component nextgen: a sound and expressive component framework for java
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Developing a general component system for a statically typed, object-oriented language is a challenging design problem for two reasons. First, mutually recursive references across components are common in object-oriented programs-an issue that has proven troublesome in the context of component systems for functional and procedural languages. Second, inheritance across component boundaries can cause accidental method overrides. Our recent research shows that a component framework can be constructed for a nominally typed object-oriented language supporting first-class generic types simply by adding appropriate annotations, syntactic sugar, and component-level type-checking. The fundamental semantic building blocks for constructing, type-checking and manipulating components are provided by the underlying first-class generic type system. To demonstrate the simplicity and utility of this approach we have designed and implemented an extension of Java called Component NEXTGEN (CGEN). CGEN, which is based on the Sun Java 5.0 javac compiler, is backwards compatible with existing Java binary code and runs on current Java Virtual Machines. The primary contribution of this paper is a technical analysis of the subtle design issues involved in building a component framework for a nominally typed object-oriented language supporting first-class generics. In contrast to component systems for structurally typed languages, mutual recursion among components is accommodated in the type system and semantics without incorporating any special machinery. Our analysis includes a presentation of Core CGEN (CCG), a small, core language modeling the CGEN framework. It is based on Featherweight GJ and incorporates some ideas from MIXGEN. CCG adds the essential features to support components, but nothing more. Our discussion includes the type rules and semantics for CCG, as well as a proof of type safety.
[Classes and objects, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Modules / packages, Software and its engineering, Polymorphism]
User-changeable visibility: resolving unanticipated name clashes in traits
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method m is composed with another trait defining a different method m then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present freezeable traits, which provide an expressive composition mechanism to support unanticipated method composition conflicts. Our solution introduces private trait methods and lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.
[Classes and objects, General programming languages, Language features, Inheritance, Software notations and tools, Software and its engineering]
Transactions with isolation and cooperation
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
We present the TIC (Transactions with Isolation and Cooperation) model for concurrent programming. TIC adds to standard transactional memory the ability for a transaction to observe the effects of other threads at selected points. This allows transactions to cooperate, as well as to invoke nonrepeatable or irreversible operations, such as I/O. Cooperating transactions run the danger of exposing intermediate state and of having other threads change the transaction's state. The TIC model protects against unanticipated interference by having the type system keep track of all operations that may (transitively) violate the atomicity of a transaction and require the programmer to establish consistency at appropriate points. The result is a programming model that is both general and simple. We have used the TIC model to re-engineer existing lock-based applications including a substantial multi-threaded web mail server and a memory allocator with coarse-grained locking. Our experience confirms the features of the TIC model: It is convenient for the programmer, while maintaining the benefits of transactional memory.
[Computer systems organization, General programming languages, Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Streamflex: high-throughput stream programming in java
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
The stream programming paradigm aims to expose coarse-grained parallelism inapplications that must process continuous sequences of events. The appeal ofstream programming comes from its conceptual simplicity. A program is acollection of independent filters which communicate by the means ofuni-directional data channels. This model lends itself naturally toconcurrent and efficient implementations on modern multiprocessors. As theoutput behavior of filters is determined by the state of their inputchannels, stream programs have fewer opportunities for the errors (such asdata races and deadlocks) that plague shared memory concurrent programming. This paper introduces S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt;, an extension to Java which marries streams with objects and thus enables to combine, in the same Java virtual machine, stream processing code with traditional object-oriented components. S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt; targets high-throughput low-latency applications with stringent quality-of-service requirements. To achieve these goals, it must, at the same time, extend and restrict Java. To allow for program optimization and provide latency guarantees, the S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt; compiler restricts Java by imposing a stricter typing discipline on filters. On the other hand, S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt; extends the Java virtual machine with real-time capabilities, transactional memory and type-safe region-based allocation. The result is a rich and expressive language that can be implemented efficiently.
[Classes and objects, General programming languages, Language features, Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Can programming be liberated from the two-level style: multi-level programming with deepjava
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Since the introduction of object-oriented programming few programming languages have attempted to provide programmers with more than objects and classes, i.e., more than two levels. Those that did, almost exclusively aimed at describing language properties-i.e., their metaclasses exert linguistic control on language concepts and mechanisms-often in order to make the language extensible. In terms of supporting logical domain classification levels, however, they are still limited to two levels. In this paper we conservatively extend the object-oriented programming paradigm to feature an unbounded number of domain classification levels. We can therefore avoid the introduction of accidental complexity into programs caused by accommodating multiple domain levels within only two programming levels. We present a corresponding language design featuring ``deep instantiation'' and demonstrate its features with a running example. Finally, we outline the implementation of our compiler prototype and discuss the potentials of further developing our language design.
[Classes and objects, Extensible languages, General programming languages, Language features, Language types, Software notations and tools, Software and its engineering]
The causes of bloat, the limits of health
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Applications often have large runtime memory requirements. In some cases, large memory footprint helps accomplish an important functional, performance, or engineering requirement. A large cache,for example, may ameliorate a pernicious performance problem. In general, however, finding a good balance between memory consumption and other requirements is quite challenging. To do so, the development team must distinguish effective from excessive use of memory. We introduce health signatures to enable these distinctions. Using data from dozens of applications and benchmarks, we show that they provide concise and application-neutral summaries of footprint. We show how to use them to form value judgments about whether a design or implementation choice is good or bad. We show how being independent ofany application eases comparison across disparate implementations. We demonstrate the asymptotic nature of memory health: certain designsare limited in the health they can achieve, no matter how much the data size scales up. Finally, we show how to use health signatures to automatically generate formulas that predict this asymptotic behavior, and show how they enable powerful limit studies on memory health.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
Notation and representation in collaborative object-oriented design: an observational study
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Software designers in the object-oriented paradigm can make use of modeling tools and standard notations such as UML. Nevertheless, casual observations from collocated design collaborations suggest that teams tend to use physical mediums to sketch a plethora of informal diagrams in varied representations that often diverge from UML. To better understand such collaborations and support them with tools, we need to understand the origins, roles, uses, and implications of these alternate representations. To this end we conducted observational studies of collaborative design exercises, in which we focused on representation use. Our primary finding is that teams intentionally improviserepresentations and organize design information in responseto ad-hoc needs, which arise from the evolution of the design, and which are difficult to meet with fixed standard notations. This behavior incurs orientation and grounding difficulties for which teams compensate by relying on memory, other communication mediums, and contextual cues. Without this additional information the artifacts are difficult to interpret and have limited documentation potential. Collaborative design tools and processes should therefore focus on preserving contextual information while permitting unconstrained mixing and improvising of notations.
[Designing software, Software creation and management, Collaborative and social computing, Collaborative and social computing theory, concepts and paradigms, Human-centered computing, Computer supported cooperative work, Professional topics, Social and professional topics, Software and its engineering, Computing and business]
Webrb: evaluating a visual domain-specific language for building relational web-applications
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Many web-applications can be characterized as "relational". In this paper we introduce and evaluate WebRB, a visualdomain-specific language for building such applications. WebRB addresses the limitations of the conventional "imperative-embedding" approach typically used to build relational web-applications. We describe the WebRB language, present extended examples of its use, and discuss the WebRB visual editor, libraries, and runtime. We then evaluate WebRB by comparing it to alternative approaches, and demonstrate its effectiveness in building relational web-applications.
[Visual languages, Data flow languages, General programming languages, Context specific languages, Language types, Software notations and tools, Software and its engineering]
Modular typestate checking of aliased objects
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Objects often define usage protocols that clients must follow inorder for these objects to work properly. Aliasing makes itnotoriously difficult to check whether clients and implementations are compliant with such protocols. Accordingly, existing approaches either operate globally or severely restrict aliasing. We have developed a sound modular protocol checking approach, based on typestates, that allows a great deal of flexibility in aliasing while guaranteeing the absence of protocol violations at runtime. The main technical contribution is a novel abstraction, access permissions, that combines typestate and object aliasing information. In our methodology, developers express their protocol design intent through annotations based on access permissions. Our checking approach then tracks permissions through method implementations. For each object reference the checker keeps track of the degree of possible aliasing and is appropriately conservativein reasoning about that reference. This helps developers account for object manipulations that may occur through aliases. The checking approach handles inheritance in a novel way, giving subclasses more flexibility in method overriding. Case studies on Java iterators and streams provide evidence that access permissions can model realistic protocols, and protocol checking based on access permissions can be used to reason precisely about the protocols that arise in practice.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Type qualifier inference for java
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Java's type system provides programmers with strong guarantees of type and memory safety, but there are many important properties not captured by standard Java types. We describe JQual, a tool that adds user-defined type qualifiers to Java, allowing programmers to quickly and easily incorporateextra lightweight, application-specific type checking into their programs. JQual provides type qualifier inference, so that programmers need only add a few key qualifier annotations to their program, and then JQual infers any remaining qualifiers and checks their consistency. We explore two applications of JQual. First, we introduce opaque and enumqualifiers to track C pointers and enumerations that flow through Java code via the JNI. In our benchmarks we found that these C values are treated correctly, but there are some places where a client could potentially violate safety. Second,we introduce a read only qualifier for annotating references that cannot be used to modify the objects they refer to. We found that JQual is able to automatically infer read only in many places on method signatures. These results suggest that type qualifiers and type qualifier inference are a useful addition to Java.
[Validation, Cross-computing tools and techniques, Software creation and management, Empirical software validation, Object oriented languages, Software verification and validation, Language types, Software notations and tools, General programming languages, Process validation, General and reference, Software and its engineering]
Establishing object invariants with delayed types
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Mainstream object-oriented languages such as C# and Java provide an initialization model for objects that does not guarantee programmer controlled initialization of fields. Instead, all fields are initialized to default values (0 for scalars and null for non-scalars) on allocation. This is in stark contrast to functional languages, where all parts of an allocation are initialized to programmer-provided values. These choices have a direct impact on two main issues: 1) the prevalence of null in object oriented languages (and its general absence in functional languages), and 2) the ability to initialize circular data structures. This paper explores connections between these differing approaches and proposes a fresh look at initialization. Delayed types are introduced to express and formalize prevalent initialization patterns in object-oriented languages.
[Theory of computation, Semantics and reasoning, Program reasoning, Program constructs, Type structures, Invariants, Object oriented constructs]
Modular verification of higher-order methods with mandatory calls specified by model programs
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
What we call a''higher-order method" (HOM) is a method that makes mandatory calls to other dynamically-dispatched methods. Examples include template methods as in the Template method design pattern and notify methods in the Observer pattern. HOMs are particularly difficult to reason about, because standard pre- and postcondition specifications cannot describe the mandatory calls. For reasoning about such methods, existing approaches use either higher order logic or traces, but both are complex and verbose. We describe a simple, concise, and modular approach to specifying HOMs We show how to verify calls to HOMs and their code using first-order verification conditions, in asound and modular way. Verification of client code that calls HOMs can take advantage of the client's knowledge about the mandatory calls to make strong conclusions. Our verification technique validates and explains traditional documentation practice for HOMs, which typically shows their code. However, specifications do not have to expose all of the code to clients, but only enough to determine how the HOM makes its mandatory calls.
[Validation, Cross-computing tools and techniques, Software creation and management, Software development methods, Software functional properties, Software verification and validation, Software notations and tools, Specification languages, Correctness, System description languages, Theory of computation, Software development process management, Proof theory, Formal software verification, Logic, Formal methods, Reliability, General and reference, Software organization and properties, Software and its engineering]
Using early phase termination to eliminate load imbalances at barrier synchronization points
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
We present a new technique, early phase termination, for eliminating idle processors in parallel computations that use barrier synchronization. This technique simply terminates each parallel phaseas soon as there are too few remaining tasks to keep all of the processors busy. Although this technique completely eliminates the idling that would other wise occur at barrier synchronization points, it may also change the computation and therefore the result that the computation produces. We address this issue by providing probabilistic distortion models that characterize how the use of early phase termination distorts the result that the computation produces. Our experimental results show that for our set of benchmark applications, 1) early phase termination can improve the performance of the parallel computation, 2) the distortion is small (or can be made to be small with the use of an appropriate compensation technique) and 3) the distortion models provide accurate and tight distortion bounds. These bounds can enable users to evaluate the effect of early phase termination and confidently accept results from parallel computations that use this technique if they find the distortion bounds to be acceptable. Finally, we identify a general computational pattern that works well with early phase termination and explain why computations that exhibit this pattern can tolerate the early termination of parallel tasks without producing unacceptable results.
[Software defect analysis, Software creation and management, Language features, Software verification and validation, Computing methodologies, Language types, Software notations and tools, Software testing and debugging, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Starc: static analysis for efficient repair of complex data
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Data structure corruptions are insidious bugs that reduce the reliability of software systems. Constraint-based datastructure repair promises to help programs recover from potentially crippling corruption errors. Prior work repairs a variety of relatively small data structures, usually with hundreds of nodes. We present STARC which uses static analysis to repair data structures with tens of thousands of nodes. Given a Java predicate method that describes the integrity constraints of a structure, STARC statically analyzes the method to identify: (1) the recurrent fields, i.e., fields that the predicate method uses to traverse the structure; and (2) local field constraints, i.e., how the value of an object field is related to the value of a neighboring object field. STARC executes the predicate method on the structure and monitors its execution to identify corrupt object fields, which STARC then repairs using a systematic search of a neighborhood of the given structure. Each repair action is guided by the result of the static analysis, which enables more efficient and effective repair compared to prior work. Experimental results showthat STARC can repair structures with tens of thousands of nodes, up to 100 times larger than prior work. STARC efficiency is probably not practical for very large data structures in deployed systems, but opens a promising direction for future work.
[Software creation and management, Abstract machines, Software verification and validation, Computing methodologies, Symbolic and algebraic manipulation, Abstraction, Software development techniques, Theory of computation, Models of computation, Semantics and reasoning, Error handling and recovery, Program reasoning, Software and its engineering]
Tracking bad apples: reporting the origin of null and undefined value errors
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Programs sometimes crash due to unusable values, for example, when Java and C# programs dereference null pointers and when C and C++ programs use undefined values to affect program behavior. A stack trace produced on such a crash identifies the effect of the unusable value, not its cause, and is often not much help to the programmer. This paper presents efficient origin tracking of unusable values; it shows how to record where these values come into existence, correctly propagate them, and report them if they cause an error. The key idea is value piggybacking: when the original program stores an unusable value, value piggybacking instead stores origin information in the spare bits of the unusable value. Modest compiler support alters the program to propagate these modified values through operations such as assignments and comparisons. We evaluate two implementations: the first tracks null pointer origins in a JVM, and the second tracks undefined value origins in a memory-checking tool built with Valgrind. These implementations show that origin tracking via value piggybacking is fast and often useful, and in the Java case, has low enough overhead for use in a production environment.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Inferring aliasing and encapsulation properties for java
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
There are many proposals for language techniques to control aliasing and encapsulation in object oriented programs, typically based on notions of object ownership and pointer uniqueness. Most of these systems require extensive manual annotations, and thus there is little experience with these properties in large, existing Java code bases. To remedy this situation, we present Uno, a novel static analysis for automatically inferring ownership, uniqueness, and other aliasing and encapsulation properties in Java. Our analysis requires no annotations, and combines an intraprocedural points-to analysis with an interprocedural, demand-driven predicate resolution algorithm. We have applied Uno to a variety of Java applications and found that some aliasing properties, such as temporarily lending a reference to a method, are common, while others, in particular field and argument ownership, are relatively uncommon. As a result, we believe that Uno can be a valuable tool for discovering and understanding aliasing and encapsulation in Java programs.
[Object oriented languages, Language types, Software notations and tools, Program analysis, Software architectures, Theory of computation, Software system structures, Semantics and reasoning, General programming languages, Program semantics, Program reasoning, Software organization and properties, Software and its engineering]
Multiple ownership
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Existing ownership type systems require objects to have precisely one primary owner, organizing the heap into an ownership tree. Unfortunately, a tree structure is too restrictive for many programs, and prevents many common design patterns where multiple objects interact. Multiple Ownership is an ownership type system where objects can have more than one owner, and the resulting ownership structure forms a DAG. We give a straightforward model for multiple ownership, focusing in particular on how multiple ownership can support a powerful effects system that determines when two computations interfere-in spite of the DAG structure. We present a core programming language MOJO, Multiple ownership for Java-like Objects, including a type and effects system, and soundness proof. In comparison to other systems, MOJO imposes absolutely no restrictions on pointers, modifications or programs' structure, but in spite of this, MOJO's effects can be used to reason about or describe programs' behaviour.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Ownership transfer in universe types
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Ownership simplifies reasoning about object-oriented programs by controlling aliasing and modifications of objects. Several type systems have been proposed to express and check ownership statically. For ownership systems to be practical, they must allow objects to migrate from one owner to another. This ownership transfer is common and occurs, for instance, during the initialization of data structures and when data structures are merged. However, existing ownership type systems either do not support ownership transfer at all or they are too restrictive, give rather weak static guarantees, or require a high annotation overhead. In this paper, we present UTT, an extension of Universe Types that supports ownership transfer. UTT combines ownership type checking with a modular static analysis to control references to transferable objects. UTT is very flexible because it permits temporary aliases, even across certain method calls. Nevertheless, it guarantees statically that a cluster of objects is externally-unique when it is transferred and, thus, that ownership transfer is type safe. UTT provides the same encapsulation as Universe Types and requires only negligible annotation overhead.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Lost in translation: formalizing proposed extensions to c#
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Current real-world software applications typically involve heavy use of relational and XML data and their query languages. Unfortunately object-oriented languages and database query languages are based on different semantic foundations and optimization strategies. The resulting ''ROX (Relations, Objects, XML) impedance mismatc'' makes life very difficult for developers. Microsoft Corporation is developing extensions to the .NET framework to facilitate easier processing of non-object-oriented data models. Part of this project (known as "LINQ") includes various extensions to the .NET languages to leverage this support. In this paper we consider proposals for C# 3.0, the next version of the C# programming language. We give both an informal introduction to the new language features, and a precise formal account by defining a translation from C# 3.0 to C# 2.0. This translation also demonstrates how these language extensions do not require any changes to the underlying CLR.
[Theory of computation, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
The java module system: core design and semantic definition
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Java has no module system. Its packages only subdivide the class name space, allowing only a very limited form of component-level information hiding and reuse. Two Java Community Processes have started addressing this problem: one describes the runtime system and has reached an early draft stage, while the other considers the developer's view and only has a straw-man proposal. Both are natural language documents, which inevitably contain ambiguities. In this work we design and formalize a core module system for Java. Where the JCP documents are complete, we follow them closely; elsewhere we make reasonable choices. We define the syntax, the type system, and the operational semantics of an LJAM language, defining these rigorously in the Isabelle/HOL automated proof assistant. Using this formalization, we identify various issues with the module system. We highlight the underlying design decisions, and discuss several alternatives and their benefits. Our Isabelle/HOL definitions should provide a basis for further consideration of the design alternatives, for reference implementations, and for proofs of soundness.
[Theory of computation, Semantics and reasoning, Semantics, General programming languages, Language features, Program semantics, Formal language definitions, Software notations and tools, Modules / packages, Syntax, Software and its engineering]
Awesome: an aspect co-weaving system for composing multiple aspect-oriented extensions
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Domain specific aspect-oriented language extensions offer unique capabilities to deal with a variety of cross cutting concerns. Ideally, one should be able to use several of these extensions together in a single program. Unfortunately, each extension generally implements its own specialized weaver and the different weavers are incompatible. Even if the weavers were compatible, combining them is a difficult problem to solve in general, because each extension definesits own language with new semantics. In this paper we present a practical composition framework, named A&lt;scp&gt;wesome&lt;/scp&gt;, for constructing a multi-extension weaver by plugging together independently developed aspect mechanisms. The framework has a component-based and aspect-oriented architecture that facilitates the development and integration of aspect weavers. To be scalable, the framework provides a default resolution of feature interactions in the composition. To be general, the framework provides means for customizing the composition behavior. Furthermore, to be practically useful, there is no framework-associated overhead on the runtime performance of compiled aspect programs. To illustrate the A&lt;scp&gt;wesome&lt;/scp&gt; framework concretely, we demonstrate the construction of a weaver for a multi-extension AOP language that combines Cool and AspectJ. However, the composition method is not exclusive to Cool and AspectJ-it can be applied to combine any comparable reactive aspect mechanisms.
[Software notations and tools, Software and its engineering, Compilers]
Scalable omniscient debugging
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Omniscient debuggers make it possible to navigate backwards in time within a program execution trace, drastically improving the task of debugging complex applications. Still, they are mostly ignored in practice due to the challenges raised by the potentially huge size of the execution traces. This paper shows that omniscient debugging can be realistically realized through the use of different techniques addressing efficiency, scalability and usability. We present TOD, a portable Trace-Oriented Debugger for Java, which combines an efficient instrumentation for event generation, a specialized distributed database for scalable storage and efficient querying, support for partial traces in order to reduce the trace volume to relevant events, and innovative interface components for interactive trace navigation and analysis in the development environment. Provided a reasonable infrastructure, the performance of TOD allows a responsive debugging experience in the face of large programs.
[Software defect analysis, Software creation and management, Software testing and debugging, Integrated and visual development environments, Software verification and validation, Software notations and tools, Development frameworks and environments, Software and its engineering]
Using hpm-sampling to drive dynamic compilation
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
All high-performance production JVMs employ an adaptive strategy for program execution. Methods are first executed unoptimized and then an online profiling mechanism is used to find a subset of methods that should be optimized during the same execution. This paper empirically evaluates the design space of several profilers for initiating dynamic compilation and shows that existing online profiling schemes suffer from several limitations. They provide an insufficient number of samples, are untimely, and have limited accuracy at determining the frequently executed methods. We describe and comprehensively evaluate HPM-sampling, a simple but effective profiling scheme for finding optimization candidates using hardware performance monitors (HPMs) that addresses the aforementioned limitations. We show that HPM-sampling is more accurate; has low overhead; and improves performance by 5.7% on average and up to 18.3% when compared to the default system in Jikes RVM, without changing the compiler.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Mop: an efficient and generic runtime verification framework
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Monitoring-Oriented Programming (MOP1) [21, 18, 22, 19] is a formal framework for software development and analysis, in which the developer specifies desired properties using definable specification formalisms, along with code to execute when properties are violated or validated. The MOP framework automatically generates monitors from the specified properties and then integrates them together with the user-defined code into the original system. The previous design of MOP only allowed specifications without parameters, so it could not be used to state and monitor safety properties referring to two or more related objects. In this paper we propose a parametric specification formalism-independent extension of MOP, together with an implementation of JavaMOP that supports parameters. In our current implementation, parametric specifications are translated into AspectJ code and then weaved into the application using off-the-shelf AspectJ compilers; hence, MOP specifications can be seen as formal or logical aspects. Our JavaMOP implementation was extensively evaluated on two benchmarks, Dacapo [14] and Tracematches [8], showing that runtime verification in general and MOP in particular are feasible. In some of the examples, millions of monitor instances are generated, each observing a set of related objects. To keep the runtime overhead of monitoring and event observation low, we devised and implemented a decentralized indexing optimization. Less than 8% of the experiments showed more than 10% runtime overhead; in most cases our tool generates monitoring code as efficient as the hand-optimized code. Despite its genericity, JavaMOP is empirically shown to be more efficient than runtime verification systems specialized and optimized for particular specification formalisms. Many property violations were detected during our experiments; some of them are benign, others indicate defects in programs. Many of these are subtle and hard to find by ordinary testing.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Making trace monitors feasible
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
A trace monitor observes an execution trace at runtime; when it recognises a specified sequence of events, the monitor runs extra code. In the aspect-oriented programming community, the idea originatedas a generalisation of the advice-trigger mechanism: instead of matchingon single events (joinpoints), one matches on a sequence of events. The runtime verification community has been investigating similar mechanisms for a number of years, specifying the event patterns in terms of temporal logic, and applying the monitors to hardware and software. In recent years trace monitors have been adapted for use with mainstream object-oriented languages. In this setting, a crucial feature is to allow the programmer to quantify over groups of related objects when expressing the sequence of events to match. While many language proposals exist for allowing such features, until now no implementation had scalable performance: execution on all but very simple examples was infeasible. This paper rectifies that situation, by identifying two optimisations for generating feasible trace monitors from declarative specifications of the relevant event pattern. We restrict ourselves to optimisations that do not have a significant impact on compile-time: they only analyse the event pattern, and not the monitored code itself. The first optimisation is an important improvement over an earlier proposal in [2] to avoid space leaks. The second optimisation is a form of indexing for partial matches. Such indexing needs to be very carefully designed to avoid introducing new space leaks, and the resulting data structure is highly non-trivial.
[Software notations and tools, Software and its engineering, Compilers]
Living in the comfort zone
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
A comfort zone is a tested region of a system's input space within which it has been observed to behave acceptably. To keep systems operating within their comfort zones, we advocate the interposition of rectifiers between systems and their input sources. Rectifiers are designed to transform inputs to ensure that they are within the comfort zone before they are presented to the system. Rectifiers enforce a highly constrained input format and, if necessary, discard information to force inputs to conform to this format. Potential benefits of this approach include the elimination of errors and vulnerabilities, the excision of undesirable excess functionality from large, complex systems, and a simplification of the computing environment. We have developed a rectifier for email messages and used this rectifier to force messages into a specific constrained form. Our results show that this rectifier can successfully produce messages that keep the Pine email client strictly within code previously confirmed (during a small testing and training session) to function acceptably. Our results also show that the rectifier completely eliminates a security vulnerability in the Pine email client. And finally, the rectifier is able to accomplish these goals while still preserving an acceptable amount of information from the original messages.
[Designing software, Requirements analysis, Software creation and management, Software notations and tools, Software and its engineering]
Living it up with a live programming language
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
A dynamic language promotes ease of use through flexible typing, a focus on high-level programming, and by streamlining the edit-compile-debug cycle. Live languages go beyond dynamic languages with more ease of use features. A live language supports live programming that provides programmers with responsive and continuous feedback about how their edits affect program execution. A live language is also based on high-level constructs such as declarative rules so that programmers can write less code. A live language could also provide programmers with responsive semantic feedback to enable time-saving services such as code completion. This paper describes the design of a textual live language that is based on reactive data-flow values known as signals and dynamic inheritance. Our language, SuperGlue, supports live programming with responsive semantic feedback, which we demonstrate with a working prototype.
[Software notations and tools, Development frameworks and environments, Software and its engineering]
No ifs, ands, or buts: uncovering the simplicity of conditionals
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Schematic tables are a new representation for conditionals. Roughly a cross between decision tables and data flowgraphs, they represent computation and decision-making orthogonally. They unify the full range of conditional constructs, from if statements through pattern matching to polymorphic predicate dispatch. Program logic is maintained in a declarative canonical form that enforces completeness and disjointness among choices. Schematic tables can beused either as a code specification/generation tool, or as a self-contained diagrammatic programming language. They give program logic the clarity of truth tables, and support high-level direct manipulation of that logic, avoiding much of the mental computation demanded by conventional conditionals.
[Control structures, Designing software, Software creation and management, General programming languages, Language features, Software notations and tools, Software development techniques, Software and its engineering, Polymorphism]
Epi-aspects: aspect-oriented conscientious software
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
Conscientious software is a recently proposed paradigm for developing reliable, self-sustaining software systems. Conscientious software systems consist of an allopoietic part, which encapsulates application functionality, and an autopoietic part that is responsible for keeping the system alive by monitoring the application and adapting it to environmental changes. Practical application of the conscientious software paradigm requires solutions to two open problems: The design of suitable autopoietic programming languages and the proposal of concrete architectures for combining the autopoietic and allopoietic parts. In this paper, we tackle the second challenge, and propose a concrete, aspect-oriented architecture for realizing conscientious software. Here, we introduce epi-aspects, a construct for upgrading new and existing applications into conscientious software. This paper provides the architectural design of epi-aspects, an autopoietic simulator, and a concrete framework for developing epi-aspects in Java. The framework and the simulator are used to conduct a case study in which we develop and test a conscientious Java application.
[Software system structures, Software architectures, Software organization and properties, Software and its engineering]
Confessions of a used programming language salesman
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
For many years I had been fruitlessly trying to sell functional programming and Haskell to solve real world problems such as scripting and data-intensive three-tier distributed web applications. The lack of widespread adoption of Haskell is a real pity. Functional programming concepts are key to curing many of the headaches that plague the majority of programmers, who today are forced to use imperative languages. If the mountain won't come to Mohammed, Mohammed must go to the mountain, and so I left academia to join industry. Instead of trying to convince imperative programmers to forget everything they already know and learn something completely new, I decided to infuse existing imperative object-oriented programming languages with functional programming features. As a result, functional programming has finally reached the masses, except that it is called Visual Basic 9 instead of Haskell 98.
[General programming languages, Object oriented languages, Language types, Functional languages, Software notations and tools, Software and its engineering]
The transactional memory / garbage collection analogy
Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications
ACM SIGPLAN Notices VOLUME 42 ISSUE 10
2007
This essay presents remarkable similarities between transactional memory and garbage collection. The connections are fascinating in their own right, and they let us better understand one technology by thinking about the corresponding issues for the other.
[Garbage collection, Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Contextual software domains, Operating systems, General programming languages, Memory management, Software organization and properties, Software and its engineering]
Caching and incrementalisation in the java query language
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Many contemporary object-oriented programming languages support first-class queries or comprehensions. These language extensions make it easier for programmers to write queries, but are generally implemented no more efficiently than the code using collections, iterators, and loops that they replace. Crucially, whenever a query is re-executed, it is recomputed from scratch. We describe a general approach to optimising queries over mutable objects: query results are cached, and those caches are incrementally maintained whenever the collections and objects underlying those queries are updated. We hope that the performance benefits of our optimisations may encourage more general adoption of first-class queries by object-oriented programmers.
[General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Interprocedural query extraction for transparent persistence
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Transparent persistence promises to integrate programming languages and databases by allowing programs to access persistent data with the same ease as non-persistent data. In this work we demonstrate the feasibility of optimizing transparently persistent programs by extracting queries to efficiently prefetch required data. A static analysis derives query structure and conditions across methods that access persistent data. Using the static analysis, our system transforms the program to execute explicit queries. The transformed program composes queries across methods to handle method calls that return persistent data. We extend an existing Java compiler to implement the static analysis and program transformation, handling recursion and parameterized queries. We evaluate the effectiveness of query extraction on the OO7 and TORPEDO benchmarks. This work is focused on programs written in the current version of Java, without languages changes. However, the techniques developed here may also be of value in conjunction with object-oriented languages extended with high-level query syntax.
[Theory of computation, Theory and algorithms for application domains, Data management systems, Software notations and tools, Database theory, Query languages, Software and its engineering, Compilers, Information systems, Database query languages (principles)]
Deep typechecking and refactoring
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Large software systems are typically composed of multiple layers, written in different languages and loosely coupled using a string-based interface. For example, in modern web-applications, a server written in Java communicates with a database back-end by passing in query strings. This widely prevalent approach is unsafe as the analyses developed for the individual layers are oblivious to the semantics of the dynamically constructed strings, making it impossible to statically reason about the correctness of the interaction. Further, even simple refactoring in such systems is daunting and error prone as the changes must also be applied to isolated string fragments scattered across the code base. We present techniques for deep typechecking and refactoring for systems that combine Java code with a database back-end using the Java Persistence API [10]. Deep typechecking ensures that the queries that are constructed dynamically are type safe and that the values returned from the queries are used safely by the program. Deep refactoring builds upon typechecking to allow programmers to safely and automatically propagate code refactorings through the query string fragments. Our algorithms are implemented in a tool called QUAIL. We present experiments evaluating the effectiveness of QUAIL on several benchmarks ranging from 3,369 to 82,907 lines of code.We show that QUAIL is able to verify that 84% of query strings in our benchmarks are type safe. Finally, we show that QUAIL reduces the number of places in the code that a programmer must look at in order to perform a refactoring by several orders of magnitude.
[Cross-computing tools and techniques, Extra-functional properties, Software reliability, Reliability, General and reference, Software organization and properties, Software and its engineering]
Whiteoak: introducing structural typing into java
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
This paper presents WHITEOAK: a JAVA extension that introduces structural type equivalence and subtyping into the language. We argue that structural subtyping addresses common software design problems, and promotes the development of loosely coupled modules without compromising type safety. We discuss language design issues, including subtyping in face of self-referencing structural types, compile-time operators for computing the new types from existing ones, and the semantics of constructors and non-abstract methods in structural types. We describe implementation techniques, including the compile-time and run-time challenges that we faced (in particular, preserving the identity of objects). Measurement indicate that the performance of our implementation of structural dispatching is comparable to that of the JVM's standard invocation mechanisms.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Mixing source and bytecode: a case for compilation by normalization
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Language extensions increase programmer productivity by providing concise, often domain-specific syntax, and support for static verification of correctness, security, and style constraints. Language extensions can often be realized through translation to the base language, supported by preprocessors and extensible compilers. However, various kinds of extensions require further adaptation of a base compiler's internal stages and components, for example to support separate compilation or to make use of low-level primitives of the platform (e.g., jump instructions or unbalanced synchronization). To allow for a more loosely coupled approach, we propose an open compiler model based on normalization steps from a high-level language to a subset of it, the core language. We developed such a compiler for a mixed Java and (core) bytecode language, and evaluate its effectiveness for composition mechanisms such as traits, as well as statement-level and expression-level language extensions.
[General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering, Compilers]
Tolerating memory leaks
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Type safety and garbage collection in managed languages eliminate memory errors such as dangling pointers, double frees, and leaks of unreachable objects. Unfortunately, a program still leaks memory if it maintains references to objects it will never use again. Leaked objects decrease program locality and increase garbage collection frequency and workload. A growing leak will eventually exhaust memory and crash the program. This paper introduces a leak tolerance approach called Melt that safely eliminates performance degradations and crashes due to leaks of dead but reachable objects in managed languages, given sufficient disk space to hold leaking objects. Melt (1) identifies stale objects that the program is not accessing; (2) segregates in-use and stale objects by storing stale objects to disk; and (3) preserves safety by activating stale objects if the program subsequently accesses them. We design and build a prototype implementation of Melt in a Java VM and show it adds overhead low enough for production systems. Whereas existing VMs grind to a halt and then crash on programs with leaks, Melt keeps many of these programs running much longer without significantly degrading performance. Melt provides users the illusion of a fixed leak and gives developers more time to fix leaky programs.
[Software creation and management, Error handling and recovery, Software development techniques, Software and its engineering]
Jolt: lightweight dynamic analysis and removal of object churn
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
It has been observed that component-based applications exhibit object churn, the excessive creation of short-lived objects, often caused by trading performance for modularity. Because churned objects are short-lived, they appear to be good candidates for stack allocation. Unfortunately, most churned objects escape their allocating function, making escape analysis ineffective. We reduce object churn with three contributions. First, we formalize two measures of churn, capture and control (15). Second, we develop lightweight dynamic analyses for measuring both capture and control. Third, we develop an algorithm that uses capture and control to inline portions of the call graph to make churned objects non-escaping, enabling churn optimization via escape analysis. JOLT is a lightweight dynamic churn optimizer that uses our algorithms. We embedded JOLT in the JIT compiler of the IBM J9 commercial JVM, and evaluated JOLT on large application frameworks, including Eclipse and JBoss. We found that JOLT eliminates over 4 times as many allocations as a state-of-the-art escape analysis alone.
[Software notations and tools, Software and its engineering, Compilers]
QVM: an efficient runtime for detecting defects in deployed systems
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Coping with software defects that occur in the post-deployment stage is a challenging problem: bugs may occur only when the system uses a specific configuration and only under certain usage scenarios. Nevertheless, halting production systems until the bug is tracked and fixed is often impossible. Thus, developers have to try to reproduce the bug in laboratory conditions. Often the reproduction of the bug consists of the lion share of the debugging effort. In this paper we suggest an approach to address the aforementioned problem by using a specialized runtime environment (QVM, for Quality Virtual Machine). QVM efficiently detects defects by continuously monitoring the execution of the application in a production setting. QVM enables the efficient checking of violations of user-specified correctness properties, e.g., typestate safety properties, Java assertions, and heap properties pertaining to ownership. QVM is markedly different from existing techniques for continuous monitoring by using a novel overhead manager which enforces a user-specified overhead budget for quality checks. Existing tools for error detection in the field usually disrupt the operation of the deployed system. QVM, on the other hand, provides a balanced trade off between the cost of the monitoring process and the maintenance of sufficient accuracy for detecting defects. Specifically, the overhead cost of using QVM instead of a standard JVM, is low enough to be acceptable in production environments. We implemented QVM on top of IBM's J9 Java Virtual Machine and used it to detect and fix various errors in real-world applications.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Contention-aware scheduler: unlocking execution parallelism in multithreaded java programs
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
In multithreaded programming, locks are frequently used as a mechanism for synchronization. Because today's operating systems do not consider lock usage as a scheduling criterion, scheduling decisions can be unfavorable to multithreaded applications, leading to performance issues such as convoying and heavy lock contention in systems with multiple processors. Previous efforts to address these issues (e.g., transactional memory, lock-free data structure) often treat scheduling decisions as "a fact of life," and therefore these solutions try to cope with the consequences of undesirable scheduling instead of dealing with the problem directly. In this paper, we introduce Contention-Aware Scheduler (CA-Scheduler), which is designed to support efficient execution of large multithreaded Java applications in multiprocessor systems. Our proposed scheduler employs a scheduling policy that reduces lock contention. As will be shown in this paper, our prototype implementation of the CA-Scheduler in Linux and Sun HotSpot virtual machine only incurs 3.5% runtime overhead, while the overall performance differences, when compared with a system with no contention awareness, range from a degradation of 3% in a small multithreaded benchmark to an improvement of 15% in a large Java application server benchmark.
[Software notations and tools, Scheduling, Concurrency control, Runtime environments, Contextual software domains, Multithreading, Operating systems, Process synchronization, Software organization and properties, Software and its engineering, Compilers, Process management]
Dynamic optimization for efficient strong atomicity
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Transactional memory (TM) is a promising concurrency control alternative to locks. Recent work has highlighted important memory model issues regarding TM semantics and exposed problems in existing TM implementations. For safe, managed languages such as Java, there is a growing consensus towards strong atomicity semantics as a sound, scalable solution. Strong atomicity has presented a challenge to implement efficiently because it requires instrumentation of non-transactional memory accesses, incurring significant overhead even when a program makes minimal or no use of transactions. To minimize overhead, existing solutions require either a sophisticated type system, specialized hardware, or static whole-program analysis. These techniques do not translate easily into a production setting on existing hardware. In this paper, we present novel dynamic optimizations that significantly reduce strong atomicity overheads and make strong atomicity practical for dynamic language environments. We introduce analyses that optimistically track which non-transactional memory accesses can avoid strong atomicity instrumentation, and we describe a lightweight speculation and recovery mechanism that applies these analyses to generate speculatively-optimized but safe code for strong atomicity in a dynamically-loaded environment. We show how to implement these mechanisms efficiently by leveraging existing dynamic optimization infrastructure in a Java system. Measurements on a set of transactional and non-transactional Java workloads demonstrate that our techniques substantially reduce the overhead of strong atomicity from a factor of 5x down to 10% or less over an efficient weak atomicity baseline.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Design and implementation of transactional constructs for C/C++
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
This paper presents a software transactional memory system that introduces first-class C++ language constructs for transactional programming. We describe new C++ language extensions, a production-quality optimizing C++ compiler that translates and optimizes these extensions, and a high-performance STM runtime library. The transactional language constructs support C++ language features including classes, inheritance, virtual functions, exception handling, and templates. The compiler automatically instruments the program for transactional execution and optimizes TM overheads. The runtime library implements multiple execution modes and implements a novel STM algorithm that supports both optimistic and pessimistic concurrency control. The runtime switches a transaction's execution mode dynamically to improve performance and to handle calls to precompiled functions and I/O libraries. We present experimental results on 8 cores (two quad-core CPUs) running a set of 20 non-trivial parallel programs. Our measurements show that our system scales well as the numbers of cores increases and that our compiler and runtime optimizations improve scalability.
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
jStar: towards practical verification for java
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
In this paper we introduce a novel methodology for verifying a large set of Java programs which builds on recent theoretical developments in program verification: it combines the idea of abstract predicate families and the idea of symbolic execution and abstraction using separation logic. The proposed technology has been implemented in a new automatic verification system, called jStar, which combines theorem proving and abstract interpretation techniques. We demonstrate the effectiveness of our methodology by using jStar to verify example programs implementing four popular design patterns (subject/observer, visitor, factory, and pooling). Although these patterns are extensively used by object-oriented developers in real-world applications, so far they have been highly challenging for existing object-oriented verification techniques.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Language features, Inheritance, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Verifying correct usage of atomic blocks and typestate
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
The atomic block, a synchronization primitive provided to programmers in transactional memory systems, has the potential to greatly ease the development of concurrent software. However, atomic blocks can still be used incorrectly, and race conditions can still occur at the level of application logic. In this paper, we present a intraprocedural static analysis, formalized as a type system and proven sound, that helps programmers use atomic blocks correctly. Using access permissions, which describe how objects are aliased and modified, our system statically prevents race conditions and enforces typestate properties in concurrent programs. We have implemented a prototype static analysis for the Java language based on our system and have used it to verify several realistic examples.
[Theory of computation, Semantics and reasoning, Distributed programming languages, General programming languages, Language types, Software notations and tools, Concurrent programming languages, Parallel programming languages, Program reasoning, Program verification, Software and its engineering]
Enforcing object protocols by combining static and runtime analysis
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
In this paper, we consider object protocols that constrain interactions between objects in a program. Several such protocols have been proposed in the literature. For many APIs (such as JDOM, JDBC), API designers constrain how API clients interact with API objects. In practice, API clients violate such constraints, as evidenced by postings in discussion forums for these APIs. Thus, it is important that API designers specify constraints using appropriate object protocols and enforce them. The goal of an object protocol is expressed as a protocol invariant. Fundamental properties such as ownership can be expressed as protocol invariants. We present a language, PROLANG, to specify object protocols along with their protocol invariants, and a tool, INVCOP++, to check if a program satisfies a protocol invariant. INVCOP++ separates the problem of checking if a protocol satisfies its protocol invariant (called protocol correctness), from the problem of checking if a program conforms to a protocol (called program conformance). The former is solved using static analysis, and the latter using runtime analysis. Due to this separation (1) errors made in protocol design are detected at a higher level of abstraction, independent of the program's source code, and (2) performance of conformance checking is improved as protocol correctness has been verified statically. We present theoretical guarantees about the way we combine static and runtime analysis, and empirical evidence that our tool INVCOP++ finds usage errors in widely used APIs. We also show that statically checking protocol correctness greatly optimizes the overhead of checking program conformance, thus enabling API clients to test whether their programs use the API as intended by the API designer.
[Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software development techniques, Software and its engineering]
The impact of static-dynamic coupling on remodularization
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
We explore the concept of static-dynamic coupling--the degree to which changes in a program's static modular structure imply changes to its dynamic structure. This paper investigates the impact of static-dynamic coupling in a programming language on the effort required to evolve the coarse modular structure of programs written in that language. We performed a series of remodularization case studies in both Java and SubjectJ. SubjectJ is designed to be similar to Java, but have strictly less static-dynamic coupling. Our results include quantitative measures-time taken and number of bugs introduced--as well as a more subjective qualitative analysis of the remodularization process. All results point in the same direction and suggest that static-dynamic coupling causes substantial accidental complexity for the remodularization of Java programs.
[Software prototyping, Software creation and management, Language features, Software post-development issues, Software notations and tools, Modules / packages, Software development techniques, Development frameworks and environments, Software evolution, Integrated and visual development environments, General programming languages, Software and its engineering]
Sound and extensible renaming for java
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Descriptive names are crucial to understand code. However, good names are notoriously hard to choose and manually changing a globally visible name can be a maintenance nightmare. Hence, tool support for automated renaming is an essential aid for developers and widely supported by popular development environments. This work improves on two limitations in current refactoring tools: too weak preconditions that lead to unsoundness where names do not bind to the correct declarations after renaming, and too strong preconditions that prevent renaming of certain programs. We identify two main reasons for unsoundness: complex name lookup rules make it hard to define sufficient preconditions, and new language features require additional preconditions. We alleviate both problems by presenting a novel extensible technique for creating symbolic names that are guaranteed to bind to a desired entity in a particular context by inverting lookup functions. The inverted lookup functions can then be tailored to create qualified names where otherwise a conflict would occur, allowing the refactoring to proceed and improve on the problem with too strong preconditions. We have implemented renaming for Java as an extension to the JastAdd Extensible Java Compiler and integrated it in Eclipse. We show examples for which other refactoring engines have too weak preconditions, as well as examples where our approach succeeds in renaming entities by inserting qualifications. To validate the extensibility of the approach we have implemented renaming support for Java 5 and AspectJ like inter-type declarations as modular extensions to the initial Java 1.4 refactoring engine. The renaming engine is only a few thousand lines of code including extensions and performance is on par with industrial strength refactoring tools.
[Software notations and tools, Software and its engineering, Compilers]
Annotation refactoring: inferring upgrade transformations for legacy applications
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Since annotations were added to the Java language, many frameworks have moved to using annotated Plain Old Java Objects (POJOs) in their newest releases. Legacy applications are thus forced to undergo extensive restructuring in order to migrate from old framework versions to new versions based on annotations (Version Lock-in). Additionally, because annotations are embedded in the application code, changing between framework vendors may also entail largescale manual changes (Vendor Lock-in). This paper presents a novel refactoring approach that effectively solves these two problems. Our approach infers a concise set of semantics-preserving transformation rules from two versions of a single class. Unlike prior approaches that detect only simple structural refactorings, our algorithm can infer general composite refactorings and is more than 97% accurate on average. We demonstrate the effectiveness of our approach by automatically upgrading more than 80K lines of the unit testing code of four open-source Java applications to use the latest version of the popular JUnit testing framework.
[Software creation and management, Reusability, Object oriented languages, Language types, Software notations and tools, Software post-development issues, Development frameworks and environments, Software development techniques, Integrated and visual development environments, Software evolution, General programming languages, Software and its engineering]
Enabling static analysis for partial java programs
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Software engineering tools often deal with the source code of programs retrieved from the web or source code repositories. Typically, these tools only have access to a subset of a program's source code (one file or a subset of files) which makes it difficult to build a complete and typed intermediate representation (IR). Indeed, for incomplete object-oriented programs, it is not always possible to completely disambiguate the syntactic constructs and to recover the declared type of certain expressions because the declaration of many types and class members are not accessible. We present a framework that performs partial type inference and uses heuristics to recover the declared type of expressions and resolve ambiguities in partial Java programs. Our framework produces a complete and typed IR suitable for further static analysis. We have implemented this framework and used it in an empirical study on four large open source systems which shows that our system recovers most declared types with a low error rate, even when only one class is accessible.
[Software notations and tools, Software and its engineering, Compilers]
Safer unsafe code for .NET
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
The .NET intermediate language (MSIL) allows expressing both statically verifiable memory and type safe code (typically called managed), as well as unsafe code using direct pointer manipulations. Unsafe code can be expressed in C# by marking regions of code as unsafe. Writing unsafe code can be useful where the rules of managed code are too strict. The obvious drawback of unsafe code is that it opens the door to programming errors typical of C and C++, namely memory access errors such as buffer overruns. Worse, a single piece of unsafe code may corrupt memory and destabilize the entire runtime or allow attackers to compromise the security of the platform. We present a new static analysis based on abstract interpretation to check memory safety for unsafe code in the .NET framework. The core of the analysis is a new numerical abstract domain, Strp, which is used to efficiently compute memory invariants. Strp is combined with lightweight abstract domains to raise the precision, yet achieving scalability. We implemented this analysis in Clousot, a generic static analyzer for .NET. In combination with contracts expressed in FoxTrot, an MSIL based annotation language for .NET, our analysis provides static safety guarantees on memory accesses in unsafe code. We tested it on all the assemblies of the .NET framework. We compare our results with those obtained using existing domains, showing how they are either too imprecise (e.g., Intervals or Octagons) or too expensive (Polyhedra) to be used in practice.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Program analysis, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program semantics, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Typestate-like analysis of multiple interacting objects
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
This paper presents a static analysis of typestate-like temporal specifications of groups of interacting objects, which are expressed using tracematches. Whereas typestate expresses a temporal specification of one object, a tracematch state may change due to operations on any of a set of related objects bound by the tracematch. The paper proposes a lattice-based operational semantics equivalent to the original tracematch semantics but better suited to static analysis. The paper defines a static analysis that computes precise local points-to sets and tracks the flow of individual objects, thereby enabling strong updates of the tracematch state. The analysis has been proved sound with respect to the semantics. A context-sensitive version of the analysis has been implemented as instances of the IFDS and IDE algorithms. The analysis was evaluated on tracematches used in earlier work and found to be very precise. Remaining imprecisions could be eliminated with more precise modeling of references from the heap and of exceptional control flow.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Java performance evaluation through rigorous replay compilation
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
A managed runtime environment, such as the Java virtual machine, is non-trivial to benchmark. Java performance is affected in various complex ways by the application and its input, as well as by the virtual machine (JIT optimizer, garbage collector, thread scheduler, etc.). In addition, non-determinism due to timer-based sampling for JIT optimization, thread scheduling, and various system effects further complicate the Java performance benchmarking process. Replay compilation is a recently introduced Java performance analysis methodology that aims at controlling non-determinism to improve experimental repeatability. The key idea of replay compilation is to control the compilation load during experimentation by inducing a pre-recorded compilation plan at replay time. Replay compilation also enables teasing apart performance effects of the application versus the virtual machine. This paper argues that in contrast to current practice which uses a single compilation plan at replay time, multiple compilation plans add statistical rigor to the replay compilation methodology. By doing so, replay compilation better accounts for the variability observed in compilation load across compilation plans. In addition, we propose matched-pair comparison for statistical data analysis. Matched-pair comparison considers the performance measurements per compilation plan before and after an innovation of interest as a pair, which enables limiting the number of compilation plans needed for accurate performance analysis compared to statistical analysis assuming unpaired measurements.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software notations and tools, Runtime environments, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering, Compilers]
Analysis and reduction of memory inefficiencies in Java strings
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
This paper describes a novel approach to reduce the memory consumption of Java programs, by focusing on their "string memory inefficiencies". In recent Java applications, string data occupies a large amount of the heap area. For example, about 40% of the live heap area is used for string data when a production J2EE application server is running. By investigating the string data in the live heap, we identified two types of memory inefficiencies -- "duplication" and "unused literals". In the heap, there are many string objects that have the same values. There also exist many string literals whose values are not actually used by the application. Since these inefficiencies exist as live objects, they cannot be eliminated by existing garbage collection techniques, which only remove dead objects. Quantitative analysis of Java heaps in real applications revealed that more than 50% of the string data in the live heap is wasted by these inefficiencies. To reduce the string memory inefficiencies, this paper proposes two techniques at the Java virtual machine level, "StringGC" for eliminating duplicated strings at the time of garbage collection, and "Lazy Body Creation" for delaying part of the literal instantiation until the literal's value is actually used. We also present an interesting technique at the Java program level, which we call "BundleConverter", for preventing unused message literals from being instantiated. Prototype implementations on a production Java virtual machine have achieved about 18% reduction of the live heap in the production application server. The proposed techniques could also reduce the live heap of standard Java benchmarks by 11.6% on average, without noticeable performance degradation.
[General programming languages, Language features, Frameworks, Software notations and tools, Software and its engineering]
Analyzing the performance of code-copying virtual machines
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Many popular programming languages use interpreter-based execution for portability, supporting dynamic or reflective properties, and ease of implementation. Code-copying is an optimization technique for interpreters that reduces the performance gap between interpretation and JIT compilation, offering significant speedups over direct-threading interpretation. Due to varying language features and virtual machine design, however, not all languages benefit from codecopying to the same extent. We consider here properties of interpreted languages, and in particular bytecode and virtual machine construction that enhance or reduce the impact of code-copying. We implemented code-copying and compared performance with the original direct-threading virtual machines for three languages, Java (SableVM), OCaml, and Ruby (Yarv), examining performance on three different architectures, ia32 (Pentium 4), x86_64 (AMD64) and PowerPC (G5). Best speedups are achieved on ia32 by OCaml (maximum 4.88 times, 2.81 times on average), where a small and simple bytecode design facilitates improvements to branch prediction brought by code-copying. Yarv only slightly improves over direct-threading; large working sizes of bytecodes, and a relatively small fraction of time spent in the actual interpreter loop both limit the application of codecopying and its overall net effect. We are able to show that simple ahead of time analysis of VM and execution properties can help determine the suitability of code-copying for a particular VM before an implementation of code-copying is even attempted.
[Design, Cross-computing tools and techniques, Interpreters, Software notations and tools, General and reference, Software and its engineering, Compilers]
Generics of a higher kind
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
With Java 5 and C# 2.0, first-order parametric polymorphism was introduced in mainstream object-oriented programming languages under the name of generics. Although the first-order variant of generics is very useful, it also imposes some restrictions: it is possible to abstract over a type, but the resulting type constructor cannot be abstracted over. This can lead to code duplication. We removed this restriction in Scala, by allowing type constructors as type parameters and abstract type members. This paper presents the design and implementation of the resulting type constructor polymorphism. Furthermore, we study how this feature interacts with existing object-oriented constructs, and show how it makes the language more expressive.
[General programming languages, Language features, Software notations and tools, Software and its engineering, Polymorphism]
The visitor pattern as a reusable, generic, type-safe component
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
The V<sc>ISITOR</sc> design pattern shows how to separate the structure of an object hierarchy from the behaviour of traversals over that hierarchy. The pattern is very flexible; this very flexibility makes it difficult to capture the pattern as anything more formal than prose, pictures and prototypes. We show how to capture the essence of the V<sc>ISITOR</sc> pattern as a reusable software library, by using advanced type system features appearing in modern object-oriented languages such as Scala. We preserve type-safety statically and modularly: no reflection or similar mechanisms are used and modules can be independently compiled. The library is generic, in two senses: not only is it parametrised by both the return type and the shape of the object hierarchy, but also it allows a number of implementation choices (internal versus external control, imperative versus functional behaviour, orthogonal aspects such as tracing and memoisation) to be specified by parameters rather than fixed in early design decisions. Finally, we propose a generalised datatype-like notation,on top of our visitor library: this provides a convenient functional decomposition style in object-oriented languages.
[General programming languages, Object oriented languages, Multiparadigm languages, Language types, Functional languages, Software notations and tools, Software libraries and repositories, Software and its engineering]
Constrained types for object-oriented languages
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
X10 is a modern object-oriented language designed for productivity and performance in concurrent and distributed systems. In this setting, dependent types offer significant opportunities for detecting design errors statically, documenting design decisions, eliminating costly run-time checks (e.g., for array bounds, null values), and improving the quality of generated code. We present the design and implementation of constrained types, a natural, simple, clean, and expressive extension to object-oriented programming: A type C{c} names a class or interface C and a constraint c on the immutable state of C and in-scope final variables. Constraints may also be associated with class definitions (representing class invariants) and with method and constructor definitions (representing preconditions). Dynamic casting is permitted. The system is parametric on the underlying constraint system: the compiler supports a simple equality-based constraint system but, in addition, supports extension with new constraint systems using compiler plugins.
[Classes and objects, Constraints, General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Efficient local type inference
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Inference of static types for local variables in Java bytecode is the first step of any serious tool that manipulates bytecode, be it for decompilation, transformation or analysis. It is important, therefore, to perform that step as accurately and efficiently as possible. Previous work has sought to give solutions with good worst-case complexity. We present a novel algorithm, which is optimised for the common case rather than worst-case performance. It works by first finding a set of minimal typings that are valid for all assignments, and then checking whether these minimal typings satisfy all uses. Unlike previous algorithms, it does not explicitly build a data structure of type constraints, and it is easy to implement efficiently. We prove that the algorithm produces a typing that is both sound (obeying the rules of the language) and as tight as possible. We then go on to present extensive experiments, comparing the results of the new algorithm against the previously best known method. The experiments include bytecode that is generated in other ways than compilation of Java source. The new algorithm is always faster, typically by a factor 6, but on some real benchmarks the gain is as high as a factor of 92. Furthermore, whereas that previous method is sometimes suboptimal, our algorithm always returns a tightest possible type. We also discuss in detail how we handle primitive types, which is a difficult issue due to the discrepancy in their treatment between Java bytecode and Java source. For the application to decompilation, however, it is very important to handle this correctly.
[Software notations and tools, Software and its engineering, Compilers]
Efficient software model checking of soundness of type systems
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
This paper presents novel techniques for checking the soundness of a type system automatically using a software model checker. Our idea is to systematically generate every type correct intermediate program state (within some finite bounds), execute the program one step forward if possible using its small step operational semantics, and then check that the resulting intermediate program state is also type correct--but do so efficiently by detecting similarities in this search space and pruning away large portions of the search space. Thus, given only a specification of type correctness and the small step operational semantics for a language, our system automatically checks type soundness by checking that the progress and preservation theorems hold for the language (albeit for program states of at most some finite size). Our preliminary experimental results on several languages--including a language of integer and boolean expressions, a simple imperative programming language, an object-oriented language which is a subset of Java, and a language with ownership types--indicate that our approach is feasible and that our search space pruning techniques do indeed significantly reduce what is otherwise an extremely large search space. Our paper thus makes contributions both in the area of checking soundness of type systems, and in the area of reducing the state space of a software model checker.
[Software defect analysis, Software creation and management, Software functional properties, Software verification and validation, Software notations and tools, Program verification, Theory of computation, Verification by model checking, Semantics and reasoning, Software testing and debugging, Semantics, Program semantics, Model checking, Formal language definitions, Program reasoning, Logic, Formal methods, Software organization and properties, Software and its engineering]
Java type inference is broken: can we fix it?
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Java 5, the most recent major update to the Java Programming Language, introduced a number of sophisticated features, including a major extension to the type system. While the technical details of these new features are complex, much of this complexity is hidden from the typical Java developer by an ambitious type inference mechanism. Unfortunately, the extensions to the Java 5 type system were so novel that their technical details had not yet been thoroughly investigated in the research literature. As a result, the Java 5 compiler includes a pragmatic but flawed type inference algorithm that is, by design, neither sound nor locally complete. The language specification points out that neither of these failures is catastrophic: the correctness of potentially-unsound results must be verified during type checking; and incompleteness can usually be worked around by manually providing the method type parameter bindings for a given call site. This paper dissects the type inference algorithm of Java 5 and proposes a signficant revision that is sound and able to calculate correct results where the Java 5 algorithm fails. The new algorithm is locally complete with the exception of a difficult corner case. Moreover, the new algorithm demonstrates that several arbitrary restrictions in the Java type system---most notably the ban on lower-bounded type parameter declarations and the limited expressibility of intersection types---are unnecessary. We hope that this work will spur the evolution of a more coherent, more comprehensive generic type system for Java.
[Classes and objects, Language features, Object oriented languages, Language types, Software notations and tools, Theory of computation, Semantics and reasoning, Semantics, General programming languages, Program semantics, Formal language definitions, Software and its engineering, Polymorphism]
Delegation-based semantics for modularizing crosscutting concerns
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
We describe semantic mappings of four high-level programming languages to our delegation-based machine model for aspect-oriented programming. One of the languages is a class-based object-oriented one. The other three represent extensions thereof that support various approaches to modularizing crosscutting concerns. We explain informally that an operational semantics expressed in terms of the model's concepts preserves the behavior of a program written in one of the high-level languages. We hence argue our model to be semantically sound in that sense, as well as sufficiently expressive in order to correctly support features such as class-based object-oriented programming, the open-classes and pointcut-and-advice flavors of aspect-oriented programming, and dynamic layers. For the latter, being a core feature of context-oriented programming, we also provide a formal semantics.
[Theory of computation, Semantics and reasoning, Operational semantics, Program semantics]
A theory of aspects as latent topics
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
After more than 10 years, Aspect-Oriented Programming (AOP) is still a controversial idea. While the concept of aspects appeals to everyone's intuitions, concrete AOP solutions often fail to convince researchers and practitioners alike. This discrepancy results in part from a lack of an adequate theory of aspects, which in turn leads to the development of AOP solutions that are useful in limited situations. We propose a new theory of aspects that can be summarized as follows: concerns are latent topics that can be automatically extracted using statistical topic modeling techniques adapted to software. Software scattering and tangling can be measured precisely by the entropies of the underlying topic-over-files and files-over-topics distributions. Aspects are latent topics with high scattering entropy. The theory is validated empirically on both the large scale, with a study of 4,632 Java projects, and the small scale, with a study of 5 individual projects. From these analyses, we identify two dozen topics that emerge as general-purpose aspects across multiple projects, as well as project-specific topics/concerns. The approach is also shown to produce results that are compatible with previous methods for identifying aspects, and also extends them. Our work provides not only a concrete approach for identifying aspects at several scales in an unsupervised manner but, more importantly, a formulation of AOP grounded in information theory. The understanding of aspects under this new perspective makes additional progress toward the design of models and tools that facilitate software development.
[Computing methodologies, Artificial intelligence]
Multiple dispatch in practice
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Multiple dispatch uses the run time types of more than one argument to a method call to determine which method body to run. While several languages over the last 20 years have provided multiple dispatch, most object-oriented languages still support only single dispatch forcing programmers to implement multiple dispatch manually when required. This paper presents an empirical study of the use of multiple dispatch in practice, considering six languages that support multiple dispatch, and also investigating the potential for multiple dispatch in Java programs. We hope that this study will help programmers understand the uses and abuses of multiple dispatch; virtual machine implementors optimise multiple dispatch; and language designers to evaluate the choice of providing multiple dispatch in new programming languages.
[Procedures, functions and subroutines, Software creation and management, General programming languages, Language features, Software notations and tools, Software development techniques, Software and its engineering]
A tag-based approach for the design and composition of information processing applications
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
In the realm of component-based software systems, pursuers of the holy grail of automated application composition face many significant challenges. In this paper we argue that, while the general problem of automated composition in response to high-level goal statements is indeed very difficult to solve, we can realize composition in a restricted context, supporting varying degrees of manual to automated assembly for specific types of applications. We propose a novel paradigm for composition in flow-based information processing systems, where application design and component development are facilitated by the pervasive use of faceted, tag-based descriptions of processing goals, of component capabilities, and of structural patterns of families of application. The facets and tags represent different dimensions of both data and processing, where each facet is modeled as a finite set of tags that are defined in a controlled folksonomy. All data flowing through the system, as well as the functional capabilities of components are described using tags. A customized AI planner is used to automatically build an application, in the form of a flow of components, given a high-level goal specification in the form of a set of tags. End-users use an automatically populated faceted search and navigation mechanism to construct these high-level goals. We also propose a novel software engineering methodology to design and develop a set of reusable, well-described components that can be assembled into a variety of applications. With examples from a case study in the Financial Services domain, we demonstrate that composition using a faceted, tag-based application design is not only possible, but also extremely useful in helping end-users create situational applications from a wide variety of available components.
[Information systems applications, Human-centered computing, Human computer interaction (HCI), Information systems]
Towards adaptive programming: integrating reinforcement learning into a programming language
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Current programming languages and software engineering paradigms are proving insufficient for building intelligent multi-agent systems--such as interactive games and narratives--where developers are called upon to write increasingly complex behavior for agents in dynamic environments. A promising solution is to build adaptive systems; that is, to develop software written specifically to adapt to its environment by changing its behavior in response to what it observes in the world. In this paper we describe a new programming language, An Adaptive Behavior Language (A2BL), that implements adaptive programming primitives to support partial programming, a paradigm in which a programmer need only specify the details of behavior known at code-writing time, leaving the run-time system to learn the rest. Partial programming enables programmers to more easily encode software agents that are difficult to write in existing languages that do not offer language-level support for adaptivity. We motivate the use of partial programming with an example agent coded in a cutting-edge, but non-adaptive agent programming language (ABL), and show how A2BL can encode the same agent much more naturally.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Designed as designer
Proceedings of the 23rd ACM SIGPLAN conference on Object-oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 43 ISSUE 10
2008
Conceptual integrity arises not (simply) from one mind or from a small number of agreeing resonant minds, but from sometimes hidden co-authors and the thing designed itself.
[Document types, General and reference]
Flapjax: a programming language for Ajax applications
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
This paper presents Flapjax, a language designed for contemporary Web applications. These applications communicate with servers and have rich, interactive interfaces. Flapjax provides two key features that simplify writing these applications. First, it provides event streams, a uniform abstraction for communication within a program as well as with external Web services. Second, the language itself is reactive: it automatically tracks data dependencies and propagates updates along those dataflows. This allows developers to write reactive interfaces in a declarative and compositional style. Flapjax is built on top of JavaScript. It runs on unmodified browsers and readily interoperates with existing JavaScript code. It is usable as either a programming language (that is compiled to JavaScript) or as a JavaScript library, and is designed for both uses. This paper presents the language, its design decisions, and illustrative examples drawn from several working Flapjax applications.
[Data flow languages, General programming languages, Language types, Software notations and tools, Software and its engineering]
Empirical assessment of object-oriented implementations with multiple inheritance and static typing
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Object-oriented languages involve a threefold tradeoff between runtime efficiency, expressiveness (multiple inheritance), and modularity, i.e. open-world assumption (OWA). Runtime efficiency is conditioned by both the implementation technique and compilation scheme. The former specifies the data structures that support method invocation, attribute access and subtype testing. The latter consists of the production line of an executable from the source code. Many implementation techniques have been proposed and several compilation schemes can be considered from fully global compilation under the closed-world assumption (CWA) to separate compilation with dynamic loading under the OWA, with midway solutions. This article reviews a significant subset of possible combinations and presents a systematic, empirical comparison of their respective efficiencies with all other things being equal. The testbed consists of the Prm compiler that has been designed for this purpose. The considered techniques include C++ subobjects, coloring, perfect hashing, binary tree dispatch and caching. A variety of processors were considered. Qualitatively, these first results confirm the intuitive or theoretical abstract assessments of the tested approaches. As expected, efficiency increases as CWA strengthens. From a quantitative standpoint, the results are the first to precisely compare the efficiency of techniques that are closely associated with specific languages like C++ and Eiffel. They also confirm that perfect hashing should be considered for implementing Java and .Net interfaces.
[Classes and objects, Language features, Object oriented languages, Language types, Software notations and tools, Record storage systems, Runtime environments, Program constructs, Object oriented constructs, Information systems, Theory of computation, Semantics and reasoning, Information storage systems, General programming languages, Software and its engineering, Compilers]
Parallel programming with object assemblies
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
We present Chorus, a high-level parallel programming model suitable for irregular, heap-manipulating applications like mesh refinement and epidemic simulations, and JChorus, an implementation of the model on top of Java. One goal of Chorus is to express the dynamic and instance-dependent patterns of memory access that are common in typical irregular applications. Its other focus is locality of effects: the property that in many of the same applications, typical imperative commands only affect small, local regions in the shared heap. Chorus addresses dynamism and locality through the unifying abstraction of an object assembly: a local region in a shared data structure equipped with a short-lived, speculative thread of control. The thread of control in an assembly can only access objects within the assembly. While objects can migrate from assembly to assembly, such migration is local--i.e., objects only move from one assembly to a neighboring one--and does not lead to aliasing. Programming primitives include a merge operation, by which an assembly merges with an adjacent assembly, and a split operation, which splits an assembly into smaller ones. Our abstractions are race and deadlock-free, and inherently data-centric. We demonstrate that Chorus and JChorus allow natural programming of several important applications exhibiting irregular data-parallelism. We also present an implementation of JChorus based on a many-to-one mapping of assemblies to lower-level threads, and report on preliminary performance numbers.
[Distributed programming languages, General programming languages, Language types, Software notations and tools, Concurrent programming languages, Parallel programming languages, Software and its engineering]
Grace: safe multithreaded programming for C/C++
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
The shift from single to multiple core architectures means that programmers must write concurrent, multithreaded programs in order to increase application performance. Unfortunately, multithreaded applications are susceptible to numerous errors, including deadlocks, race conditions, atomicity violations, and order violations. These errors are notoriously difficult for programmers to debug. This paper presents Grace, a software-only runtime system that eliminates concurrency errors for a class of multithreaded programs: those based on fork-join parallelism. By turning threads into processes, leveraging virtual memory protection, and imposing a sequential commit protocol, Grace provides programmers with the appearance of deterministic, sequential execution, while taking advantage of available processing cores to run code concurrently and efficiently. Experimental results demonstrate Grace's effectiveness: with modest code changes across a suite of computationally-intensive benchmarks (1-16 lines), Grace can achieve high scalability and performance while preventing concurrency errors.
[Access protection, Software functional properties, Computing methodologies, Parallel computing methodologies, Language types, Software and application security, Software notations and tools, Parallel programming languages, Correctness, Security and privacy, General programming languages, Software security engineering, Software organization and properties, Software and its engineering]
A type and effect system for deterministic parallel Java
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Today's shared-memory parallel programming models are complex and error-prone.While many parallel programs are intended to be deterministic, unanticipated thread interleavings can lead to subtle bugs and nondeterministic semantics. In this paper, we demonstrate that a practical type and effect system can simplify parallel programming by guaranteeing deterministic semantics with modular, compile-time type checking even in a rich, concurrent object-oriented language such as Java. We describe an object-oriented type and effect system that provides several new capabilities over previous systems for expressing deterministic parallel algorithms.We also describe a language called Deterministic Parallel Java (DPJ) that incorporates the new type system features, and we show that a core subset of DPJ is sound. We describe an experimental validation showing thatDPJ can express a wide range of realistic parallel programs; that the new type system features are useful for such programs; and that the parallel programs exhibit good performance gains (coming close to or beating equivalent, nondeterministic multithreaded programs where those are available).
[Distributed programming languages, General programming languages, Language types, Computing methodologies, Parallel computing methodologies, Software notations and tools, Concurrent programming languages, Parallel programming languages, Software and its engineering]
Thorn: robust, concurrent, extensible scripting on the JVM
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Scripting languages enjoy great popularity due to their support for rapid and exploratory development. They typically have lightweight syntax, weak data privacy, dynamic typing, powerful aggregate data types, and allow execution of the completed parts of incomplete programs. The price of these features comes later in the software life cycle. Scripts are hard to evolve and compose, and often slow. An additional weakness of most scripting languages is lack of support for concurrency - though concurrency is required for scalability and interacting with remote services. This paper reports on the design and implementation of Thorn, a novel programming language targeting the JVM. Our principal contributions are a careful selection of features that support the evolution of scripts into industrial grade programs - e.g., an expressive module system, an optional type annotation facility for declarations, and support for concurrency based on message passing between lightweight, isolated processes. On the implementation side, Thorn has been designed to accommodate the evolution of the language itself through a compiler plugin mechanism and target the Java virtual machine.
[Classes and objects, Language features, Object oriented languages, Concurrent programming structures, Language types, Software notations and tools, Parallel programming languages, Modules / packages, Distributed programming languages, General programming languages, Data types and structures, Concurrent programming languages, Software and its engineering]
How a Java VM can get more from a hardware performance monitor
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
This paper describes our sampling-based profiler that exploits a processor's HPM (Hardware Performance Monitor) to collect information on running Java applications for use by the Java VM. Our profiler provides two novel features: Java-level event profiling and lightweight context-sensitive event profiling. For Java events, we propose new techniques to leverage the sampling facility of the HPM to generate object creation profiles and lock activity profiles. The HPM sampling is the key to achieve a smaller overhead compared to profilers that do not rely on hardware helps. To sample the object creations with the HPM, which can only sample hardware events such as executed instructions or cache misses, we correlate the object creations with the store instructions for Java object headers. For the lock activity profile, we introduce an instrumentation-based technique, called ProbeNOP, which uses a special NOP instruction whose executions are counted by the HPM. For the context-sensitive event profiling, we propose a new technique called CallerChaining, which detects the calling context of HPM events based on the call stack depth (the value of the stack frame pointer). We show that it can detect the calling contexts in many programs including a large commercial application. Our proposed techniques enable both programmers and runtime systems to get more valuable information from the HPM to understand and optimize the programs without adding significant runtime overhead.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
A concurrent dynamic analysis framework for multicore hardware
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Software has spent the bounty of Moore's law by solving harder problems and exploiting abstractions, such as high-level languages, virtual machine technology, binary rewriting, and dynamic analysis. Abstractions make programmers more productive and programs more portable, but usually slow them down. Since Moore's law is now delivering multiple cores instead of faster processors, future systems must either bear a relatively higher cost for abstractions or use some cores to help tolerate abstraction costs. This paper presents the design, implementation, and evaluation of a novel concurrent, configurable dynamic analysis framework that efficiently utilizes multicore cache architectures. It introduces Cache-friendly Asymmetric Buffering (CAB), a lock-free ring-buffer that implements efficient communication between application and analysis threads. We guide the design and implementation of our framework with a model of dynamic analysis overheads. The framework implements exhaustive and sampling event processing and is analysis-neutral. We evaluate the framework with five popular and diverse analyses, and show performance improvements even for lightweight, low-overhead analyses. Efficient inter-core communication is central to high performance parallel systems and we believe the CAB design gives insight into the subtleties and difficulties of attaining it for dynamic analysis and other parallel software.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Inferred call path profiling
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Prior work has found call path profiles to be useful for optimizers and programmer-productivity tools. Unfortunately, previous approaches for collecting path profiles are expensive: they need to either execute additional instructions (to track calls and returns) or they need to walk the stack. The state-of-the-art techniques for call path profiling slow down the program by 7% (for C programs) and 20% (for Java programs). This paper describes an innovative technique that collects minimal information from the running program and later (offline) infers the full call paths from this information. The key insight behind our approach is that readily available information during program execution - the height of the call stack and the identity of the current executing function - are good indicators of calling context. We call this pair a context identifier. Because more than one call path may have the same context identifier, we show how to disambiguate context identifiers by changing the sizes of function activation records. This disambiguation has no overhead in terms of executed instructions. We evaluate our approach on the SPEC CPU 2006 C++ and C benchmarks. We show that collecting context identifiers slows down programs by 0.17% (geometric mean). We can map these context identifiers to the correct unique call path 80% of the time for C++ programs and 95% of the time for C programs.
[Hardware validation, Hardware]
Accelerating the creation of customized, language-Specific IDEs in Eclipse
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Full-featured integrated development environments have become critical to the adoption of new programming languages. Key to the success of these IDEs is the provision of services tailored to the languages. However, modern IDEs are large and complex, and the cost of constructing one from scratch can be prohibitive. Generators that work from language specifications reduce costs but produce environments that do not fully reflect distinctive language characteristics. We believe that there is a practical middle ground between these extremes that can be effectively addressed by an open, semi-automated strategy to IDE development. This strategy is to reduce the burden of IDE development as much as possible, especially for internal IDE details, while opening opportunities for significant customizations to IDE services. To reduce the effort needed for customization we provide a combination of frameworks, templates, and generators. We demonstrate an extensible IDE architecture that embodies this strategy, and we show that this architecture can be used to produce customized IDEs, with a moderate amount of effort, for a variety of interesting languages.
[Integrated and visual development environments, Software notations and tools, Development frameworks and environments, Software and its engineering]
Debug all your code: portable mixed-environment debugging
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Programmers build large-scale systems with multiple languages to reuse legacy code and leverage languages best suited to their problems. For instance, the same program may use Java for ease-of-programming and C to interface with the operating system. These programs pose significant debugging challenges, because programmers need to understand and control code across languages, which may execute in different environments. Unfortunately, traditional multilingual debuggers require a single execution environment. This paper presents a novel composition approach to building portable mixed-environment debuggers, in which an intermediate agent interposes on language transitions, controlling and reusing single-environment debuggers. We implement debugger composition in Blink, a debugger for Java, C, and the Jeannie programming language. We show that Blink is (1) relatively simple: it requires modest amounts of new code; (2) portable: it supports multiple Java Virtual Machines, C compilers, operating systems, and component debuggers; and (3) powerful: composition eases debugging, while supporting new mixed-language expression evaluation and Java Native Interface (JNI) bug diagnostics. In real-world case studies, we show that language-interface errors require single-environment debuggers to restart execution multiple times, whereas Blink directly diagnoses them with one execution. We also describe extensions for other mixed-environments to show debugger composition will generalize.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
The design of a task parallel library
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
The Task Parallel Library (TPL) is a library for .NET that makes it easy to take advantage of potential parallelism in a program. The library relies heavily on generics and delegate expressions to provide custom control structures expressing structured parallelism such as map-reduce in user programs. The library implementation is built around the notion of a task as a finite CPU-bound computation. To capture the ubiquitous apply-to-all pattern the library also introduces the novel concept of a replicable task. Tasks and replicable tasks are assigned to threads using work stealing techniques, but unlike traditional implementations based on the THE protocol, the library uses a novel data structure called a 'duplicating queue'. A surprising feature of duplicating queues is that they have sequentially inconsistent behavior on architectures with weak memory models, but capture this non-determinism in a benign way by sometimes duplicating elements. TPL ships as part of the Microsoft Parallel Extensions for the .NET framework 4.0, and forms the foundation of Parallel LINQ queries (however, note that the productized TPL library may differ in significant ways from the basic design described in this article).
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
Strictly declarative specification of sophisticated points-to analyses
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
We present the DOOP framework for points-to analysis of Java programs. DOOP builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. We carry the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively using a novel technique specifically targeting highly recursive Datalog programs. As a result, DOOP achieves several benefits, including full order-of-magnitude improvements in runtime. We compare DOOP with Lhotak and Hendren's PADDLE, which defines the state of the art for context-sensitive analyses. For the exact same logical points-to definitions (and, consequently, identical precision) DOOP is more than 15x faster than PADDLE for a 1-call-site sensitive analysis of the DaCapo benchmarks, with lower but still substantial speedups for other important analyses. Additionally, DOOP scales to very precise analyses that are impossible with PADDLE and Whaley et al.'s bddbddb, directly addressing open problems in past literature. Finally, our implementation is modular and can be easily configured to analyses with a wide range of characteristics, largely due to its declarativeness.
[Logic programming and answer set programming, Computing methodologies, Language types, Software notations and tools, Program analysis, Knowledge representation and reasoning, Theory of computation, Constraint and logic languages, Semantics and reasoning, General programming languages, Program semantics, Program reasoning, Artificial intelligence, Software and its engineering]
Self type constructors
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Bruce and Foster proposed the language LOOJ, an extension of Java with the notion of MyType, which represents the type of a self reference and changes its meaning along with inheritance. MyType is useful to write extensible yet type-safe classes for objects with recursive interfaces, that is, ones with methods that take or return objects of the same type as the receiver. Although LOOJ has also generics, MyType has been introduced as a feature rather orthogonal to generics. As a result, LOOJ cannot express an interface that refers to the same generic class recursively but with different type arguments. This is a significant limitation because such an interface naturally arises in practice, for example, in a generic collection class with method map(), which converts a collection to the same kind of collection of a different element type. Altherr and Cremet and Moors, Piessens, and Odersky gave solutions to this problem but they used a highly sophisticated combination of advanced mechanisms such as abstract type members, higher-order type constructors, and F-bounded polymorphism. In this paper, we give another solution by introducing self type constructors, which integrate MyType and generics so that MyType can take type arguments in a generic class. Self type constructors are tailored to writing recursive interfaces more concicely than previous solutions. We demonstrate the expressive power of self type constructors by means of examples, formalize a core language with self type constructors, and prove its type safety.
[Classes and objects, General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Profile-guided static typing for dynamic scripting languages
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Many popular scripting languages such as Ruby, Python, and Perl include highly dynamic language constructs, such as an eval method that evaluates a string as program text. While these constructs allow terse and expressive code, they have traditionally obstructed static analysis. In this paper we present PRuby, an extension to Diamondback Ruby (DRuby), a static type inference system for Ruby. PRuby augments DRuby with a novel dynamic analysis and transformation that allows us to precisely type uses of highly dynamic constructs. PRuby's analysis proceeds in three steps. First, we use run-time instrumentation to gather per-application profiles of dynamic feature usage. Next, we replace dynamic features with statically analyzable alternatives based on the profile. We also add instrumentation to safely handle cases when subsequent runs do not match the profile. Finally, we run DRuby's static type inference on the transformed code to enforce type safety. We used PRuby to gather profiles for a benchmark suite of sample Ruby programs. We found that dynamic features are pervasive throughout the benchmarks and the libraries they include, but that most uses of these features are highly constrained and hence can be effectively profiled. Using the profiles to guide type inference, we found that DRuby can generally statically type our benchmarks modulo some refactoring, and we discovered several previously unknown type errors. These results suggest that profiling and transformation is a lightweight but highly effective approach to bring static typing to highly dynamic languages.
[Theory of computation, Traceability, Software creation and management, Semantics and reasoning, Software verification and validation, Process validation, Program semantics, Program reasoning, Program analysis, Software and its engineering]
Enhancing source-level programming tools with an awareness of transparent program transformations
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Programs written in managed languages are compiled to a platform-independent intermediate representation, such as Java bytecode. The relative high level of Java bytecode has engendered a widespread practice of changing the bytecode directly, without modifying the maintained version of the source code. This practice, called bytecode engineering or enhancement, has become indispensable in introducing various concerns, including persistence, distribution, and security, transparently. For example, transparent persistence architectures help avoid the entanglement of business and persistence logic in the source code by changing the bytecode directly to synchronize objects with stable storage. With functionality added directly at the bytecode level, the source code reflects only partial semantics of the program. Specifically, the programmer can neither ascertain the program's runtime behavior by browsing its source code, nor map the runtime behavior back to the original source code. This paper presents an approach that improves the utility of source-level programming tools by providing enhancement specifications written in a domain-specific language. By interpreting the specifications, a source-level programming tool can gain an awareness of the bytecode enhancements and improve its precision and usability. We demonstrate the applicability of our approach by making a source code editor and a symbolic debugger enhancements-aware.
[Software defect analysis, Traceability, Software creation and management, Software testing and debugging, Software verification and validation, Process validation, Interpreters, Software notations and tools, Development frameworks and environments, Software and its engineering, Compilers]
Static extraction and conformance analysis of hierarchical runtime architectural structure using annotations
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
An object diagram makes explicit the object structures that are only implicit in a class diagram. An object diagram may be missing and must extracted from the code. Alternatively, an existing diagram may be inconsistent with the code, and must be analyzed for conformance with the implementation. One can generalize the global object diagram of a system into a runtime architecture which abstracts objects into components, represents how those components interact, and can decompose a component into a nested sub-architecture. A static object diagram represents all objects and inter-object relations possibly created, and is recovered by static analysis of a program. Existing analyses extract static object diagrams that are non-hierarchical, do not scale, and do not provide meaningful architectural abstraction. Indeed, architectural hierarchy is not readily observable in arbitrary code. Previous approaches used breaking language extensions to specify hierarchy and instances in code, or used dynamic analyses to extract dynamic object diagrams that show objects and relations for a few program runs. Typecheckable ownership domain annotations use existing language support for annotations and specify in code object encapsulation, logical containment and architectural tiers. These annotations enable a points-to static analysis to extract a sound global object graph that provides architectural abstraction by ownership hierarchy and by types, where architecturally significant objects appear near the top of the hierarchy and data structures are further down. Another analysis can abstract an object graph into a built runtime architecture. Then, a third analysis can compare the built architecture to a target, analyze and measure their structural conformance, establish traceability between the two and identify interesting differences.
[Classes and objects, General programming languages, Language features, Software notations and tools, Software and its engineering]
Demystifying model transformations: an approach based on automated rule inference
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Model-driven development (MDD) is widely used to develop modern business applications. MDD involves creating models at different levels of abstractions. Starting with models of domain concepts, these abstractions are successively refined, using transforms, to design-level models and, eventually, code-level artifacts. Although many tools exist that support transform creation and verification, tools that help users in understanding and using transforms are rare. In this paper, we present an approach for assisting users in understanding model transformations and debugging their input models. We use automated program-analysis techniques to analyze the transform code and compute constraints under which a transformation may fail or be incomplete. These code-level constraints are mapped to the input model elements to generate model-level rules. The rules can be used to validate whether an input model violates transform constraints, and to support general user queries about a transformation. We have implemented the analysis in a tool called XYLEM. We present empirical results, which indicate that (1) our approach can be effective in inferring useful rules, and (2) the rules let users efficiently diagnose a failing transformation without examining the transform source code.
[Software defect analysis, Theory of computation, Software creation and management, Software testing and debugging, Semantics and reasoning, Software verification and validation, Program semantics, Program reasoning, Program analysis, Software and its engineering]
Allocation wall: a limiting factor of Java applications on emerging multi-core platforms
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Multi-core processors are widely used in computer systems. As the performance of microprocessors greatly exceeds that of memory, the memory wall becomes a limiting factor. It is important to understand how the large disparity of speed between processor and memory influences the performance and scalability of Java applications on emerging multi-core platforms. In this paper, we studied two popular Java benchmarks, SPECjbb2005 and SPECjvm2008, on multi-core platforms including Intel Clovertown and AMD Phenom. We focus on the "partially scalable" benchmark programs. With smaller number of CPU cores these programs scale perfectly, but when more cores and software threads are used, the slope of the scalability curve degrades dramatically. We identified a strong correlation between scalability, object allocation rate and memory bus write traffic in our experiments with our partially scalable programs. We find that these applications allocate large amounts of memory and consume almost all the memory write bandwidth in our hardware platforms. Because the write bandwidth is so limited, we propose the following hypothesis: the scalability and performance is limited by the object allocation on emerging multi-core platforms for those objects-allocation intensive Java applications, as if these applications are running into an "allocation wall". In order to verify this hypothesis, several experiments are performed, including measuring key architecture level metrics, composing a micro-benchmark program, and studying the effect of modifying some of the "partially scalable" programs. All the experiments strongly suggest the existence of the allocation wall.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
NUMA-aware memory manager with dominant-thread-based copying GC
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
We propose a novel online method of identifying the preferred NUMA nodes for objects with negligible overhead during the garbage collection time as well as object allocation time. Since the number of CPUs (or NUMA nodes) is increasing recently, it is critical for the memory manager of the runtime environment of an object-oriented language to exploit the low latency of local memory for high performance. To locate the CPU of a thread that frequently accesses an object, prior research uses the runtime information about memory accesses as sampled by the hardware. However, the overhead of this approach is high for a garbage collector. Our approach uses the information about which thread can exclusively access an object, or the Dominant Thread (DoT). The dominant thread of an object is the thread that often most accesses an object so that we do not require memory access samples. Our NUMA-aware GC performs DoT based object copying, which copies each live object to the CPU where the dominant thread was last dispatched before GC. The dominant thread information is known from the thread stack and from objects that are locked or reserved by threads and is propagated in the object reference graph. We demonstrate that our approach can improve the performance of benchmark programs such as SPECpower ssj2008, SPECjbb2005, and SPECjvm2008.We prototyped a NUMAaware memory manager on a modified version of IBM Java VM and tested it on a cc-NUMA POWER6 machine with eight NUMA nodes. Our NUMA-aware GC achieved performance improvements up to 14.3% and 2.0% on average over a JVM that only used the NUMA-aware allocator. The total improvement using both the NUMA-aware allocator and GC is up to 53.1% and 10.8% on average.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Executing code in the past: efficient in-memory object graph versioning
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Object versioning refers to how an application can have access to previous states of its objects. Implementing this mechanism is hard because it needs to be efficient in space and time, and well integrated with the programming language. This paper presents HistOOry, an object versioning system that uses an efficient data structure to store and retrieve past states. It needs only three primitives, and existing code does not need to be modified to be versioned. It provides fine-grained control over what parts of objects are versioned and when. It stores all states, past and present, in memory. Code can be executed in the past of the system and will see the complete system at that point in time. We have implemented our model in Smalltalk and used it for three applications that need versioning: checked postconditions, stateful execution tracing and a planar point location implementation. Benchmarks are provided to asses the practical complexity of our implementation.
[Classes and objects, General programming languages, Language features, Object oriented languages, Data types and structures, Language types, Software notations and tools, Software and its engineering]
Optimizing programs with intended semantics
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Modern object-oriented languages have complex features that cause programmers to overspecify their programs. This overspecification hinders automatic optimizers, since they must preserve the overspecified semantics. If an optimizer knew which semantics the programmer intended, it could do a better job. Making a programmer clarify his intentions by placing assumptions into the program is rarely practical. This is because the programmer does not know which parts of the programs' overspecified semantics hinder the optimizer. Therefore, the programmer has to guess which assumption to add. Since the programmer can add many different assumptions to a large program, he will need to place many such assumptions before he guesses right and helps the optimizer. We present IOpt, a practical optimizer that uses a specification of the programmers' intended semantics to enable additional optimizations. That way, our optimizer can significantly improve the performance of a program. We present case studies in which we use IOpt to speed up two programs by a factor of 2. To make specifying the intended semantics practical, IOpt communicates with the programmer. IOpt identifies which assumptions the programmer should place, and where he should place them. IOpt ranks each assumption by (i) the likelyhood that the assumption conforms to the programmers' intended semantics and (ii) how much the assumption will help IOpt improve the programs' performance. IOpt proposes ranked assumptions to the programmer, who just picks those that conform to his intended semantics.With this approach, IOpt keeps the programmers' specification burden low. In our case studies, programmers had to add just a few assumptions to realize significant performance speedups.
[Software notations and tools, Development frameworks and environments, Software and its engineering, Compilers]
Minimizing dependencies within generic classes for faster and smaller programs
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Generic classes can be used to improve performance by allowing compile-time polymorphism. But the applicability of compile-time polymorphism is narrower than that of runtime polymorphism, and it might bloat the object code. We advocate a programming principle whereby a generic class should be implemented in a way that minimizes the dependencies between its members (nested types, methods) and its generic type parameters. Conforming to this principle (1) reduces the bloat and (2) gives rise to a previously unconceived manner of using the language that expands the applicability of compile-time polymorphism to a wider range of problems. Our contribution is thus a programming technique that generates faster and smaller programs. We apply our ideas to GCC's STL containers and iterators, and we demonstrate notable speedups and reduction in object code size (real application runs 1.2x to 2.1x faster and STL code is 1x to 25x smaller). We conclude that standard generic APIs (like STL) should be amended to reflect the proposed principle in the interest of efficiency and compactness. Such modifications will not break old code, simply increase flexibility. Our findings apply to languages like C++, C#, and D, which realize generic programming through multiple instantiations.
[General programming languages, Language features, Data types and structures, Software notations and tools, Software and its engineering, Polymorphism]
Providing rapid feedback in generated modular language environments: adding error recovery to scannerless generalized-LR parsing
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Integrated development environments (IDEs) increase programmer productivity, providing rapid, interactive feedback based on the syntax and semantics of a language. A heavy burden lies on developers of new languages to provide adequate IDE support. Code generation techniques provide a viable, efficient approach to semi-automatically produce IDE plugins. Key components for the realization of plugins are the language's grammar and parser. For embedded languages and language extensions, constituent IDE plugin modules and their grammars can be combined. Unlike conventional parsing algorithms, scannerless generalized-LR parsing supports the full set of context-free grammars, which is closed under composition, and hence can parse language embeddings and extensions composed from separate grammar modules. To apply this algorithm in an interactive environment, this paper introduces a novel error recovery mechanism, which allows it to be used with files with syntax errors -- common in interactive editing. Error recovery is vital for providing rapid feedback in case of syntax errors, as most IDE services depend on the parser from syntax highlighting to semantic analysis and cross-referencing. We base our approach on the principles of island grammars, and derive permissive grammars with error recovery productions from normal SDF grammars. To cope with the added complexity of these grammars, we adapt the parser to support backtracking. We evaluate the recovery quality and performance of our approach using a set of composed languages, based on Java and Stratego.
[Parsers, Software notations and tools, Software and its engineering, Compilers]
Onward! Chair's Welcome
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
None
2009
None
[]
Design pattern density defined
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Design pattern density is a metric that measures how much of an object-oriented design can be understood and represented as instances of design patterns. Expert developers have long believed that a high design pattern density implies a high maturity of the design under inspection. This paper presents a quantifiable and observable definition of this metric. The metric is illustrated and qualitatively validated using four real-world case studies. We present several hypotheses of the metric's meaning and their implications, including the one about design maturity. We propose that the design pattern density of a maturing framework has a fixed point and we show that if software design patterns make learning frameworks easier, a framework's design pattern density is a measure of how much easier it will become.
[Cross-computing tools and techniques, Language features, Software notations and tools, Client-server architectures, Software architectures, Distributed systems organizing principles, Software system structures, Metrics, General programming languages, General and reference, Patterns, Software organization and properties, Software and its engineering]
Writing code for other people: cognitive psychology and the fundamentals of good software design principles
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
This paper demonstrates how the cognitive model of the mind can explain the core fundamentals behind widely accepted design principles. The conclusion is that software design is largely a task of chunking analogies and presents a theory that is detailed enough to be accessible to even the most inexperienced programmer. The corollary of which is a pedagogical approach to understanding design principles rather than the necessity of years of software development experience.
[Applied computing, Software creation and management, Object oriented development, Psychology, Software notations and tools, Object oriented frameworks, Law, social and behavioral sciences, Development frameworks and environments, Software development techniques, Software and its engineering]
Regrowing a language: refactoring tools allow programming languages to evolve
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Successful programming languages change as they age. They tend to become more complex, and eventually some features become outdated or are rarely used. Programming tools for these languages become more complex as well, since they have to support archaic features. Old programs are hard to maintain, since these archaic features are unfamiliar to modern programmers. These problems can be solved by refactoring tools that can transform programs to use the modern form. We show that refactoring tools can ease the cost of program evolution by examining the evolution of two languages, Fortran and Java, and showing that each change corresponds to an automatable refactoring.
[General programming languages, Software notations and tools, Software and its engineering]
&#960;: a pattern language
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Current programming languages and techniques realize many features which allow their users to extend these languages on a semantic basis: classes, functions, interfaces, aspects and other entities can be defined. However, there is a lack of modern programming languages which are both semantically and syntactically extensible from within the language itself, i.e., with no additional tool or meta-language. In this paper we present &#960; as an approach that aims to overcome this lack. &#960; provides an abstraction mechanism based on parameterized symbols which is capable of semantically and syntactically unifying programming concepts like variables, control-structures, procedures and functions into one concept: the pattern. We have evaluated the abstraction potential and the syntactic extensibility of &#960; by successfully creating patterns for the aforementioned programming concepts. &#960; could serve as a tool for designing new experimental languages and might generally influence the view we have on current programming concepts.
[Extensible languages, General programming languages, Language features, Language types, Software notations and tools, Patterns, Software and its engineering]
Software evolution and the moving picture metaphor
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
Software systems evolve over time. Currently we do not do a good job of documenting this evolution. This essay discusses the need to better document software evolution and introduces the Moving Picture Metaphor. Source Control Management systems are more like collections of still photographs than moving pictures. Still photography is not ideal when trying to capture evolutional changes. Moving pictures do a much better job. A storyteller can use moving pictures to tell compelling stories that are easier to digest than traditional documentation. We can learn a great deal from watching stories that document a system's evolution.
[Software creation and management, Documentation, Software post-development issues, Software and its engineering]
Agile anthropology and Alexander's architecture: an essay in three voices
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
During its formative decades the software community looked twice to the theories of Christopher Alexander for inspiration, both times failing to completely master the architect's most useful insights. Now a third opportunity presents itself with Alexander's recent publication, The Nature of Order. Serious apprenticeship, however, imposes a prerequisite of sober self-reflection and evaluation. What, really, is the nature of the developer's tasks? Under what philosophical umbrella has the software community matured until now? Do other philosophical traditions offer alternative and perhaps more pertinent epistemologies? What voices, besides Alexander's, might contribute to the community's evolution? We address these questions along with theory building, ethnography, weak links, design heuristics, agility, and complex systems, all of which combine with Alexander's new theories to suggest different ways of doing what we do, better.
[Professional topics, Social and professional topics]
An exploration of program as language
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
In this paper we explore the idea that the code that constitutes a program actually forms a higher-level, program specific language. The symbols of the language are the abstractions of the program, and the grammar of the language is the set of (generally unwritten) rules about the allowable combinations of those abstractions. As such, a program is both a language definition, and the only use of that language. This specificity means that reading a never-before encountered program involves learning a new natural language, and that porting code from one program to another requires translation from one natural language into another. We suggest that the complexity and depth of the program language is affected by the gap between the program semantics (what the program is meant to do) and the code semantics (the way in which the machine runs). We believe that in seeing that programs are languages, we gain new insight into our own experience as programmers, and are able to gain new perspective on the intense complexity of code and its creation.
[Very high level languages, General programming languages, Language types, Software notations and tools, Software and its engineering]
On understanding data abstraction, revisited
Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 44 ISSUE 10
2009
In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called "On understanding types, data abstraction, and polymorphism". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, abstract data types and objects. This essay attempts to explain the differences and also why the differences matter.
[Classes and objects, General programming languages, Language features, Software notations and tools, Abstract data types, Software and its engineering]
The case for evolvable software
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
As programmers, we like to think of software as the product of our intelligent design, carefully crafted to meet well-specified goals. In reality, software evolves inadvertently through the actions of many individual programmers, often leading to unanticipated consequences. Large complex software systems are subject to constraints similar to those faced by evolving biological systems, and we have much to gain by viewing software through the lens of evolutionary biology. The talk will highlight recent research that applies the mechanisms of evolution quite directly to the problem of repairing software bugs.
[Management of computing and information systems, Software maintenance, Software creation and management, Software development methods, Professional topics, Software notations and tools, Object oriented frameworks, Software post-development issues, Development frameworks and environments, Software development techniques, Software development process management, Software management, Object oriented development, Social and professional topics, Software and its engineering]
To achieve our highest goals, we must be willing to abandon them
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Someday computer scientists may build systems of astronomical complexity that provide profound benefit to humanity. However, the question today is how such feats will ultimately be achieved. As is common with technology, present limitations to modern approaches challenge our imagination to search for new paradigms and organizing principles. To examine the prerequisites to achieving our most ambitious objectives, this talk will contemplate the implications of recent counterintuitive results from experiments with evolutionary algorithms that suggest that search (which is a metaphor for innovation in general) is sometimes most effective when it is not explicitly seeking an objective. In particular, through several experiments in interactive evolution and with an algorithm called "novelty search," a picture of innovation is emerging in which objectives can help to guide us one stepping-stone away from our present understanding, yet ultimately become handcuffs that also blind us to essential orthogonal discoveries on the road to long-term innovation. While the implications of these insights for reaching our highest goals are in part sobering, the silver lining is that much can be gained by liberating ourselves from the temptation to frame all our projects in terms of what they ultimately aim to achieve. Instead, with evidence in hand, we can exploit the structure of the unknown by orienting ourselves towards discovery and away from the shackles of mandated outcomes.
[Computing methodologies, Social and professional topics]
F#: Taking Succinct, Efficient, Typed Functional Programming into the Mainstream
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
None
[]
Efficient modular glass box software model checking
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Glass box software model checking incorporates novel techniques to identify similarities in the state space of a model checker and safely prune large numbers of redundant states without explicitly checking them. It is significantly more efficient than other software model checking approaches for checking certain kinds of programs and program properties. This paper presents Pipal, a system for modular glass box software model checking. Extending glass box software model checking to perform modular checking is important to further improve its scalability. It is nontrivial because unlike traditional software model checkers such as Java PathFinder (JPF) and CMC, a glass box software model checker does not check every state separately---instead, it checks a large set of states together in each step. We present a solution and demonstrate Pipal's effectiveness on a variety of programs.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Software notations and tools, Verification, Formal languages and automata theory, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Formal language definitions, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
An experiment about static and dynamic type systems: doubts about the positive impact of static type systems on development time
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Although static type systems are an essential part in teach-ing and research in software engineering and computer science, there is hardly any knowledge about what the impact of static type systems on the development time or the resulting quality for a piece of software is. On the one hand there are authors that state that static type systems decrease an application's complexity and hence its development time (which means that the quality must be improved since developers have more time left in their projects). On the other hand there are authors that argue that static type systems increase development time (and hence decrease the code quality) since they restrict developers to express themselves in a desired way. This paper presents an empirical study with 49 subjects that studies the impact of a static type system for the development of a parser over 27 hours working time. In the experiments the existence of the static type system has neither a positive nor a negative impact on an application's development time (under the conditions of the experiment).
[General programming languages, Language features, Software notations and tools, Software and its engineering]
A simple inductive synthesis methodology and its applications
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Given a high-level specification and a low-level programming language, our goal is to automatically synthesize an efficient program that meets the specification. In this paper, we present a new algorithmic methodology for inductive synthesis that allows us to do this. We use Second Order logic as our generic high level specification logic. For our low-level languages we choose small application-specific logics that can be immediately translated into code that runs in expected linear time in the worst case. We explain our methodology and provide examples of the synthesis of several graph classifiers, e.g, linear-time tests of whether the input graph is connected, acyclic, etc. In another set of applications we automatically derive many finite differencing expressions equivalent to ones that Paige built by hand in his thesis [Pai81]. Finally we describe directions for automatically combining such automatically generated building blocks to synthesize efficient code implementing more complicated specifications. The methods in this paper have been implemented in Python using the SMT solver Z3 [dMB].
[Theory of computation, Semantics and reasoning, Semantics, Program semantics, Formal language definitions, Software notations and tools, Software and its engineering]
A domain-specific approach to architecturing error handling in pervasive computing
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
The challenging nature of error handling constantly escalates as a growing number of environments consists of networked devices and software components. In these environments, errors cover a uniquely large spectrum of situations related to each layer ranging from hardware to distributed platforms, to software components. Handling errors becomes a daunting task for programmers, whose outcome is unpredictable. Scaling up error handling requires to raise the level of abstraction beyond the code level and the try-catch construct, approaching error handling at the software architecture level. We propose a novel approach that relies on an Architecture Description Language (ADL), which is extended with error-handling declarations. To further raise the level of abstraction, our approach revolves around a domain-specific architectural pattern commonly used in pervasive computing. Error handling is decomposed into components dedicated to platform-wide, error-recovery strategies. At the application level, descriptions of functional components include declarations dedicated to error handling. We have implemented a compiler for an ADL extended with error-handling declarations. It produces customized programming frameworks that drive and support the programming of error handling. Our approach has been validated with a variety of applications for building automation.
[Software system structures, Context specific languages, Software notations and tools, Software architectures, Software organization and properties, Software and its engineering, Domain specific languages]
G-Finder: routing programming questions closer to the experts
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Programming forums are becoming the primary tools for programmers to find answers for their programming problems. Our empirical study of popular programming forums shows that the forum users experience long waiting period for answers and a small number of experts are often overloaded with questions. To improve the usage experience, we have designed and implemented G-Finder, both an algorithm and a tool that makes intelligent routing decisions as to which participant is the expert for answering a particular programming question. Our main approach is to leverage the source code information of the software systems that forums are dedicated to, and discover latent relationships between forums users. Our algorithms construct the concept networks and the user networks from the program source and the forum data.We use programming questions to dynamically integrate these two networks and present an adaptive ranking of the potential experts. Our evaluation of G-Finder, using the data from three large programming forums, takes a retrospective view to check if G-Finder can correctly predict the experts who provided answers to programming questions. The evaluation results show that G-Finder improves the prediction precision by 25% to 74%, compared to related approaches.
[Software notations and tools, Development frameworks and environments, Software and its engineering]
Agility in context
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Evangelists for Agile methods strongly encourage all projects to follow every practice of their chosen method. Based on a Grounded Theory study involving 40 participants at 16 organizations, and corroborated by 4 independent case studies, we argue that development methods and practices must be adapted to fit their contexts. Understanding Agility in context will help development teams, their managers, and Agile coaches to adapt development processes to fit their projects' contexts.
[Software configuration management and version control systems, Management of computing and information systems, Project and people management, Software development process management, Software creation and management, Professional topics, Software notations and tools, Social and professional topics, Software and its engineering]
Lime: a Java-compatible and synthesizable language for heterogeneous architectures
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
The halt in clock frequency scaling has forced architects and language designers to look elsewhere for continued improvements in performance. We believe that extracting maximum performance will require compilation to highly heterogeneous architectures that include reconfigurable hardware. We present a new language, Lime, which is designed to be executable across a broad range of architectures, from FPGAs to conventional CPUs. We present the language as a whole, focusing on its novel features for limiting side-effects and integration of the streaming paradigm into an object- oriented language. We conclude with some initial results demonstrating applications running either on a CPU or co- executing on a CPU and an FPGA.
[Integrated circuits, Logic circuits, General programming languages, Language features, Software notations and tools, Hardware, Software and its engineering]
From OO to FPGA: fitting round objects into square hardware?
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Consumer electronics today such as cell phones often have one or more low-power FPGAs to assist with energyintensive operations in order to reduce overall energy consumption and increase battery life. However, current techniques for programming FPGAs require people to be specially trained to do so. Ideally, software engineers can more readily take advantage of the benefits FPGAs offer by being able to program them using their existing skills, a common one being object-oriented programming. However, traditional techniques for compiling object-oriented languages are at odds with today's FPGA tools, which support neither pointers nor complex data structures. Open until now is the problem of compiling an object-oriented language to an FPGA in a way that harnesses this potential for huge energy savings. In this paper, we present a new compilation technique that feeds into an existing FPGA tool chain and produces FPGAs with up to almost an order of magnitude in energy savings compared to a low-power microprocessor while still retaining comparable performance and area usage.
[Software notations and tools, Software and its engineering, Compilers]
An input-centric paradigm for program dynamic optimizations
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Accurately predicting program behaviors (e.g., locality, dependency, method calling frequency) is fundamental for program optimizations and runtime adaptations. Despite decades of remarkable progress, prior studies have not systematically exploited program inputs, a deciding factor for program behaviors. Triggered by the strong and predictive correlations between program inputs and behaviors that recent studies have uncovered, this work proposes to include program inputs into the focus of program behavior analysis, cultivating a new paradigm named input-centric program behavior analysis. This new approach consists of three components, forming a three-layer pyramid. At the base is program input characterization, a component for resolving the complexity in program raw inputs and the extraction of important features. In the middle is input-behavior modeling, a component for recognizing and modeling the correlations between characterized input features and program behaviors. These two components constitute input-centric program behavior analysis, which (ideally) is able to predict the large-scope behaviors of a program's execution as soon as the execution starts. The top layer of the pyramid is input-centric adaptation, which capitalizes on the novel opportunities that the first two components create to facilitate proactive adaptation for program optimizations. By centering on program inputs, the new approach resolves a proactivity-adaptivity dilemma inherent in previous techniques. Its benefits are demonstrated through proactive dynamic optimizations and version selection, yielding significant performance improvement on a set of Java and C programs.
[Software notations and tools, Software and its engineering, Compilers]
Composable specifications for structured shared-memory communication
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
In this paper we propose a communication-centric approach to specifying and checking how multithreaded programs use shared memory to perform inter-thread communication. Our approach complements past efforts for improving the safety of multithreaded programs such as race detection and atomicity checking. Unlike prior work, we focus on what pieces of code are allowed to communicate with one another, as opposed to declaring what data items are shared or what code blocks should be atomic. We develop a language that supports composable specifications at multiple levels of abstraction and that allows libraries to specify whether or not shared-memory communication is exposed to clients. The precise meaning of a specification is given with a formal semantics we present. We have developed a dynamic-analysis tool for Java that observes program execution to see if it obeys a specification. We report results for using the tool on several benchmark programs to which we added specifications, concluding that our approach matches the modular structure of multithreaded applications and that our tool is performant enough for use in development and testing.
[Cross-computing tools and techniques, Language types, Extra-functional properties, Software notations and tools, Parallel programming languages, Software reliability, Distributed programming languages, General programming languages, Concurrent programming languages, Reliability, General and reference, Software organization and properties, Software and its engineering]
Do I use the wrong definition?: DeFuse: definition-use invariants for detecting concurrency and sequential bugs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Software bugs, such as concurrency, memory and semantic bugs, can significantly affect system reliability. Although much effort has been made to address this problem, there are still many bugs that cannot be detected, especially concurrency bugs due to the complexity of concurrent programs. Effective approaches for detecting these common bugs are therefore highly desired. This paper presents an invariant-based bug detection tool, DefUse, which can detect not only concurrency bugs (including the previously under-studied order violation bugs), but also memory and semantic bugs. Based on the observation that many bugs appear as violations to programmers' data flow intentions, we introduce three different types of definition-use invariants that commonly exist in both sequential and concurrent programs. We also design an algorithm to automatically extract such invariants from programs, which are then used to detect bugs. Moreover, DefUse uses various techniques to prune false positives and rank error reports. We evaluated DefUse using sixteen real-world applications with twenty real-world concurrency and sequential bugs. Our results show that DefUse can effectively detect 19 of these bugs, including 2 new bugs that were never reported before, with only a few false positives. Our training sensitivity results show that, with the benefit of the pruning and ranking algorithms, DefUse is accurate even with insufficient training.
[Cross-computing tools and techniques, Software creation and management, Software verification and validation, Extra-functional properties, Software reliability, Reliability, General and reference, Software organization and properties, Software and its engineering]
Scalable and systematic detection of buggy inconsistencies in source code
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Software developers often duplicate source code to replicate functionality. This practice can hinder the maintenance of a software project: bugs may arise when two identical code segments are edited inconsistently. This paper presents DejaVu, a highly scalable system for detecting these general syntactic inconsistency bugs. DejaVu operates in two phases. Given a target code base, a parallel /inconsistent clone analysis/ first enumerates all groups of source code fragments that are similar but not identical. Next, an extensible /buggy change analysis/ framework refines these results, separating each group of inconsistent fragments into a fine-grained set of inconsistent changes and classifying each as benign or buggy. On a 75+ million line pre-production commercial code base, DejaVu executed in under five hours and produced a report of over 8,000 potential bugs. Our analysis of a sizable random sample suggests with high likelihood that at this report contains at least 2,000 true bugs and 1,000 code smells. These bugs draw from a diverse class of software defects and are often simple to correct: syntactic inconsistencies both indicate problems and suggest solutions.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software post-development issues, Software reverse engineering, Software and its engineering]
A study of Java's non-Java memory
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
A Java application sometimes raises an out-of-memory ex-ception. This is usually because it has exhausted the Java heap. However, a Java application can raise an out-of-memory exception when it exhausts the memory used by Java that is not in the Java heap. We call this area non-Java memory. For example, an out-of-memory exception in the non-Java memory can happen when the JVM attempts to load too many classes. Although it is relatively rare to ex-haust the non-Java memory compared to exhausting the Java heap, a Java application can consume a considerable amount of non-Java memory. This paper presents a quantitative analysis of non-Java memory. To the best of our knowledge, this is the first in-depth analysis of the non-Java memory. To do this we cre-ated a tool called Memory Analyzer for Redundant, Unused, and String Areas (MARUSA), which gathers memory statis-tics from both the OS and the Java virtual machine, break-ing down and visualizing the non-Java memory usage. We studied the use of non-Java memory for a wide range of Java applications, including the DaCapo benchmarks and Apache DayTrader. Our study is based on the IBM J9 Java Virtual Machine for Linux. Although some of our results may be specific to this combination, we believe that most of our observations are applicable to other platforms as well.
[Measurement, Software defect analysis, Cross-computing tools and techniques, Metrics, Software creation and management, Software testing and debugging, Software verification and validation, General and reference, Software and its engineering]
Hera-JVM: a runtime system for heterogeneous multi-core architectures
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Heterogeneous multi-core processors, such as the IBM Cell processor, can deliver high performance. However, these processors are notoriously difficult to program: different cores support different instruction set architectures, and the processor as a whole does not provide coherence between the different cores' local memories. We present Hera-JVM, an implementation of the Java Virtual Machine which operates over the Cell processor, thereby making this platforms more readily accessible to mainstream developers. Hera-JVM supports the full Java language; threads from an unmodified Java application can be simultaneously executed on both the main PowerPC-based core and on the additional SPE accelerator cores. Migration of threads between these cores is transparent from the point of view of the application, requiring no modification to Java source code or bytecode. Hera-JVM supports the existing Java Memory Model, even though the underlying hardware does not provide cache coherence between the different core types. We examine Hera-JVM's performance under a series of real-world Java benchmarks from the SpecJVM, Java Grande and Dacapo benchmark suites. These benchmarks show a wide variation in relative performance on the different core types of the Cell processor, depending upon the nature of their workload. Execution of these benchmarks on Hera-JVM can achieve speedups of up to 2.25x by using one of the Cell processor's SPE accelerator cores, compared to execution on the main PowerPC-based core. When all six SPE cores are exploited, parallel workloads can achieve speedups of up to 13x compared to execution on the single PowerPC core.
[Computer systems organization, Software notations and tools, Runtime environments, Other architectures, Heterogeneous (hybrid) systems, Architectures, Software and its engineering, Compilers]
Cross-language, type-safe, and transparent object sharing for co-located managed runtimes
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
As software becomes increasingly complex and difficult to analyze, it is more and more common for developers to use high-level, type-safe, object-oriented (OO) programming languages and to architect systems that comprise multiple components. Different components are often implemented in different programming languages. In state-of-the-art multicomponent, multi-language systems, cross-component communication relies on remote procedure calls (RPC) and message passing. As components are increasingly co-located on the same physical machine to ensure high utilization of multi-core systems, there is a growing potential for using shared memory for cross-language cross-runtime communication. We present the design and implementation of Co-Located Runtime Sharing (CoLoRS), a system that enables cross-language, cross-runtime type-safe, transparent shared memory. CoLoRS provides object sharing for co-located OO runtimes for both static and dynamic languages. CoLoRS defines a language-neutral object/classmodel,which is a static-dynamic hybrid and enables class evolution while maintaining the space/time efficiency of a static model. CoLoRS uses type mapping and class versioning to transparently map shared types to private types. CoLoRS also contributes a synchronization mechanism and a parallel, concurrent, on-the-fly GC algorithm, both designed to facilitate cross-language cross-runtime object sharing. We implement CoLoRS in open-source, production-quality runtimes for Python and Java. Our empirical evaluation shows that CoLoRS extensions impose low overhead. We also investigate RPC over CoLoRS and find that using shared memory to implement co-located RPC significantly improves both communication throughput and latency by avoiding data structure serialization.
[Garbage collection, Classes and objects, Language features, Software notations and tools, Runtime environments, Contextual software domains, Dynamic compilers, Operating systems, Memory management, General programming languages, Software organization and properties, Software and its engineering, Compilers]
Instrumentation and sampling strategies for cooperative concurrency bug isolation
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Fixing concurrency bugs (or "crugs") is critical in modern software systems. Static analyses to find crugs such as data races and atomicity violations scale poorly, while dynamic approaches incur high run-time overheads. Crugs manifest only under specific execution interleavings that may not arise during in-house testing, thereby demanding a lightweight program monitoring technique that can be used post-deployment. We present Cooperative Crug Isolation (CCI), a low-overhead instrumentation framework to diagnose production-run failures caused by crugs. CCI tracks specific thread interleavings at run-time, and uses statistical models to identify strong failure predictors among these. We offer a varied suite of predicates that represent different trade-offs between complexity and fault isolation capability. We also develop variant random sampling strategies that suit different types of predicates and help keep the run-time overhead low. Experiments with 9 real-world bugs in 6 non-trivial C applications show that these schemes span a wide spectrum of performance and diagnosis capabilities, each suitable for different usage scenarios.
[Software defect analysis, Software creation and management, Software verification and validation, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Program verification, Theory of computation, Software testing and debugging, Semantics and reasoning, General programming languages, Program reasoning, Software and its engineering]
What can the GC compute efficiently?: a language for heap assertions at GC time
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
We present the DeAL language for heap assertions that are efficiently evaluated during garbage collection time. DeAL is a rich, declarative, logic-based language whose programs are guaranteed to be executable with good whole-heap locality, i.e., within a single traversal over every live object on the heap and a finite neighborhood around each object. As a result, evaluating DeAL programs incurs negligible cost: for simple assertion checking at each garbage collection, the end-to-end execution slowdown is below 2%. DeAL is integrated into Java as a VM extension and we demonstrate its efficiency and expressiveness with several applications and properties from the past literature. Compared to past systems for heap assertions, DeAL is distinguished by its very attractive expressiveness/efficiency tradeoff: it o ers a significantly richer class of assertions than what past systems could check with a single traversal. Conversely, past systems that can express the same (or more) complex assertions as DeAL do so only by su ering orders-of-magnitude higher costs.
[Software defect analysis, Software creation and management, Software verification and validation, Assertion checking, Assertions, Functional verification, Theory of computation, Software testing and debugging, Semantics and reasoning, Hardware validation, Hardware, Program reasoning, Software and its engineering]
Monitor optimization via stutter-equivalent loop transformation
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
There has been significant interest in equipping programs with runtime checks aimed at detecting errors to improve fault detection during testing and in the field. Recent work in this area has studied methods for efficiently monitoring a program execution's conformance to path property specifications, e.g., such as those captured by a finite state automaton. These techniques show great promise, but their broad applicability is hampered by the fact that for certain combinations of programs and properties the overhead of checking can slow the program down by up to 3500%. We have observed that, in many cases, the overhead of runtime monitoring is due to the behavior of program loops. We present a general framework for optimizing the monitoring of loops relative to a property. This framework allows monitors to process a loop in constant-time rather than time that is proportional to the number of loop iterations. We present the results of an empirical study that demonstrates that significant overhead reduction that can be achieved by applying the framework to monitor properties of several large Java programs.
[Middleware for databases, Software creation and management, Distributed transaction monitors, Software verification and validation, Contextual software domains, Information systems, Traceability, Operating systems, Process validation, Data management systems, Monitors, Software organization and properties, Software and its engineering, Process management]
Specifying and implementing refactorings
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Modern IDEs for object-oriented languages like Java provide support for a basic set of simple automated refactorings whose behaviour is easy to describe intuitively. It is, however, surprisingly difficult to specify their behaviour in detail. In particular, the popular precondition-based approach tends to produce somewhat unwieldy descriptions if advanced features of the object language are taken into account. This has resulted in refactoring implementations that are complex, hard to understand, and even harder to maintain, yet these implementations themselves are the only precise "specification" of many refactorings. We have in past work advocated a different approach based on several complementary notions of dependencies that guide the implementation, and on the concept of microrefactorings that structure it. We show in this work that these concepts are powerful enough to provide high-level specifications of many of the refactorings implemented in Eclipse. These specifications are precise enough to serve as the basis of a clean-room reimplementation of these refactorings that is very compact, yet matches Eclipse's for features and outperforms it in terms of correctness.
[Software notations and tools, Software and its engineering, Compilers]
A graph-based approach to API usage adaptation
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Reusing existing library components is essential for reducing the cost of software development and maintenance. When library components evolve to accommodate new feature requests, to fix bugs, or to meet new standards, the clients of software libraries often need to make corresponding changes to correctly use the updated libraries. Existing API usage adaptation techniques support simple adaptation such as replacing the target of calls to a deprecated API, however, cannot handle complex adaptations such as creating a new object to be passed to a different API method, or adding an exception handling logic that surrounds the updated API method calls. This paper presents LIBSYNC that guides developers in adapting API usage code by learning complex API usage adaptation patterns from other clients that already migrated to a new library version (and also from the API usages within the library's test code). LIBSYNC uses several graph-based techniques (1) to identify changes to API declarations by comparing two library versions, (2) to extract associated API usage skeletons before and after library migration, and (3) to compare the extracted API usage skeletons to recover API usage adaptation patterns. Using the learned adaptation patterns, LIBSYNC recommends the locations and edit operations for adapting API usages. The evaluation of LIBSYNC on real-world software systems shows that it is highly correct and useful with a precision of 100% and a recall of 91%.
[Software creation and management, Software evolution, Software post-development issues, Software and its engineering]
Component adaptation and assembly using interface relations
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Software's expense owes partly to frequent reimplementation of similar functionality and partly to maintenance of patches, ports or components targeting evolving interfaces. More modular non-invasive approaches are unpopular because they entail laborious wrapper code. We propose Cake, a rule-based language describing compositions using interface relations. To evaluate it, we compare several existing wrappers with reimplemented Cake versions, finding the latter to be simpler and better modularised.
[Software notations and tools, Extra-functional properties, Interoperability, Software organization and properties, Software and its engineering]
Type classes as objects and implicits
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation. This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.
[General programming languages, Object oriented languages, Language types, Functional languages, Software notations and tools, Software and its engineering]
Supporting dynamic, third-party code customizations in JavaScript using aspects
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Web sites and web browsers have recently evolved into platforms on top of which entire applications are delivered dynamically, mostly as JavaScript source code. This delivery format has sparked extremely enthusiastic efforts to customize both individual web sites and entire browsers in ways the original authors never expected or accommodated. Such customizations take the form of yet more script dynamically injected into the application, and the current idioms to do so exploit arcane JavaScript features and are extremely brittle. In this work, we accept the popularity of extensions and seek better linguistic mechanisms to support them. We suggest adding to JavaScript aspect-oriented features that allow straightforward and declarative ways for customization code to modify the targeted application. Compared to most prior aspect-related research, our work has a different motivation and a different target programming environment, both of which lead to novel design and implementation techniques. Our aspect weaving is entirely integrated into a new dynamic JIT compiler, which lets us properly handle advice to first-class functions in the presence of arbitrary aliasing, without resorting to whole-program code transformations. Our prototype demonstrates that an aspect-oriented approach to web-application customization is often more efficient than current idioms while simplifying the entire process.
[Software notations and tools, Software and its engineering, Compilers]
Dynamic parallelization of recursive code: part 1: managing control flow interactions with the continuator
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
While most approaches to automatic parallelization focus on compilation approaches for parallelizing loop iterations, we advocate the need for new virtual machines that can parallelize the execution of recursive programs. In this paper, we show that recursive programs can be effectively parallelized when arguments to procedures are evaluated concurrently and branches of conditional statements are speculatively executed in parallel. We introduce the continuator concept, a runtime structure that tracks and manages the control dependences between such concurrently spawned tasks, ensuring adherence to the sequential semantics of the parallelized program. As a proof of concept, we discuss the details of a parallel interpreter for Scheme (implemented in Common Lisp) based on these ideas, and show the results from executing the Clinger benchmark suite for Scheme.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Interpreters, Software notations and tools, Parallel programming languages, Software and its engineering, Compilers]
Symbolic heap abstraction with demand-driven axiomatization of memory invariants
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Many relational static analysis techniques for precise reasoning about heap contents perform an explicit case analysis of all possible heaps that can arise. We argue that such precise relational reasoning can be obtained in a more scalable and economical way by enforcing the memory invariant that every concrete memory location stores one unique value directly on the heap abstraction. Our technique combines the strengths of analyses for precise reasoning about heap contents with approaches that prioritize axiomatization of memory invariants, such as the theory of arrays. Furthermore, by avoiding an explicit case analysis, our technique is scalable and powerful enough to analyze real-world programs with intricate use of arrays and pointers; in particular, we verify the absence of buffer overruns, incorrect casts, and null pointer dereferences in OpenSSH (over 26,000 lines of code) after fixing 4 previously undiscovered bugs found by our system. Our experiments also show that the combination of reasoning about heap contents and enforcing existence and uniqueness invariants is crucial for this level of precision.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Extra-functional properties, Software reliability, Formal software verification, Reliability, Formal methods, General and reference, Software organization and properties, Software and its engineering]
A dynamic evaluation of the precision of static heap abstractions
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
The quality of a static analysis of heap-manipulating programs is largely determined by its heap abstraction. Object allocation sites are a commonly-used abstraction, but are too coarse for some clients. The goal of this paper is to investigate how various refinements of allocation sites can improve precision. In particular, we consider abstractions that use call stack, object recency, and heap connectivity information. We measure the precision of these abstractions dynamically for four different clients motivated by concurrency and on nine Java programs chosen from the DaCapo benchmark suite. Our dynamic results shed new light on aspects of heap abstractions that matter for precision, which allows us to more effectively navigate the large space of possible heap abstractions
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Parallel inclusion-based points-to analysis
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Inclusion-based points-to analysis provides a good trade-off between precision of results and speed of analysis, and it has been incorporated into several production compilers including gcc. There is an extensive literature on how to speed up this algorithm using heuristics such as detecting and collapsing cycles of pointer-equivalent variables. This paper describes a complementary approach based on exploiting parallelism. Our implementation exploits two key insights. First, we show that inclusion-based points-to analysis can be formulated entirely in terms of graphs and graph rewrite rules. This exposes the amorphous data-parallelism in this algorithm and makes it easier to develop a parallel implementation. Second, we show that this graph-theoretic formulation reveals certain key properties of the algorithm that can be exploited to obtain an efficient parallel implementation. Our parallel implementation achieves a scaling of up to 3x on a 8-core machine for a suite of ten large C programs. For all but the smallest benchmarks, the parallel analysis outperforms a state-of-the-art, highly optimized, serial implementation of the same algorithm. To the best of our knowledge, this is the first parallel implementation of a points-to analysis.
[General programming languages, Language features, Frameworks, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
The spoofax language workbench: rules for declarative specification of languages and IDEs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Spoofax is a language workbench for efficient, agile development of textual domain-specific languages with state-of-the-art IDE support. Spoofax integrates language processing techniques for parser generation, meta-programming, and IDE development into a single environment. It uses concise, declarative specifications for languages and IDE services. In this paper we describe the architecture of Spoofax and introduce idioms for high-level specifications of language semantics using rewrite rules, showing how analyses can be reused for transformations, code generation, and editor services such as error marking, reference resolving, and content completion. The implementation of these services is supported by language-parametric editor service classes that can be dynamically loaded by the Eclipse IDE, allowing new languages to be developed and used side-by-side in the same Eclipse environment.
[Software notations and tools, Development frameworks and environments, Software and its engineering]
MetaFJig: a meta-circular composition language for Java-like classes
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
We propose a Java-like language where class definitions are first class values and new classes can be derived from existing ones by exploiting the full power of the language itself, used on top of a small set of primitive composition operators, instead of using a fixed mechanism like inheritance. Hence, compilation requires to perform (meta-)reduction steps, by a process that we call compile-time execution. This approach differs from meta-programming techniques available in mainstream languages since it is meta-circular, hence programmers are not required to learn new syntax and idioms. Compile-time execution is guaranteed to be sound (not to get stuck) by a lightweight technique, where class composition errors are detected dynamically, and conventional typing errors are detected by interleaving typechecking with meta-reduction steps. This allows for a modular approach, that is, compile-time execution is defined, and can be implemented, on top of typechecking and execution of the underlying language. Moreover, programmers can handle errors due to composition operators. Besides soundness, our technique ensures an additional important property called meta-level soundness, that is, typing errors never originate from (meta-)code in already compiled programs.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Modular logic metaprogramming
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
In logic metaprogramming, programs are not stored as plain textfiles but rather derived from a deductive database. While the benefits of this approach for metaprogramming are obvious, its incompatibility with separate checking limits its applicability to large-scale projects. We analyze the problems inhibiting separate checking and propose a class of logics that reconcile logic metaprogramming and separate checking. We have formalized the resulting module system and have proven the soundness of separate checking. We validate its feasibility by presenting the design and implementation of a specific logic that is able to express many metaprogramming examples from the literature.
[Logic programming and answer set programming, Computing methodologies, Language types, Software notations and tools, Formal languages and automata theory, Knowledge representation and reasoning, Theory of computation, Constraint and logic languages, General programming languages, Formal language definitions, Artificial intelligence, Software and its engineering]
Reasoning about multiple related abstractions with MultiStar
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Encapsulated abstractions are fundamental in object-oriented programming. A single class may employ multiple abstractions to achieve its purpose. Such abstractions are often related and combined in disciplined ways. This paper explores ways to express, verify and rely on logical relationships between abstractions. It introduces two general specification mechanisms: export clauses for relating abstractions in individual classes, and axiom clauses for relating abstractions in a class and all its descendants. MultiStar, an automatic verification tool based on separation logic and abstract predicate families, implements these mechanisms in a multiple inheritance setting. Several verified examples illustrate MultiStar's underlying logic. To demonstrate the flexibility of our approach, we also used MultiStar to verify the core iterator hierarchy of a popular data structure library.
[Cross-computing tools and techniques, Software creation and management, Classes and objects, Software functional properties, Software verification and validation, Language features, Inheritance, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Homogeneous family sharing
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Recent work has introduced class sharing as a mechanism for adapting a family of related classes with new functionality. This paper introduces homogeneous family sharing, implemented in the J&<sub>h</sub> language, in which the sharing mechanism is lifted from class-level sharing to true family-level sharing. Compared to the original (heterogeneous) class sharing mechanism, homogeneous family sharing provides useful new functionality and substantially reduces the annotation burden on programmers by eliminating the need for masked types and sharing declarations. This is achieved through a new mechanism, shadow classes, which permit homogeneous sharing of all related classes in shared families. The new sharing mechanism has a straightforward semantics, which is formalized in the J&<sub>h</sub> calculus. The soundness of the J&<sub>h</sub> type system is proved. The J&<sub>h</sub> language is implemented as an extension to the J& language. To demonstrate the effectiveness of family sharing, the Polyglot compiler framework is ported to J&<sub>h</sub>.
[Classes and objects, General programming languages, Object oriented languages, Language features, Inheritance, Frameworks, Language types, Software notations and tools, Modules / packages, Software and its engineering]
Mostly modular compilation of crosscutting concerns by contextual predicate dispatch
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
The modularity of aspect-oriented programming (AOP) has been a controversial issue. To investigate this issue compared with object-oriented programming (OOP), we propose a simple language providing AOP mechanisms, which are enhanced traditional OOP mechanisms. We also present its formal system and then show that programs in this language can be only mostly modularly (i.e. separately) typechecked and compiled.We mention a source of this unmodularity and discuss whether or not it is appropriate to claim that AOP breaks modularity compared with OOP.
[Classes and objects, General programming languages, Language features, Software notations and tools, Software and its engineering]
Random testing for higher-order, stateful programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Testing is among the most effective tools available for finding bugs. Still, we know of no automatic technique for generating test cases that expose bugs involving a combination of mutable state and callbacks, even though objects and method overriding set up exactly that combination. For such cases, a test generator must create callbacks or subclasses that aggressively exercise side-effecting operations using combinations of generated objects. This paper presents a new algorithm for randomly testing programs that use state and callbacks. Our algorithm exploits a combination of contracts and environment bindings to guide the test-case generator toward interesting inputs. Our prototype implementation for Racket (formerly PLT Scheme) - which has a Java-like class system, but with first-class classes as well as gbeta-like augmentable methods - uncovered dozens of bugs in a well-tested and widely used text-editor library. We describe our approach in a precise, formal notation, borrowing the techniques used to describe operational semantics and type systems. The formalism enables us to provide a compact and self-contained explanation of the core of our technique without the ambiguity usually present in pseudo-code descriptions.
[Software defect analysis, Software creation and management, Software verification and validation, Assertion checking, Assertions, Functional verification, Theory of computation, Software testing and debugging, Semantics and reasoning, Hardware validation, Hardware, Program reasoning, Software and its engineering]
The two-state solution: native and serializable continuations accord
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Continuation-based Web servers provide advantages over traditional Web application development through the increase of expressive power they allow. This leads to fewer errors and more productivity for the programmers that adopt them. Unfortunately, existing implementation techniques force a hard choice between scalability and expressiveness. Our technique allows a smoother path to scalable, continuation-based Web programs. We present a modular program transformation that allows scalable Web applications to use third-party, higher-order libraries with higher-order arguments that cause Web interaction. Consequently, our system provides existing Web applications with more scalability through significantly less memory use than the traditional technique.
[Control structures, General programming languages, Language features, Software notations and tools, Software and its engineering]
Back to the futures: incremental parallelization of existing sequential runtime systems
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Many language implementations, particularly for high-level and scripting languages, are based on carefully honed runtime systems that have an internally sequential execution model. Adding support for parallelism in the usual form -- as threads that run arbitrary code in parallel -- would require a major revision or even a rewrite to add safe and efficient locking and communication. We describe an alternative approach to incremental parallelization of runtime systems. This approach can be applied inexpensively to many sequential runtime systems, and we demonstrate its effectiveness in the Racket runtime system and Parrot virtual machine. Our evaluation assesses both the performance benefits and the developer effort needed to implement our approach. We find that incremental parallelization can provide useful, scalable parallelism on commodity multicore processors at a fraction of the effort required to implement conventional parallel threads.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Ownership and immutability in generic Java
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
The Java language lacks the important notions of ownership (an object owns its representation to prevent unwanted aliasing) and immutability (the division into mutable, immutable, and readonly data and references). Programmers are prone to design errors, such as representation exposure or violation of immutability contracts. This paper presents Ownership Immutability Generic Java (OIGJ), a backward-compatible purely-static language extension supporting ownership and immutability. We formally defined a core calculus for OIGJ, based on Featherweight Java, and proved it sound. We also implemented OIGJ and performed case studies on 33,000 lines of code. Creation of immutable cyclic structures requires a "cooking phase" in which the structure is mutated but the outside world cannot observe this mutation. OIGJ uses ownership information to facilitate creation of immutable cyclic structures, by safely prolonging the cooking phase even after the constructor finishes. OIGJ is easy for a programmer to use, and it is easy to implement (flow-insensitive, adding only 14 rules to those of Java). Yet, OIGJ is more expressive than previous ownership languages, in the sense that it can type-check more good code. OIGJ can express the factory and visitor patterns, and OIGJ can type-check Sun's java.util collections (except for the clone method) without refactoring and with only a small number of annotations. Previous work required major refactoring of existing code in order to fit its ownership restrictions. Forcing refactoring of well-designed code is undesirable because it costs programmer effort, degrades the design, and hinders adoption in the mainstream community.
[General programming languages, Language features, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Tribal ownership
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Tribal Ownership unifies class nesting and object ownership. Tribal Ownership is based on Tribe, a language with nested classes and object families. In Tribal Ownership, a program's runtime object ownership structure is characterised by the lexical nesting structure of its classes. We build on a variant of Tribe to present a descriptive ownership system, using object nesting to describe heap partitions, but without imposing any restrictions on programming disciplines. We then demonstrate how a range of different prescriptive ownership policies can be supported on top of the descriptive Tribal Ownership mechanism; including a novel owners-as-local-dominators policy. We formalise our type system and prove soundness and several ownership invariants. The resulting system requires strikingly few annotations, and uses well-understood encapsulation techniques to create ownership systems that should be intuitive for programmers.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
A time-aware type system for data-race protection and guaranteed initialization
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
We introduce a type system based on intervals, objects representing the time in which a block of code will execute. The type system can verify time-based properties such as when a field will be accessed or a method will be invoked. One concrete application of our type system is data-race protection: For fields which are initialized during one phase of the program and constant thereafter, users can designate the interval during which the field is mutable. Code which happens after this initialization interval can safely read the field in parallel. We also support fields guarded by a lock and even the use of dynamic race detectors. Another use for intervals is to designate different phases in the object's lifetime, such as a constructor phase. The type system then ensures that only appropriate methods are invoked in each phase.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Automatic atomic region identification in shared memory SPMD programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
This paper presents TransFinder, a compile-time tool that automatically determines which statements of an unsynchronized multithreaded program must be enclosed in atomic regions to enforce conflict-serializability. Unlike previous tools, TransFinder requires no programmer input (beyond the program) and is more efficient in both time and space. Our implementation shows that the generated atomic regions range from being identical to, or smaller than, the programmer-specified transactions in the three Java Grande benchmarks considered, and in five of the eight STAMP benchmarks considered, while still providing identical synchronization semantics and results. The generated atomic regions are between 5 and 38 lines larger in the three remaining STAMP benchmarks. In the most conservative case, TransFinder can, based on the program structure, successfully identify and suggest an alternative that conforms exactly to the programmer-specified atomic regions. By generating small, highly-targeted, conflict-serializable atomic regions, TransFinder allows the programmer to focus further tuning efforts on only a small portion of the code (when further tuning is needed).
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Task types for pervasive atomicity
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Atomic regions are an important concept in correct concurrent programming: since atomic regions can be viewed as having executed in a single step, atomicity greatly reduces the number of possible interleavings the programmer needs to consider. This paper describes a method for building atomicity into a programming language in an organic fashion. We take the view that atomicity holds for whole threads by default, and a division into smaller atomic regions occurs only at points where an explicit need for sharing is needed and declared. A corollary of this view is every line of code is part of some atomic region. We define a polymorphic type system, Task Types, to enforce most of the desired atomicity properties statically. We show the reasonableness of our type system by proving that type soundness, isolation invariance, and atomicity enforcement properties hold at run time. We also present initial results of a Task Types implementation built on Java
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
Concurrent programming with revisions and isolation types
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Building applications that are responsive and can exploit parallel hardware while remaining simple to write, understand, test, and maintain, poses an important challenge for developers. In particular, it is often desirable to enable various tasks to read or modify shared data concurrently without requiring complicated locking schemes that may throttle concurrency and introduce bugs. We introduce a mechanism that simplifies the parallel execution of different application tasks. Programmers declare what data they wish to share between tasks by using isolation types, and execute tasks concurrently by forking and joining revisions. These revisions are isolated: they read and modify their own private copy of the shared data only. A runtime creates and merges copies automatically, and resolves conflicts deterministically, in a manner declared by the chosen isolation type. To demonstrate the practical viability of our approach, we developed an efficient algorithm and an implementation in the form of a C# library, and used it to parallelize an interactive game application. Our results show that the parallelized game, while simple and very similar to the original sequential game, achieves satisfactory speedups on a multicore processor.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
SPUR: a trace-based JIT compiler for CIL
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Tracing just-in-time compilers (TJITs) determine frequently executed traces (hot paths and loops) in running programs and focus their optimization effort by emitting optimized machine code specialized to these traces. Prior work has established this strategy to be especially beneficial for dynamic languages such as JavaScript, where the TJIT interfaces with the interpreter and produces machine code from the JavaScript trace. This direct coupling with a JavaScript interpreter makes it difficult to harness the power of a TJIT for other components that are not written in JavaScript, e.g., the DOM implementation or the layout engine inside a browser. Furthermore, if a TJIT is tied to a particular high-level language interpreter, it is difficult to reuse it for other input languages as the optimizations are likely targeted at specific idioms of the source language. To address these issues, we designed and implemented a TJIT for Microsoft's Common Intermediate Language CIL (the target language of C#, VisualBasic, F#, and many other languages). Working on CIL enables TJIT optimizations for any program compiled to this platform. In addition, to validate that the performance gains of a TJIT for JavaScript do not depend on specific idioms of JavaScript that are lost in the translation to CIL, we provide a performance evaluation of our JavaScript runtime which translates JavaScript to CIL and then runs on top of our CIL TJIT.
[Source code generation, Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Refactoring references for library migration
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Automated refactoring is a key feature of modern IDEs. Existing refactorings rely on the transformation of source code declarations, in which references may also be transformed as a side effect. However, there exist situations in which a declaration is not available for refactoring or would be inappropriate to transform, for example, in the presence of dangling references or where a set of references should be retargeted to a different declaration. We investigate the problem of dangling references through a detailed study of three open source libraries. We find that the introduction of dangling references during library migration is a significant real problem, and characterize the specific issues that arise. Based on these findings we provide and test a prototype tool, called Trident, that allows programmers to refactor references. Our results suggest that supporting the direct refactoring of references is a significant improvement over the state-of-the-art.
[Management of computing and information systems, Software maintenance, Software creation and management, Software management, Professional topics, Software post-development issues, Social and professional topics, Software and its engineering]
Performance analysis of idle programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
This paper presents an approach for performance analysis of modern enterprise-class server applications. In our experience, performance bottlenecks in these applications differ qualitatively from bottlenecks in smaller, stand-alone systems. Small applications and benchmarks often suffer from CPU-intensive hot spots. In contrast, enterprise-class multi-tier applications often suffer from problems that manifest not as hot spots, but as idle time, indicating a lack of forward motion. Many factors can contribute to undesirable idle time, including locking problems, excessive system-level activities like garbage collection, various resource constraints, and problems driving load. We present the design and methodology for WAIT, a tool to diagnosis the root cause of idle time in server applications. Given lightweight samples of Java activity on a single tier, the tool can often pinpoint the primary bottleneck on a multi-tier system. The methodology centers on an informative abstraction of the states of idleness observed in a running program. This abstraction allows the tool to distinguish, for example, between hold-ups on a database machine, insufficient load, lock contention in application code, and a conventional bottleneck due to a hot method. To compute the abstraction, we present a simple expert system based on an extensible set of declarative rules. WAIT can be deployed on the fly, without modifying or even restarting the application. Many groups in IBM have applied the tool to diagnosis performance problems in commercial systems, and we present a number of examples as case studies.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
Registration-based language abstractions
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Programming language innovation has been hindered by the difficulty of making changes to existing languages. A key source of difficulty is the tyrannical nature of existing approaches to realizing languages -- adding a new language construct means that any tool, document or programmer that works with the language must be prepared to deal with that construct. A registration-based approach makes it possible to define language constructs that are not tyrannical. They are instead transient -- the program appears to be written using the constructs only so long as a given programmer wants to see it that way. This approach may have the potential to greatly facilitate programming language innovation.
[General programming languages, Language features, Software notations and tools, Development frameworks and environments, Software and its engineering]
Pinocchio: bringing reflection to life with first-class interpreters
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
To support development tools like debuggers, runtime systems need to provide a meta-programming interface to alter their semantics and access internal data. Reflective capabilities are typically fixed by the Virtual Machine (VM). Unanticipated reflective features must either be simulated by complex program transformations, or they require the development of a specially tailored VM. We propose a novel approach to behavioral reflection that eliminates the barrier between applications and the VM by manipulating an explicit tower of first-class interpreters. Pinocchio is a proof-of-concept implementation of our approach which enables radical changes to the interpretation of programs by explicitly instantiating subclasses of the base interpreter. We illustrate the design of Pinocchio through non-trivial examples that extend runtime semantics to support debugging, parallel debugging, and back-in-time object-flow debugging. Although performance is not yet addressed, we also discuss numerous opportunities for optimization, which we believe will lead to a practical approach to behavioral reflection.
[Very high level languages, General programming languages, Interpreters, Language types, Software notations and tools, Software and its engineering, Compilers]
Concurrency by modularity: design patterns, a case in point
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
General purpose object-oriented programs typically aren't embarrassingly parallel. For these applications, finding enough concurrency remains a challenge in program design. To address this challenge, in the Panini project we are looking at reconciling concurrent program design goals with modular program design goals. The main idea is that if programmers improve the modularity of their programs they should get concurrency for free. In this work we describe one of our directions to reconcile these two goals by enhancing Gang-of-Four (GOF) object-oriented design patterns. GOF patterns are commonly used to improve the modularity of object-oriented software. These patterns describe strategies to decouple components in design space and specify how these components should interact. Our hypothesis is that if these patterns are enhanced to also decouple components in execution space applying them will concomitantly improve the design and potentially available concurrency in software systems. To evaluate our hypothesis we have studied all 23 GOF patterns. For 18 patterns out of 23, our hypothesis has held true. Another interesting preliminary result reported here is that for 17 out of these 18 studied patterns, concurrency and synchronization concerns were completely encapsulated in our concurrent design pattern framework.
[Designing software, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Patterns and statistical analysis for understanding reduced resource computing
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
We present several general, broadly applicable mechanisms that enable computations to execute with reduced resources, typically at the cost of some loss in the accuracy of the result they produce.We identify several general computational patterns that interact well with these resource reduction mechanisms, present a concrete manifestation of these patterns in the form of simple model programs, perform simulationbased explorations of the quantitative consequences of applying these mechanisms to our model programs, and relate the model computations (and their interaction with the resource reduction mechanisms) to more complex benchmark applications drawn from a variety of fields.
[Language features, Software notations and tools, Client-server architectures, Software architectures, Program verification, Distributed systems organizing principles, Theory of computation, Software system structures, Semantics and reasoning, General programming languages, Semantics, Program semantics, Formal language definitions, Program reasoning, Patterns, Software organization and properties, Software and its engineering]
Programming with time: cyber-physical programming with impromptu
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
The act of computer programming is generally considered to be temporally removed from a computer program's execution. In this paper we discuss the idea of programming as an activity that takes place within the temporal bounds of a real-time computational process and its interactions with the physical world. We ground these ideas within the con- text of livecoding -- a live audiovisual performance practice. We then describe how the development of the programming environment "Impromptu" has addressed our ideas of programming with time and the notion of the programmer as an agent in a cyber-physical system.
[Software creation and management, Software development techniques, Software and its engineering]
Language virtualization for heterogeneous parallel computing
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
As heterogeneous parallel systems become dominant, application developers are being forced to turn to an incompatiblemix of low level programming models (e.g. OpenMP, MPI, CUDA, OpenCL). However, these models do little to shield developers from the difficult problems of parallelization, data decomposition and machine-specific details. Most programmersare having a difficult time using these programming models effectively. To provide a programming modelthat addresses the productivity and performance requirements for the average programmer, we explore a domainspecificapproach to heterogeneous parallel programming. We propose language virtualization as a new principle that enables the construction of highly efficient parallel domain specific languages that are embedded in a common host language. We define criteria for language virtualization and present techniques to achieve them.We present two concrete case studies of domain-specific languages that are implemented using our virtualization approach.
[Source code generation, General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering, Compilers]
Flexible modeling tools for pre-requirements analysis: conceptual architecture and research challenges
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
A serious tool gap exists at the start of the software lifecy-cle, before requirements formulation. Pre-requirements analysts gather information, organize it to gain insight, en-vision possible futures, and present insights and recom-mendations to stakeholders. They typically use office tools, which give great freedom, but no help with consistency management, change propagation, or information migration to downstream tools. Despite these downsides, office tools are still favored over modeling tools, which are constrain-ing and difficult to use. We introduce the notion of flexible modeling tools, which blend the advantages of office and modeling tools. We propose a conceptual architecture for such tools, and outline research challenges to be met in realizing them. We briefly describe the Business Insight Toolkit, a prototype tool embodying this architecture.
[Software creation and management, Software development techniques, Software and its engineering]
To upgrade or not to upgrade: impact of online upgrades across multiple administrative domains
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Online software upgrades are often plagued by runtime behaviors that are poorly understood and difficult to ascertain. For example, the interactions among multiple versions of the software expose the system to race conditions that can introduce latent errors or data corruption. Moreover, industry trends suggest that online upgrades are currently needed in large-scale enterprise systems, which often span multiple administrative domains (e.g., Web 2.0 applications that rely on AJAX client-side code or systems that lease cloud-computing resources). In such systems, the enterprise does not control all the tiers of the system and cannot coordinate the upgrade process, making existing techniques inadequate to prevent mixed-version races. In this paper, we present an analytical framework for impact assessment, which allows system administrators to directly compare the risk of following an online-upgrade plan with the risk of delaying or canceling the upgrade. We also describe an executable model that implements our formal impact assessment and enables a systematic approach for deciding whether an online upgrade is appropriate. Our model provides a method of last resort for avoiding undesirable program behaviors, in situations where mixed-version races cannot be avoided through other technical means.
[Management of computing and information systems, Software maintenance, Software creation and management, Professional topics, Software post-development issues, Distributed systems organizing principles, Computer systems organization, Software system structures, Distributed architectures, Software management, Social and professional topics, Software organization and properties, Software and its engineering, Architectures]
Managing ambiguity in programming by finding unambiguous examples
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
We propose a new way to raise the level of discourse in the programming process: permit ambiguity, but manage it by linking it to unambiguous examples. This allows programming environments to work with informal descriptions that lack precise semantics, such as natural language descriptions or conceptual diagrams, without requiring programmers to formulate their ideas in a formal language first. As an example of this idea, we present Zones, a code search and reuse interface that connects code with ambiguous natural language statements about its purpose. The backend, called ProcedureSpace, relates purpose statements, static code analysis features, and natural language background knowledge. ProcedureSpace can search for code given statements of purpose or vice versa, and can find code that was never annotated or commented. Since completed Zones searches become annotations, system coverage grows with user interaction. Users in a preliminary study found that reasoning jointly over natural language and programming language helped them reuse code.
[Natural language interfaces, Human-centered computing, Software notations and tools, Human computer interaction (HCI), Interaction paradigms, Software and its engineering]
Better science through art
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
How do artists and scientists work? The same.
[Document types, General and reference]
Rubber ducks, nightmares, and unsaturated predicates: proto-scientific schemata are good for agile
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Fine-grain case studies of scientific inquiry, lessons from linguistics on metaphoric thinking, the epistemology of Charles Sanders Peirce, recent work on architectural image-schemata, along with the computer world's own theorist, Peter Naur, all suggest that software developers (frequently dulled and desiccated from overdosing on 'Cartesian' methodologies) could benefit from imbibing a little 'mysticism' not the wave-your-hands woo-woo kind but the more ineffable hunch and gut side of human cognition. Scholarly publications in their final polished forms rarely admit that stories, jokes, eroticism, and dreams were the fertile seeds that germinated into 'serious' results. This essay looks to these 'closet' sources, non-reductionist, non-self conscious, metaphorical, aformal modes of thought as the salvation of a profession gone awry. It is notably proto-scientific image-schemata that retain our attention as a pragmatic tool for improving the fecundity of Agile methodology, at its roots, so to speak. The necessary context is provided by Peter Naur's fundamental insights about software development as 'theory building' coupled with an elaboration of the Agile concept of storytelling.
[Professional topics, Social and professional topics]
Pure and declarative syntax definition: paradise lost and regained
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Syntax definitions are pervasive in modern software systems, and serve as the basis for language processing tools like parsers and compilers. Mainstream parser generators pose restrictions on syntax definitions that follow from their implementation algorithm. They hamper evolution, maintainability, and compositionality of syntax definitions. The pureness and declarativity of syntax definitions is lost. We analyze how these problems arise for different aspects of syntax definitions, discuss their consequences for language engineers, and show how the pure and declarative nature of syntax definitions can be regained.
[Parsers, Formal language definitions, Software notations and tools, Syntax, Software and its engineering, Compilers]
Faith, hope, and love: an essay on software science's neglect of human factors
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Research in the area of programming languages has different facets -- from formal reasoning about new programming language constructs (such as type soundness proofs for new type systems) over inventions of new abstractions, up to performance measurements of virtual machines. A closer look into the underlying research methods reveals a distressing characteristic of programming language research: developers, which are the main audience for new language constructs, are hardly considered in the research process. As a consequence, it is simply not possible to state whether a new construct that requires some kind of interaction with the developer has any positive impact on the construction of software. This paper argues for appropriate research methods in programming language research that rely on studies of developers -- and argues that the introduction of corresponding empirical methods not only requires a new understanding of research but also a different view on how to teach software science to students.
[General programming languages, Software notations and tools, Software and its engineering]
The Tower of Babel did not fail
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 45 ISSUE 10
2010
Fred Brooks' retelling of the biblical story of the Tower of Babel offers many insights into what makes building software difficult. The difficulty, according to common interpretations, comes from the communication and organizational problems in software development. But the story contains one more important lesson that people tend to miss: one cannot accomplish impossible goals, which programmers are often asked to do. Software engineering, as a discipline, can overcome poor communication; but as long as we attempt to live up to impossible expectations, we will always fail.
[Management of computing and information systems, Codes of ethics, Software creation and management, Software management, Professional topics, Computing profession, Social and professional topics, Software and its engineering]
The sequential prison
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
We are trapped in a sequential prison. We use sequential character strings to write sequential programs to control sequential computers. No wonder concurrency remains elusive. How did we come to be here? The high cost of vacuum tube logic forced sequence upon early computer builders. Sequential character strings were the economic way to describe what sequential computers should do. Sequential programs controlled the expensive part of the machine, namely logic. The lethargic pace of logic circuits masked the cost of moving data over distance, allowing programming languages to ignore the cost of communication. Today, the time delay and energy cost of communicating over distance dominate modern computers; logic is essentially free. Why then, do programming languages continue to control logic and largely ignore communication? It will take a broad effort to escape our sequential prison, requiring changes in hardware, programming notations and the ways in which they are expressed. Most importantly, it will require recognizing that we are in sequential prison, and planning for an escape.
[Computer systems organization]
SHERIFF: precise detection and automatic mitigation of false sharing
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
False sharing is an insidious problem for multithreaded programs running on multicore processors, where it can silently degrade performance and scalability. Previous tools for detecting false sharing are severely limited: they cannot distinguish false sharing from true sharing, have high false positive rates, and provide limited assistance to help programmers locate and resolve false sharing. This paper presents two tools that attack the problem of false sharing: Sheriff-Detect and Sheriff-Protect. Both tools leverage a framework we introduce here called Sheriff. Sheriff breaks out threads into separate processes, and exposes an API that allows programs to perform per-thread memory isolation and tracking on a per-page basis. We believe Sheriff is of independent interest. Sheriff-Detect finds instances of false sharing by comparing updates within the same cache lines by different threads, and uses sampling to rank them by performance impact. Sheriff-Detect is precise (no false positives), runs with low overhead (on average, 20%), and is accurate, pinpointing the exact objects involved in false sharing. We present a case study demonstrating Sheriff-Detect's effectiveness at locating false sharing in a variety of benchmarks. Rewriting a program to fix false sharing can be infeasible when source is unavailable, or undesirable when padding objects would unacceptably increase memory consumption or further worsen runtime performance. Sheriff-Protect mitigates false sharing by adaptively isolating shared updates from different threads into separate physical addresses, effectively eliminating most of the performance impact of false sharing. We show that Sheriff-Protect can improve performance for programs with catastrophic false sharing by up to 9&#215;, without programmer intervention.
[Cross-computing tools and techniques, Software performance, Computing methodologies, Language types, Software notations and tools, Extra-functional properties, General programming languages, Concurrent programming languages, Performance, Concurrent computing methodologies, General and reference, Software organization and properties, Software and its engineering]
SOS: saving time in dynamic race detection with stationary analysis
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Data races are subtle and difficult to detect errors that arise during concurrent program execution. Traditional testing techniques fail to find these errors, but recent research has shown that targeted dynamic analysis techniques can be developed to precisely detect races (i.e., no false race reports are generated) that occur during program execution. Unfortunately, precise race detection is still too expensive to be used in practice. State-of-the-art techniques still slow down program execution by a factor of eight or more. In this paper, we incorporate an optimization technique based on the observation that many thread-shared objects are written early in their lifetimes and then become read-only for the remainder of their lifetimes; these are known as stationary objects. The main contribution of our work is the insight that once a stationary object becomes thread-shared, races cannot occur. Therefore, our proposed approach does not monitor access to these objects. As such, our system only incurs an average overhead of 45% of that of an implementation of FastTrack, a low-overhead dynamic race detector. We then compared the effectiveness of our approach to de- tect races in deployed environments with that of Pacer, a sampling based race detector based on FastTrack. We found that our approach can detect over five times more races than Pacer when we budget 50% for runtime overhead.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Testing atomicity of composed concurrent operations
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
We address the problem of testing atomicity of composed concurrent operations. Concurrent libraries help programmers exploit parallel hardware by providing scalable concurrent operations with the illusion that each operation is executed atomically. However, client code often needs to compose atomic operations in such a way that the resulting composite operation is also atomic while preserving scalability. We present a novel technique for testing the atomicity of client code composing scalable concurrent operations. The challenge in testing this kind of client code is that a bug may occur very rarely and only on a particular interleaving with a specific thread configuration. Our technique is based on modular testing of client code in the presence of an adversarial environment; we use commutativity specifications to drastically reduce the number of executions explored to detect a bug. We implemented our approach in a tool called COLT, and evaluated its effectiveness on a range of 51 real-world concurrent Java programs. Using COLT, we found 56 atomicity violations in Apache Tomcat, Cassandra, MyFaces Trinidad, and other applications.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Data-driven synthesis for object-oriented frameworks
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Software construction today often involves the use of large frameworks. The challenge in this type of programming is that object-oriented frameworks tend to grow exceedingly intricate; they spread functionality among numerous classes, and any use of the framework requires knowledge of many interacting components. We present a system named MATCHMAKER that from a simple query synthesizes code that interacts with the framework. The query consists of names of two framework classes, and our system produces code enabling interaction between them. MATCHMAKER relies on a database of dynamic program traces called DELIGHT that uses novel abstraction-based indexing techniques to answer queries about the evolution of heap connectivity in a matter of seconds. The paper evaluates the performance and effectiveness of MATCHMAKER on a number of benchmarks from the Eclipse framework. The paper also presents the results of a user study that showed a 49% average productivity improvement from the use of our tool.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, Software development methods, Software and its engineering]
Synthesis of first-order dynamic programming algorithms
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
To solve a problem with a dynamic programming algorithm, one must reformulate the problem such that its solution can be formed from solutions to overlapping subproblems. Because overlapping subproblems may not be apparent in the specification, it is desirable to obtain the algorithm directly from the specification. We describe a semi-automatic synthesizer of linear-time dynamic programming algorithms. The programmer supplies a declarative specification of the problem and the operators that might appear in the solution. The synthesizer obtains the algorithm by searching a space of candidate algorithms; internally, the search is implemented with constraint solving. The space of candidate algorithms is defined with a program template reusable across all linear-time dynamic programming algorithms, which we characterize as first-order recurrences. This paper focuses on how to write the template so that the constraint solving process scales to real-world linear-time dynamic programming algorithms. We show how to reduce the space with (i)~symmetry reduction and (ii)~domain knowledge of dynamic programming algorithms. We have synthesized algorithms for variants of maximal substring matching, an assembly-line optimization, and the extended Euclid algorithm. We have also synthesized a problem outside the class of first-order recurrences, by composing three instances of the algorithm template.
[Constraints, General programming languages, Language features, Software notations and tools, Software and its engineering]
Kind analysis for MATLAB
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
MATLAB is a popular dynamic programming language used for scientific and numerical programming. As a language, it has evolved from a small scripting language intended as an interactive interface to numerical libraries, to a very popular language supporting many language features and libraries. The overloaded syntax and dynamic nature of the language, plus the somewhat organic addition of language features over the years, makes static analysis of modern MATLAB quite challenging. A fundamental problem in MATLAB is determining the kind of an identifier. Does an identifier refer to a variable, a named function or a prefix? Although this is a trivial problem for most programming languages, it was not clear how to do this properly in MATLAB. Furthermore, there was no simple explanation of kind analysis suitable for MATLAB programmers, nor a publicly-available implementation suitable for compiler researchers. This paper explains the required background of MATLAB, clarifies the kind assignment program, and proposes some general guidelines for developing good kind analyses. Based on these foundations we present our design and implementation of a variety of kind analyses, including an approach that matches the intended behaviour of modern MATLAB 7 and two potentially better alternatives. We have implemented all the variations of the kind analysis in McLab, our extensible compiler framework, and we present an empirical evaluation of the various analyses on a large set of benchmark programs.
[Software notations and tools, Software and its engineering, Compilers]
Tool-supported refactoring for JavaScript
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Refactoring is a popular technique for improving the structure of existing programs while maintaining their behavior. For statically typed programming languages such as Java, a wide variety of refactorings have been described, and tool support for performing refactorings and ensuring their correctness is widely available in modern IDEs. For the JavaScript programming language, however, existing refactoring tools are less mature and often unable to ensure that program behavior is preserved. Refactoring algorithms that have been developed for statically typed languages are not applicable to JavaScript because of its dynamic nature. We propose a framework for specifying and implementing JavaScript refactorings based on pointer analysis. We describe novel refactorings motivated by best practice recommendations for JavaScript programming, and demonstrate how they can be described concisely in terms of queries provided by our framework. Experiments performed with a prototype implementation on a suite of existing applications show that our approach is well-suited for developing practical refactoring tools for JavaScript.
[Software creation and management, Software post-development issues, Software reverse engineering, Software and its engineering]
Integrated language definition testing: enabling test-driven language development
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
The reliability of compilers, interpreters, and development environments for programming languages is essential for effective software development and maintenance. They are often tested only as an afterthought. Languages with a smaller scope, such as domain-specific languages, often remain untested. General-purpose testing techniques and test case generation methods fall short in providing a low-threshold solution for test-driven language development. In this paper we introduce the notion of a language-parametric testing language (LPTL) that provides a reusable, generic basis for declaratively specifying language definition tests. We integrate the syntax, semantics, and editor services of a language under test into the LPTL for writing test inputs. This paper describes the design of an LPTL and the tool support provided for it, shows use cases using examples, and describes our implementation in the form of the Spoofax testing language.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software notations and tools, Software and its engineering]
Catch me if you can: performance bug detection in the wild
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Profilers help developers to find and fix performance problems. But do they find performance bugs -- performance problems that real users actually notice? In this paper we argue that -- especially in the case of interactive applications -- traditional profilers find irrelevant problems but fail to find relevant bugs. We then introduce lag hunting, an approach that identifies perceptible performance bugs by monitoring the behavior of applications deployed in the wild. The approach transparently produces a list of performance issues, and for each issue provides the developer with information that helps in finding the cause of the problem. We evaluate our approach with an experiment where we monitor an application used by 24 users for 1958 hours over the course of 3-months. We characterize the resulting 881 issues, and we find and fix the causes of a set of representative examples.
[Measurement, Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Metrics, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
PREFAIL: a programmable tool for multiple-failure injection
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
As hardware failures are no longer rare in the era of cloud computing, cloud software systems must "prevail" against multiple, diverse failures that are likely to occur. Testing software against multiple failures poses the problem of combinatorial explosion of multiple failures. To address this problem, we present PreFail, a programmable failure-injection tool that enables testers to write a wide range of policies to prune down the large space of multiple failures. We integrate PreFail to three cloud software systems (HDFS, Cassandra, and ZooKeeper), show a wide variety of useful pruning policies that we can write for them, and evaluate the speed-ups in testing time that we obtain by using the policies. In our experiments, our testing approach with appropriate policies found all the bugs that one can find using exhaustive testing while spending 10X--200X less time than exhaustive testing.
[Software defect analysis, Software fault tolerance, Software creation and management, Software testing and debugging, Software verification and validation, Extra-functional properties, Software organization and properties, Software and its engineering]
Synthesizing method sequences for high-coverage testing
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
High-coverage testing is challenging. Modern object-oriented programs present additional challenges for testing. One key difficulty is the generation of proper method sequences to construct desired objects as method parameters. In this paper, we cast the problem as an instance of program synthesis that automatically generates candidate programs to satisfy a user-specified intent. In our setting, candidate programs are method sequences, and desired object states specify an intent. Automatic generation of desired method sequences is difficult due to its large search space---sequences often involve methods from multiple classes and require specific primitive values. This paper introduces a novel approach, called Seeker, to intelligently navigate the large search space. Seeker synergistically combines static and dynamic analyses: (1) dynamic analysis generates method sequences to cover branches; (2) static analysis uses dynamic analysis information for not-covered branches to generate candidate sequences; and (3) dynamic analysis explores and eliminates statically generated sequences. For evaluation, we have implemented Seeker and demonstrate its effectiveness on four subject applications totalling 28K LOC. We show that Seeker achieves higher branch coverage and def-use coverage than existing state-of-the-art approaches. We also show that Seeker detects 34 new defects missed by existing tools.
[Software creation and management, Abstract machines, Object oriented languages, Software verification and validation, Language types, Computing methodologies, Symbolic and algebraic manipulation, Software notations and tools, Abstraction, Theory of computation, Models of computation, Semantics and reasoning, General programming languages, Program reasoning, Software and its engineering]
HAWKEYE: effective discovery of dataflow impediments to parallelization
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Parallelization transformations are an important vehicle for improving the performance and scalability of a software system. Utilizing concurrency requires that the developer first identify a suitable parallelization scope: one that poses as a performance bottleneck, and at the same time, exhibits considerable available parallelism. However, having identified a candidate scope, the developer still needs to ensure the correctness of the transformation. This is a difficult undertaking, where a major source of complication lies in tracking down sequential dependencies that inhibit parallelization and addressing them. We report on Hawkeye, a dynamic dependence-analysis tool that is designed to assist programmers in pinpointing such impediments to parallelization. In contrast with field-based dependence analyses, which track concrete memory conflicts and thus suffer from a high rate of false reports, Hawkeye tracks dependencies induced by the abstract semantics of the data type while ignoring dependencing arising solely from implementation artifacts. This enables a more concise report, where the reported dependencies are more likely to be real as well as intelligible to the programmer.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Automatic fine-grain locking using shape properties
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
We present a technique for automatically adding fine-grain locking to an abstract data type that is implemented using a dynamic forest -i.e., the data structures may be mutated, even to the point of violating forestness temporarily during the execution of a method of the ADT. Our automatic technique is based on Domination Locking, a novel locking protocol. Domination locking is designed specifically for software concurrency control, and in particular is designed for object-oriented software with destructive pointer updates. Domination locking is a strict generalization of existing locking protocols for dynamically changing graphs. We show our technique can successfully add fine-grain locking to libraries where manually performing locking is extremely challenging. We show that automatic fine-grain locking is more efficient than coarse-grain locking, and obtains similar performance to hand-crafted fine-grain locking.
[Trees, Computing methodologies, Language types, Software notations and tools, Record storage systems, Graph theory, Information systems, Theory of computation, Semantics and reasoning, Information storage systems, General programming languages, B-trees, Program semantics, Discrete mathematics, Concurrent programming languages, Mathematics of computing, Directory structures, Concurrent computing methodologies, Software and its engineering]
Safe parallel programming using dynamic dependence hints
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Speculative parallelization divides a sequential program into possibly parallel tasks and permits these tasks to run in parallel if and only if they show no dependences with each other. The parallelization is safe in that a speculative execution always produces the same output as the sequential execution. In this paper, we present the dependence hint, an interface for a user to specify possible dependences between possibly parallel tasks. Dependence hints may be incorrect or incomplete but they do not change the program output. The interface extends Cytron's do-across and recent OpenMP ordering primitives and makes them safe and safely composable. We use it to express conditional and partial parallelism and to parallelize large-size legacy code. The prototype system is implemented as a software library. It is used to improve performance by nearly 10 times on average on current multicore machines for 8 programs including 5 SPEC benchmarks.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Sprint: speculative prefetching of remote data
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Remote data access latency is a significant performance bottleneck in many modern programs that use remote databases and web services. We present Sprint - a run-time system for optimizing such programs by prefetching and caching data from remote sources in parallel to the execution of the original program. Sprint separates the concerns of exposing potentially-independent data accesses from the mechanism for executing them efficiently in parallel or in a batch. In contrast to prior work, Sprint can efficiently prefetch data in the presence of irregular or input-dependent access patterns, while preserving the semantics of the original program. We used Sprint to automatically improve the performance of several real-world Java programs that access remote databases (MySQL, DB2) and web services (Facebook, IBM's Yellow Pages). Sprint achieves speedups ranging 2.4x to 15.8x over sequential execution, which are comparable to those achieved by manually modifying the program for asynchronous and batch execution of data accesses. Sprint provides a simple interface that allows a programmer to plug in support for additional data sources without modifying the client program.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Asynchronous assertions
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Assertions are a familiar and widely used bug detection technique. Traditional assertion checking, however, is performed synchronously, imposing its full cost on the runtime of the program. As a result, many useful kinds of checks, such as data structure invariants and heap analyses, are impractical because they lead to extreme slowdowns. We present a solution that decouples assertion evaluation from program execution: assertions are checked asynchronously by separate checking threads while the program continues to execute. Our technique guarantees that asynchronous evaluation always produces the same result as synchronous evaluation, even if the program concurrently modifies the program state. The checking threads evaluate each assertion on a consistent snapshot of the program state as it existed at the moment the assertion started. We implemented our technique in a system called Strobe, which supports asynchronous assertion checking in both single-and multi-threaded Java applications. Strobe runs inside the Java virtual machine and uses copy-on-write to construct snapshots incrementally, on-the-fly. Our system includes all necessary synchronization to support multiple concurrent checking threads, and to prevent data races with the main program threads. We find that asynchronous checking significantly outperforms synchronous checking, incurring tolerable overheads -- in the range of 10% to 50% over no checking at all -- even for heavy-weight assertions that would otherwise result in crushing slowdowns.
[Theory of computation, Software creation and management, Semantics and reasoning, Software verification and validation, Hardware validation, Assertion checking, Hardware, Program reasoning, Assertions, Software and its engineering, Functional verification]
Ribbons: a partially shared memory programming model
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
The need for programs to execute subcomponents in isolation from each other or with lower privileges is prevalent among today's systems. We introduce ribbons: a shared memory programming model that allows for more implicit sharing of memory than processes but is more restrictive than threads. Ribbons structure the heap into protection domains. Privileges between these protection domains are carefully controlled in order to confine computation. We propose RibbonJ, a backwards-compatible extension of Java, to easily create or port programs to use the ribbons model. We study the progress and isolation properties of a subset of the language. Building on JikesRVM we implement ribbons by leveraging existing memory protection mechanisms in modern hardware and operating systems, avoiding the overhead of inline security checks and read or write barriers. We evaluate efficiency via microbenchmarks and the DaCapo suite, observing minor overhead. Additionally, we refactor Apache Tomcat to use ribbons for application isolation, discuss the refactoring's design and complexity, and evaluate performance using the SPECweb2009 benchmark.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Why nothing matters: the impact of zeroing
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Memory safety defends against inadvertent and malicious misuse of memory that may compromise program correctness and security. A critical element of memory safety is zero initialization. The direct cost of zero initialization is surprisingly high: up to 12.7%, with average costs ranging from 2.7 to 4.5% on a high performance virtual machine on IA32 architectures. Zero initialization also incurs indirect costs due to its memory bandwidth demands and cache displacement effects. Existing virtual machines either: a) minimize direct costs by zeroing in large blocks, or b) minimize indirect costs by zeroing in the allocation sequence, which reduces cache displacement and bandwidth. This paper evaluates the two widely used zero initialization designs, showing that they make different tradeoffs to achieve very similar performance. Our analysis inspires three better designs: (1) bulk zeroing with cache-bypassing (non-temporal) instructions to reduce the direct and indirect zeroing costs simultaneously, (2) concurrent non-temporal bulk zeroing that exploits parallel hardware to move work off the application's critical path, and (3) adaptive zeroing, which dynamically chooses between (1) and (2) based on available hardware parallelism. The new software strategies offer speedups sometimes greater than the direct overhead, improving total performance by 3% on average. Our findings invite additional optimizations and microarchitectural support.
[Garbage collection, Operating systems, Memory management, Software notations and tools, Runtime environments, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Trustworthy numerical computation in Scala
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Modern computing has adopted the floating point type as a default way to describe computations with real numbers. Thanks to dedicated hardware support, such computations are efficient on modern architectures, even in double precision. However, rigorous reasoning about the resulting programs remains difficult. This is in part due to a large gap between the finite floating point representation and the infinite-precision real-number semantics that serves as the developers' mental model. Because programming languages do not provide support for estimating errors, some computations in practice are performed more and some less precisely than needed. We present a library solution for rigorous arithmetic computation. Our numerical data type library tracks a (double) floating point value, but also a guaranteed upper bound on the error between this value and the ideal value that would be computed in the real-value semantics. Our implementation involves a set of linear approximations based on an extension of affine arithmetic. The derived approximations cover most of the standard mathematical operations, including trigonometric functions, and are more comprehensive than any publicly available ones. Moreover, while interval arithmetic rapidly yields overly pessimistic estimates, our approach remains precise for several computational tasks of interest. We evaluate the library on a number of examples from numerical analysis and physical simulations. We found it to be a useful tool for gaining confidence in the correctness of the computation.
[Validation, Cross-computing tools and techniques, Software creation and management, Empirical software validation, Software verification and validation, Theory of computation, Semantics and reasoning, Process validation, Program reasoning, Logic, General and reference, Software and its engineering]
JET: exception checking in the Java native interface
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Java's type system enforces exception-checking rules that stipulate a checked exception thrown by a method must be declared in the throws clause of the method. Software written in Java often invokes native methods through the use of the Java Native Interface (JNI). Java's type system, however, cannot enforce the same exception-checking rules on Java exceptions raised in native methods. This gap makes Java software potentially buggy and often difficult to debug when an exception is raised in native code. In this paper, we propose a complete static-analysis framework called JET to extend exception-checking rules even on native code. The framework has a two-stage design where the first stage throws away a large portion of irrelevant code so that the second stage, a fine-grained analysis, can concentrate on a small set of code for accurate bug finding. This design achieves both high efficiency and accuracy. We have applied JET on a set of benchmark programs with a total over 227K lines of source code and identified 12 inconsistent native-method exception declarations.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Extra-functional properties, Verification, Software verification, Program verification, Interoperability, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Immutable specifications for more concise and precise verification
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
In the current work, we investigate the benefits of immutability guarantees for allowing more flexible handling of aliasing, as well as more precise and concise specifications. Our approach supports finer levels of control that can mark data structures as being immutable through the use of immutability annotations. By using such annotations to encode immutability guarantees, we expect to obtain better specifications that can more accurately describe the intentions, as well as prohibitions, of the method. Ultimately, our goal is improving the precision of the verification process, as well as making the specifications more readable, more precise and as an enforceable program documentation. We have designed and implemented a new entailment procedure to formally and automatically reason about immutability enhanced specifications. We have also formalised the soundness for our new procedure through an operational semantics with mutability assertions on the heap. Lastly, we have carried out a set of experiments to both validate and affirm the utility of our current proposal on immutability enhanced specification mechanism.
[Theory of computation, Software creation and management, Semantics and reasoning, Software verification and validation, Hardware validation, Assertion checking, Hardware, Program reasoning, Assertions, Software and its engineering, Functional verification]
Hybrid partial evaluation
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Hybrid partial evaluation (HPE) is a pragmatic approach to partial evaluation that borrows ideas from both online and offline partial evaluation. HPE performs offline-style specialization using an online approach without static binding time analysis. The goal of HPE is to provide a practical and predictable level of optimization for programmers, with an implementation strategy that fits well within existing compilers or interpreters. HPE requires the programmer to specify where partial evaluation should be applied. It provides no termination guarantee and reports errors in situations that violate simple binding time rules, or have incorrect use of side effects in compile-time code. We formalize HPE for a small imperative object-oriented language and describe Civet, a straightforward implementation of HPE as a relatively simple extension of a Java compiler. Code optimized by Civet performs as well as the output of a state-of-the-art offline partial evaluator.
[Theory of computation, Semantics and reasoning, Program semantics]
SugarJ: library-based syntactic language extensibility
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Existing approaches to extend a programming language with syntactic sugar often leave a bitter taste, because they cannot be used with the same ease as the main extension mechanism of the programming language - libraries. Sugar libraries are a novel approach for syntactically extending a programming language within the language. A sugar library is like an ordinary library, but can, in addition, export syntactic sugar for using the library. Sugar libraries maintain the composability and scoping properties of ordinary libraries and are hence particularly well-suited for embedding a multitude of domain-specific languages into a host language. They also inherit self-applicability from libraries, which means that sugar libraries can provide syntactic extensions for the definition of other sugar libraries. To demonstrate the expressiveness and applicability of sugar libraries, we have developed SugarJ, a language on top of Java, SDF and Stratego, which supports syntactic extensibility. SugarJ employs a novel incremental parsing technique, which allows changing the syntax within a source file. We demonstrate SugarJ by five language extensions, including embeddings of XML and closures in Java, all available as sugar libraries. We illustrate the utility of self-applicability by embedding XML Schema, a metalanguage to define XML languages.
[Extensible languages, Software creation and management, Reusability, General programming languages, Language types, Software notations and tools, Software development techniques, Software libraries and repositories, Software and its engineering]
Reactive imperative programming with dataflow constraints
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Dataflow languages provide natural support for specifying constraints between objects in dynamic applications, where programs need to react efficiently to changes of their environment. Researchers have long investigated how to take advantage of dataflow constraints by embedding them into procedural languages. Previous mixed imperative/dataflow systems, however, require syntactic extensions or libraries of ad hoc data types for binding the imperative program to the dataflow solver. In this paper we propose a novel approach that smoothly combines the two paradigms without placing undue burden on the programmer. In our framework, programmers can define ordinary statements of the imperative host language that enforce constraints between objects stored in special memory locations designated as "reactive". Differently from previous approaches, reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures. Statements defining constraints are automatically re-executed every time their input memory locations change, letting a program behave like a spreadsheet where the values of some variables depend upon the values of other variables. The constraint solving mechanism is handled transparently by altering the semantics of elementary operations of the host language for reading and modifying objects. We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers. We discuss common coding idioms and relevant applications to reactive scenarios, including incremental computation, observer design pattern, and data structure repair. The performance of our implementation is compared to ad hoc problem-specific change propagation algorithms, as well as to language-centric approaches such as self-adjusting computation and subject/observer communication mechanisms, showing that the proposed approach is efficient in practice.
[Constraints, General programming languages, Language features, Software notations and tools, Software and its engineering]
Two for the price of one: a model for parallel and incremental computation
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Parallel or incremental versions of an algorithm can significantly outperform their counterparts, but are often difficult to develop. Programming models that provide appropriate abstractions to decompose data and tasks can simplify parallelization. We show in this work that the same abstractions can enable both parallel and incremental execution. We present a novel algorithm for parallel self-adjusting computation. This algorithm extends a deterministic parallel programming model (concurrent revisions) with support for recording and repeating computations. On record, we construct a dynamic dependence graph of the parallel computation. On repeat, we reexecute only parts whose dependencies have changed. We implement and evaluate our idea by studying five example programs, including a realistic multi-pass CSS layout algorithm. We describe programming techniques that proved particularly useful to improve the performance of self-adjustment in practice. Our final results show significant speedups on all examples (up to 37x on an 8-core machine). These speedups are well beyond what can be achieved by parallelization alone, while requiring a comparable effort by the programmer.
[General programming languages, Language features, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
A step towards transparent integration of input-consciousness into dynamic program optimizations
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Dynamic program optimizations are critical for the efficiency of applications in managed programming languages and scripting languages. Recent studies have shown that exploitation of program inputs may enhance the effectiveness of dynamic optimizations significantly. However, current solutions for enabling the exploitation require either programmers' annotations or intensive offline profiling, impairing the practical adoption of the techniques. This current work examines the basic feasibility of transparent integration of input-consciousness into dynamic program optimizations, particularly in managed execution environments. It uses transparent learning across production runs as the basic vehicle, and investigates the implications of cross-run learning on each main component of input-conscious dynamic optimizations. It proposes several techniques to address some key challenges for the transparent integration, including randomized inspection-instrumentation for cross-user data collection, a sparsity-tolerant algorithm for input characterization, and selective prediction for efficiency protection. These techniques make it possible to automatically recognize the relations between the inputs to a program and the appropriate ways to optimize it. The whole process happens transparently across production runs; no need for offline profiling or programmer intervention. Experiments on a number of Java programs demonstrate the effectiveness of the techniques in enabling input-consciousness for dynamic optimizations, revealing the feasibility and potential benefits of the new optimization paradigm in some basic settings.
[Software notations and tools, Software and its engineering, Compilers]
Enhancing locality for recursive traversals of recursive structures
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
While there has been decades of work on developing automatic, locality-enhancing transformations for regular programs that operate over dense matrices and arrays, there has been little investigation of such transformations for irregular programs, which operate over pointer-based data structures such as graphs, trees and lists. In this paper, we argue that, for a class of irregular applications we call traversal codes, there exists substantial data reuse and hence opportunity for locality exploitation. We develop a novel optimization called point blocking, inspired by the classic tiling loop transformation, and show that it can substantially enhance temporal locality in traversal codes. We then present a transformation and optimization framework called TreeTiler that automatically detects opportunities for applying point blocking and applies the transformation. TreeTiler uses autotuning techniques to determine appropriate parameters for the transformation. For a series of traversal algorithms drawn from real-world applications, we show that TreeTiler is able to deliver performance improvements of up to 245% over an optimized (but non-transformed) parallel baseline, and in several cases, significantly better scalability.
[Software notations and tools, Software and its engineering, Compilers]
Flow-sensitive type recovery in linear-log time
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
The flexibility of dynamically typed languages such as JavaScript, Python, Ruby, and Scheme comes at the cost of run-time type checks. Some of these checks can be eliminated via control-flow analysis. However, traditional control-flow analysis (CFA) is not ideal for this task as it ignores flow-sensitive information that can be gained from dynamic type predicates, such as JavaScript's 'instanceof' and Scheme's 'pair?', and from type-restricted operators, such as Scheme's 'car'. Yet, adding flow-sensitivity to a traditional CFA worsens the already significant compile-time cost of traditional CFA. This makes it unsuitable for use in just-in-time compilers. In response, we have developed a fast, flow-sensitive type-recovery algorithm based on the linear-time, flow-insensitive sub-0CFA. The algorithm has been implemented as an experimental optimization for the commercial Chez Scheme compiler, where it has proven to be effective, justifying the elimination of about 60% of run-time type checks in a large set of benchmarks. The algorithm processes on average over 100,000 lines of code per second and scales well asymptotically, running in only O(n log n) time. We achieve this compile-time performance and scalability through a novel combination of data structures and algorithms.
[Software notations and tools, Software and its engineering, Compilers]
Oracle scheduling: controlling granularity in implicitly parallel languages
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
A classic problem in parallel computing is determining whether to execute a task in parallel or sequentially. If small tasks are executed in parallel, the task-creation overheads can be overwhelming. If large tasks are executed sequentially, processors may spin idle. This granularity problem, however well known, is not well understood: broadly applicable solutions remain elusive. We propose techniques for controlling granularity in implicitly parallel programming languages. Using a cost semantics for a general-purpose language in the style of the lambda calculus with support for parallelism, we show that task-creation overheads can indeed slow down parallel execution by a multiplicative factor. We then propose oracle scheduling, a technique for reducing these overheads, which bases granularity decisions on estimates of task-execution times. We prove that, for a class of computations, oracle scheduling can reduce task creation overheads to a small fraction of the work without adversely affecting available parallelism, thereby leading to efficient parallel executions. We realize oracle scheduling in practice by a combination of static and dynamic techniques. We require the programmer to provide the asymptotic complexity of every function and use run-time profiling to determine the implicit, architecture-specific constant factors. In our experiments, we were able to reduce overheads of parallelism down to between 3 and 13 percent, while achieving 6- to 10-fold speedups.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Kismet: parallel speedup estimates for serial programs
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Software engineers now face the difficult task of refactoring serial programs for parallel execution on multicore processors. Currently, they are offered little guidance as to how much benefit may come from this task, or how close they are to the best possible parallelization. This paper presents Kismet, a tool that creates parallel speedup estimates for unparallelized serial programs. Kismet differs from previous approaches in that it does not require any manual analysis or modification of the program. This difference allows quick analysis of many programs, avoiding wasted engineering effort on those that are fundamentally limited. To accomplish this task, Kismet builds upon the hierarchical critical path analysis (HCPA) technique, a recently developed dynamic analysis that localizes parallelism to each of the potentially nested regions in the target program. It then uses a parallel execution time model to compute an approximate upper bound for performance, modeling constraints that stem from both hardware parameters and internal program structure. Our evaluation applies Kismet to eight high-parallelism NAS Parallel Benchmarks running on a 32-core AMD multicore system, five low-parallelism SpecInt benchmarks, and six medium-parallelism benchmarks running on the finegrained MIT Raw processor. The results are compelling. Kismet is able to significantly improve the accuracy of parallel speedup estimates relative to prior work based on critical path analysis.
[Software design techniques, Software creation and management, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software implementation planning, Designing software, Software development process management, General programming languages, Software and its engineering]
Efficiently speeding up sequential computation through the n-way programming model
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
With core counts on the rise, the sequential components of applications are becoming the major bottleneck in performance scaling as predicted by Amdahl's law. We are therefore faced with the simultaneous problems of occupying an increasing number of cores and speeding up sequential sections. In this work, we reconcile these two seemingly incompatible problems with a novel programming model called N-way. The core idea behind N-way is to benefit from the algorithmic diversity available to express certain key computational steps. By simultaneously launching in parallel multiple ways to solve a given computation, a runtime can just-in-time pick the best (for example the fastest) way and therefore achieve speedup. Previous work has demonstrated the benefits of such an approach but has not addressed its inherent waste. In this work, we focus on providing a mathematically sound learning-based statistical model that can be used by a runtime to determine the optimal balance between resources used and benefits obtainable through N-way. We further describe a dynamic culling mechanism to further reduce resource waste. We present abstractions and a runtime support to cleanly encapsulate the computational-options and monitor their progress. We demonstrate a low-overhead runtime that achieves significant speedup over a range of widely used kernels. Our results demonstrate super-linear speedups in certain cases.
[General programming languages, Language features, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Exploiting coarse-grain speculative parallelism
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Speculative execution at coarse granularities (e.g., code-blocks, methods, algorithms) offers a promising programming model for exploiting parallelism on modern architectures. In this paper we present Anumita, a framework that includes programming constructs and a supporting runtime system to enable the use of coarse-grain speculation to improve program performance, without burdening the programmer with the complexity of creating, managing and retiring speculations. Speculations may be composed by specifying surrogate code blocks at any arbitrary granularity, which are then executed concurrently, with a single winner ultimately modifying program state. Anumita provides expressive semantics for winner selection that go beyond time to solution to include user-defined notions of quality of solution. Anumita can be used to improve the performance of hard to parallelize algorithms whose performance is highly dependent on input data. Anumita is implemented as a user-level runtime with programming interfaces to C, C++, Fortran and as an OpenMP extension. Performance results from several applications show the efficacy of using coarse-grain speculation to achieve (a) robustness when surrogates fail and (b) significant speedup over static algorithm choices.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Scalable join patterns
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Coordination can destroy scalability in parallel programming. A comprehensive library of scalable synchronization primitives is therefore an essential tool for exploiting parallelism. Unfortunately, such primitives do not easily combine to yield solutions to more complex problems. We demonstrate that a concurrency library based on Fournet and Gonthier's join calculus can provide declarative and scalable coordination. By declarative, we mean that the programmer needs only to write down the constraints of a coordination problem, and the library will automatically derive a correct solution. By scalable, we mean that the derived solutions deliver robust performance both as the number of processors increases, and as the complexity of the coordination problem grows. We validate our claims empirically on seven coordination problems, comparing our generic solution to specialized algorithms from the literature.
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
Product lines of theorems
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Mechanized proof assistants are powerful verification tools, but proof development can be difficult and time-consuming. When verifying a family of related programs, the effort can be reduced by proof reuse. In this paper, we show how to engineer product lines with theorems and proofs built from feature modules. Each module contains proof fragments which are composed together to build a complete proof of correctness for each product. We consider a product line of programming languages, where each variant includes metatheory proofs verifying the correctness of its semantic definitions. This approach has been realized in the Coq proof assistant, with the proofs of each feature independently certifiable by Coq. These proofs are composed for each language variant, with Coq mechanically verifying that the composite proofs are correct. As validation, we formalize a core calculus for Java in Coq which can be extended with any combination of casts, interfaces, or generics.
[Theory of computation, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
Gradual typing for generics
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Gradual typing is a framework to combine static and dynamic typing in a single programming language. In this paper, we develop a gradual type system for class-based object-oriented languages with generics. We introduce a special type to denote dynamically typed parts of a program; unlike dynamic types introduced to C# 4.0, however, our type system allows for more seamless integration of dynamically and statically typed code. We formalize a gradual type system for Featherweight GJ with a semantics given by a translation that inserts explicit run-time checks. The type system guarantees that statically typed parts of a program do not go wrong, even if it includes dynamically typed parts. We also describe a basic implementation scheme for Java and report preliminary performance evaluation.
[Theory of computation, General programming languages, Object oriented languages, Language types, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
A theory of substructural types and control
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Exceptions are invaluable for structured error handling in high-level languages, but they are at odds with linear types. More generally, control effects may delete or duplicate portions of the stack, which, if we are not careful, can invalidate all substructural usage guarantees for values on the stack. We have developed a type-and-effect system that tracks control effects and ensures that values on the stack are never wrongly duplicated or dropped. We present the system first with abstract control effects and prove its soundness. We then give examples of three instantiations with particular control effects, including exceptions and delimited continuations, and show that they meet the soundness criteria for specific control effects.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Benefits and barriers of user evaluation in software engineering research
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
In this paper, we identify trends about, benefits from, and barriers to performing user evaluations in software engineering research. From a corpus of over 3,000 papers spanning ten years, we report on various subtypes of user evaluations (e.g., coding tasks vs. questionnaires) and relate user evaluations to paper topics (e.g., debugging vs. technology transfer). We identify the external measures of impact, such as best paper awards and citation counts, that are correlated with the presence of user evaluations. We complement this with a survey of over 100 researchers from over 40 different universities and labs in which we identify a set of perceived barriers to performing user evaluations.
[Human-centered computing, Human computer interaction (HCI), Software and its engineering]
Da capo con scala: design and analysis of a scala benchmark suite for the java virtual machine
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Originally conceived as the target platform for Java alone, the Java Virtual Machine (JVM) has since been targeted by other languages, one of which is Scala. This trend, however, is not yet reflected by the benchmark suites commonly used in JVM research. In this paper, we thus present the design and analysis of the first full-fledged benchmark suite for Scala. We furthermore compare the benchmarks contained therein with those from the well-known DaCapo 9.12 benchmark suite and show where the differences are between Scala and Java code---and where not.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software management, Performance, Social and professional topics, General and reference, Software organization and properties, Software and its engineering]
Automated construction of JavaScript benchmarks
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
JavaScript is a highly dynamic language for web-based applications. Innovative implementation techniques for improving its speed and responsiveness have been developed in recent years. Industry benchmarks such as WebKit SunSpider are often cited as a measure of the efficacy of these techniques. However, recent studies have shown that these benchmarks fail to accurately represent the dynamic nature of modern JavaScript applications, and so may be poor predictors of real-world performance. Worse, they may guide the development of optimizations which are unhelpful for real applications. Our goal is to develop a tool and techniques to automate the creation of realistic and representative benchmarks from existing web applications. We propose a record-and-replay approach to capture JavaScript sessions which has sufficient fidelity to accurately recreate key characteristics of the original application, and at the same time is sufficiently flexible that a recording produced on one platform can be replayed on a different one. We describe JSBench, a flexible tool for workload capture and benchmark generation, and demonstrate its use in creating eight benchmarks based on popular sites. Using a variety of runtime metrics collected with instrumented versions of Firefox, Internet Explorer, and Safari, we show that workloads created by JSBench match the behavior of the original web applications.
[Measurement, Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Design, Metrics, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
Declaratively programming the mobile web with Mobl
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
A new generation of mobile touch devices, such as the iPhone, iPad and Android devices, are equipped with powerful, modern browsers. However, regular websites are not optimized for the specific features and constraints of these devices, such as limited screen estate, unreliable Internet access, touch-based interaction patterns, and features such as GPS. While recent advances in web technology enable web developers to build web applications that take advantage of the unique properties of mobile devices, developing such applications exposes a number of problems, specifically: developers are required to use many loosely coupled languages with limited tool support and application code is often verbose and imperative. We introduce mobl, a new language designed to declaratively construct mobile web applications. Mobl integrates languages for user interface design, styling, data modeling, querying and application logic into a single, unified language that is flexible, expressive, enables early detection of errors, and has good IDE support.
[Software system structures, General programming languages, Language features, Software notations and tools, Software architectures, Software organization and properties, Software and its engineering]
First-class state change in plaid
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Objects model the world, and state is fundamental to a faithful modeling. Engineers use state machines to understand and reason about state transitions, but programming languages provide little support for building software based on state abstractions. We propose Plaid, a language in which objects are modeled not just in terms of classes, but in terms of changing abstract states. Each state may have its own representation, as well as methods that may transition the object into a new state. A formal model precisely defines the semantics of core Plaid constructs such as state transition and trait-like state composition. We evaluate Plaid through a series of examples taken from the Plaid compiler and the standard libraries of Smalltalk and Java. These examples show how Plaid can more closely model state-based designs, enhancing understandability, enhancing dynamic error checking, and providing reuse benefits.
[Designing software, Software creation and management, General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Cedalion: a language for language oriented programming
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Language Oriented Programming (LOP) is a paradigm that puts domain specific programming languages (DSLs) at the center of the software development process. Currently, there are three main approaches to LOP: (1) the use of internal DSLs, implemented as libraries in a given host language; (2) the use of external DSLs, implemented as interpreters or compilers in an external language; and (3) the use of language workbenches, which are integrated development environments (IDEs) for defining and using external DSLs. In this paper, we contribute: (4) a novel language-oriented approach to LOP for defining and using internal DSLs. While language workbenches adapt internal DSL features to overcome some of the limitations of external DSLs, our approach adapts language workbench features to overcome some of the limitations of internal DSLs. We introduce Cedalion, an LOP host language for internal DSLs, featuring static validation and projectional editing. To validate our approach we present a case study in which Cedalion was used by biologists in designing a DNA microarray for molecular Biology research.
[Extensible languages, Logic programming and answer set programming, Language types, Computing methodologies, Context specific languages, Software notations and tools, Knowledge representation and reasoning, Specialized application languages, Constraint and logic languages, General programming languages, Artificial intelligence, Software and its engineering]
Self-adjusting stack machines
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Self-adjusting computation offers a language-based approach to writing programs that automatically respond to dynamically changing data. Recent work made significant progress in developing sound semantics and associated implementations of self-adjusting computation for high-level, functional languages. These techniques, however, do not address issues that arise for low-level languages, i.e., stack-based imperative languages that lack strong type systems and automatic memory management. In this paper, we describe techniques for self-adjusting computation which are suitable for low-level languages. Necessarily, we take a different approach than previous work: instead of starting with a high-level language with additional primitives to support self-adjusting computation, we start with a low-level intermediate language, whose semantics is given by a stack-based abstract machine. We prove that this semantics is sound: it always updates computations in a way that is consistent with full reevaluation. We give a compiler and runtime system for the intermediate language used by our abstract machine. We present an empirical evaluation that shows that our approach is efficient in practice, and performs favorably compared to prior proposals.
[Software creation and management, Software development techniques, Software and its engineering]
JIT compilation policy for modern machines
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Dynamic or Just-in-Time (JIT) compilation is crucial to achieve acceptable performance for applications (written in managed languages, such as Java and C#) distributed as intermediate language binary codes for a virtual machine (VM) architecture. Since it occurs at runtime, JIT compilation needs to carefully tune its compilation policy to make effective decisions regarding 'if' and 'when' to compile different program regions to achieve the best overall program performance. Past research has extensively tuned JIT compilation policies, but mainly for VMs with a single compiler thread and for execution on single-processor machines. This work is driven by the need to explore the most effective JIT compilation strategies in their modern operational environment, where (a) processors have evolved from single to multi/many cores, and (b) VMs provide support for multiple concurrent compiler threads. Our results confirm that changing 'if' and 'when' methods are compiled have significant performance impacts. We construct several novel configurations in the HotSpot JVM to facilitate this study. The new configurations are necessitated by modern Java benchmarks that impede traditional static whole-program discovery, analysis and annotation, and are required for simulating future many-core hardware that is not yet widely available. We study the effects on performance of increasing compiler aggressiveness for VMs with multiple compiler threads running on existing single/multi-core and future many-core machines. Our results indicate that although more aggressive JIT compilation policies show no benefits on single-core machines, these can often improve program performance for multi/many-core machines. However, accurately prioritizing JIT method compilations is crucial to realize such benefits.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Reducing trace selection footprint for large-scale Java applications without performance loss
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
When optimizing large-scale applications, striking the balance between steady-state performance, start-up time, and code size has always been a grand challenge. While recent advances in trace compilation have significantly improved the steady-state performance of trace JITs for large-scale Java applications, the size control aspect of a trace compilation system remains largely overlooked. For instance, using the DaCapo 9.12 benchmarks, we observe that 40% of traces selected by a state-of-the-art trace selection algorithm are short-lived and, on average, each selected basic block is replicated 13 times in the trace cache. This paper studies the size control problem for a class of commonly used trace selection algorithms and proposes six techniques to reduce the footprint of trace selection without incurring any performance loss. The crux of our approach is to target redundancies in trace selection in the form of either short-lived traces or unnecessary trace duplication. Using one of the best performing selection algorithms as the baseline, we demonstrate that, on the DaCapo 9.12 benchmarks and DayTrader 2.0 on WebSphere Application Server 7.0, our techniques reduce the code size and compilation time by 69% and the start-up time by 43% while retaining the steady-state performance. On DayTrader 2.0, an example of large-scale application, our techniques also improve the steady-state performance by 10%.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Variability-aware parsing in the presence of lexical macros and conditional compilation
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
In many projects, lexical preprocessors are used to manage different variants of the project (using conditional compilation) and to define compile-time code transformations (using macros). Unfortunately, while being a simple way to implement variability, conditional compilation and lexical macros hinder automatic analysis, even though such analysis is urgently needed to combat variability-induced complexity. To analyze code with its variability, we need to parse it without preprocessing it. However, current parsing solutions use unsound heuristics, support only a subset of the language, or suffer from exponential explosion. As part of the TypeChef project, we contribute a novel variability-aware parser that can parse almost all unpreprocessed code without heuristics in practicable time. Beyond the obvious task of detecting syntax errors, our parser paves the road for further analysis, such as variability-aware type checking. We implement variability-aware parsers for Java and GNU C and demonstrate practicability by parsing the product line MobileMedia and the entire X86 architecture of the Linux kernel with 6065 variable features.
[Software notations and tools, Development frameworks and environments, Software and its engineering, Compilers]
Safe and atomic run-time code evolution for Java and its application to dynamic AOP
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Dynamic updates to running programs improve development productivity and reduce downtime of long-running applications. This feature is however severely limited in current virtual machines for object-oriented languages. In particular, changes to classes often apply only to methods invoked after a class change, but not to active methods on the call stack of threads. Additionally, adding and removing methods as well as fields is often not supported. We present a novel programming model for safe and atomic code updates of Java programs that also updates methods that are currently executed. We introduce safe update regions and pause threads only there before an update. We automatically convert the stack frames to suit the new versions of the methods. Our implementation is based on a production-quality Java virtual machine. Additionally, we present SafeWeave, a dynamic aspect-oriented programming system that exposes the atomic code updates through a high-level programming model. AspectJ advice can be added to and removed from a running application.Changes are atomic and correctness is guaranteed even though weaving happens in parallel to program execution, and the system fully supports the dynamic class loading of Java. We show that the enhanced evolution features do not incur any performance penalty before and after version changes.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
A simple abstraction for complex concurrent indexes
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Indexes are ubiquitous. Examples include associative arrays, dictionaries, maps and hashes used in applications such as databases, file systems and dynamic languages. Abstractly, a sequential index can be viewed as a partial function from keys to values. Values can be queried by their keys, and the index can be mutated by adding or removing mappings. Whilst appealingly simple, this abstract specification is insufficient for reasoning about indexes accessed concurrently. We present an abstract specification for concurrent indexes. We verify several representative concurrent client applications using our specification, demonstrating that clients can reason abstractly without having to consider specific underlying implementations. Our specification would, however, mean nothing if it were not satisfied by standard implementations of concurrent indexes. We verify that our specification is satisfied by algorithms based on linked lists, hash tables and B-Link trees. The complexity of these algorithms, in particular the B-Link tree algorithm, can be completely hidden from the client's view by our abstract specification.
[Software creation and management, Software functional properties, Software verification and validation, Formal software verification, Formal methods, Software organization and properties, Software and its engineering]
Composable, nestable, pessimistic atomic statements
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
In this paper we introduce a new method for pessimistically implementing composable, nestable atomic statements. Our mechanism, called shelters, is inspired by the synchronization strategy used in the Jade programming language. Unlike previous lock-based pessimistic approaches, our mechanism does not require a whole-program analysis that computes a global lock order. Further, this mechanism frees us to implement several optimizations, impossible with automatically inserted locks, that are necessary for scaling on recent multi-core systems. Additionally we show how our basic mechanism can be extended to support both open- and closed-nesting of atomic statements, something that, to our knowledge, has not yet been implemented fully-pessimistically in this context. Unlike optimistic, transactional-memory-based approaches, programmers using our mechanism do not have to write compensating actions for open-nesting, or worry about the possibly awkward semantics and performance impact of aborted transactions. Similar to systems using locks, our implementation requires programmers to annotate the types of objects with the shelters that protect them, and indicate the sections of code to be executed atomically with atomic statements. A static analysis then determines from which shelters protection is needed for the atomic statements to run atomically. We have implemented shelter-based atomic statements for C, and applied our implementation to 12 benchmarks totaling over 200k lines of code including the STAMP benchmark suite, and the sqlite database system. Our implementation's performance is competitive with explicit locking, Autolocker, and a mature software transactional memory implementation.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Delegated isolation
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Isolation---the property that a task can access shared data without interference from other tasks---is one of the most basic concerns in parallel programming. In this paper, we present Aida, a new model of isolated execution for parallel programs that perform frequent, irregular accesses to pointer-based shared data structures. The three primary benefits of Aida are dynamism, safety and liveness guarantees, and programmability. First, Aida allows tasks to dynamically select and modify, in an isolated manner, arbitrary fine-grained regions in shared data structures, all the while maintaining a high level of concurrency. Consequently, the model can achieve scalable parallelization of regular as well as irregular shared-memory applications. Second, the model offers freedom from data races, deadlocks, and livelocks. Third, no extra burden is imposed on programmers, who access the model via a simple, declarative isolation construct that is similar to that for transactional memory. The key new insight in Aida is a notion of delegation among concurrent isolated tasks (known in Aida as assemblies). Each assembly A is equipped with a region in the shared heap that it owns---the only objects accessed by A are those it owns, guaranteeing race-freedom. The region owned by A can grow or shrink flexibly---however, when A needs to own a datum owned by B, A delegates itself, as well as its owned region, to B. From now on, B has the responsibility of re-executing the task A set out to complete. Delegation as above is the only inter-assembly communication primitive in Aida. In addition to reducing contention in a local, data-driven manner, it guarantees freedom from deadlocks and livelocks. We offer an implementation of Aida on top of the Habanero Java parallel programming language. The implementation employs several novel ideas, including the use of a union-find data structure to represent tasks and the regions that they own. A thorough evaluation using several irregular data-parallel benchmarks demonstrates the low overhead and excellent scalability of Aida, as well as its benefits over existing approaches to declarative isolation. Our results show that Aida performs on par with the state-of-the-art customized implementations of irregular applications and much better than coarse-grained locking and transactional memory approaches.
[Distributed programming languages, General programming languages, Language types, Computing methodologies, Parallel computing methodologies, Software notations and tools, Concurrent programming languages, Parallel programming languages, Software and its engineering]
AC: composable asynchronous IO for native languages
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
This paper introduces AC, a set of language constructs for composable asynchronous IO in native languages such as C/C++. Unlike traditional synchronous IO interfaces, AC lets a thread issue multiple IO requests so that they can be serviced concurrently, and so that long-latency operations can be overlapped with computation. Unlike traditional asynchronous IO interfaces, AC retains a sequential style of programming without requiring code to use multiple threads, and without requiring code to be "stack-ripped" into chains of callbacks. AC provides an "async" statement to identify opportunities for IO operations to be issued concurrently, a "do..finish" block that waits until any enclosed "async" work is complete, and a "cancel" statement that requests cancellation of unfinished IO within an enclosing "do..finish". We give an operational semantics for a core language. We describe and evaluate implementations that are integrated with message passing on the Barrelfish research OS, and integrated with asynchronous file and network IO on Microsoft Windows. We show that AC offers comparable performance to existing C/C++ interfaces for asynchronous IO, while providing a simpler programming model.
[Communications management, Input / output, Computing methodologies, Language types, Software notations and tools, Contextual software domains, Operating systems, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software organization and properties, Software and its engineering]
Virtual values for language extension
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
This paper focuses on extensibility, the ability of a programmer using a particular language to extend the expressiveness of that language. This paper explores how to provide an interesting notion of extensibility by virtualizing the interface between code and data. A virtual value is a special value that supports behavioral intercession. When a primitive operation is applied to a virtual value, it invokes a trap on that virtual value. A virtual value contains multiple traps, each of which is a user-defined function that describes how that operation should behave on that value. This paper formalizes the semantics of virtual values, and shows how they enable the definition of a variety of language extensions, including additional numeric types; delayed evaluation; taint tracking; contracts; revokable membranes; and units of measure. We report on our experience implementing virtual values for Javascript within an extension for the Firefox browser.
[Theory of computation, Semantics and reasoning, Semantics, Program semantics, Formal language definitions, Software notations and tools, Software and its engineering]
Backstage Java: making a difference in metaprogramming
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
We propose Backstage Java (BSJ), a Java language extension which allows algorithmic, contextually-aware generation and transformation of code. BSJ explicitly and concisely represents design patterns and other encodings by employing compile-time metaprogramming: a practice in which the programmer writes instructions which are executed over the program's AST during compilation. While compile-time metaprogramming has been successfully used in functional languages such as Template Haskell, a number of language properties (scope, syntactic structure, mutation, etc.) have thus far prevented this theory from translating to the imperative world. BSJ uses the novel approach of difference-based metaprogramming to provide an imperative programming style amenable to the Java community and to enforce that metaprograms are consistent and semantically unambiguous. To make the feasibility of BSJ metaprogramming evident, we have developed a compiler implementation and numerous working code examples.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Flexible object layouts: enabling lightweight language extensions by intercepting slot access
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Programming idioms, design patterns and application libraries often introduce cumbersome and repetitive boilerplate code to a software system. Language extensions and external DSLs (domain specific languages) are sometimes introduced to reduce the need for boilerplate code, but they also complicate the system by introducing the need for language dialects and inter-language mediation. To address this, we propose to extend the structural reflective model of the language with object layouts, layout scopes and slots. Based on the new reflective language model we can 1) provide behavioral hooks to object layouts that are triggered when the fields of an object are accessed and 2) simplify the implementation of state-related language extensions such as stateful traits. By doing this we show how many idiomatic use cases that normally require boilerplate code can be more effectively supported. We present an implementation in Smalltalk, and illustrate its usage through a series of extended examples.
[General programming languages, Language features, Interpreters, Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Type checking modular multiple dispatch with parametric polymorphism and multiple inheritance
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
In previous work, we presented rules for defining overloaded functions that ensure type safety under symmetric multiple dispatch in an object-oriented language with multiple inheritance, and we showed how to check these rules without requiring the entire type hierarchy to be known, thus supporting modularity and extensibility. In this work, we extend these rules to a language that supports parametric polymorphism on both classes and functions. In a multiple-inheritance language in which any type may be extended by types in other modules, some overloaded functions that might seem valid are correctly rejected by our rules. We explain how these functions can be permitted in a language that additionally supports an exclusion relation among types, allowing programmers to declare "nominal exclusions" and also implicitly imposing exclusion among different instances of each polymorphic type. We give rules for computing the exclusion relation, deriving many type exclusions from declared and implicit ones. We also show how to check our rules for ensuring the safety of overloaded functions. In particular, we reduce the problem of handling parametric polymorphism to one of determining subtyping relationships among universal and existential types. Our system has been implemented as part of the open-source Fortress compiler.
[Classes and objects, General programming languages, Language features, Inheritance, Software notations and tools, Modules / packages, Software and its engineering, Polymorphism]
A syntactic type system for recursive modules
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
A practical type system for ML-style recursive modules should address at least two technical challenges. First, it needs to solve the double vision problem, which refers to an inconsistency between external and internal views of recursive modules. Second, it needs to overcome the tension between practical decidability and expressivity which arises from the potential presence of cyclic type definitions caused by recursion between modules. Although type systems in previous proposals solve the double vision problem and are also decidable, they fail to typecheck common patterns of recursive modules, such as functor fixpoints, that are essential to the expressivity of the module system and the modular development of recursive modules. This paper proposes a novel type system for recursive modules that solves the double vision problem and typechecks common patterns of recursive modules including functor fixpoints. First, we design a type system with a type equivalence based on weak bisimilarity, which does not lend itself to practical implementation in general, but accommodates a broad range of cyclic type definitions. Then, we identify a practically implementable fragment using a type equivalence based on type normalization, which is expressive enough to typecheck typical uses of recursive modules. Our approach is purely syntactic and the definition of the type system is ready for use in an actual implementation.
[Theory of computation, General programming languages, Language features, Formal language definitions, Software notations and tools, Formal languages and automata theory, Modules / packages, Recursion, Software and its engineering]
Freedom before commitment: a lightweight type system for object initialisation
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
One of the main purposes of object initialisation is to establish invariants such as a field being non-null or an immutable data structure containing specific values. These invariants are then implicitly assumed by the rest of the implementation, for instance, to ensure that a field may be safely dereferenced or that immutable data may be accessed concurrently. Consequently, letting an object escape from its constructor is dangerous; the escaping object might not yet satisfy its invariants, leading to errors in code that relies on them. Nevertheless, preventing objects entirely from escaping from their constructors is too restrictive; it is often useful to call auxiliary methods on the object under initialisation or to pass it to another constructor to set up mutually-recursive structures. We present a type system that tracks which objects are fully initialised and which are still under initialisation. The system can be used to prevent objects from escaping, but also to allow safe escaping by making explicit which objects might not yet satisfy their invariants. We designed, formalised and implemented our system as an extension to a non-null type system, but it is not limited to this application. Our system is conceptually simple and requires little annotation overhead; it is sound and sufficiently expressive for many common programming idioms. Therefore, we believe it to be the first such system suitable for mainstream use.
[Classes and objects, General programming languages, Language features, Software notations and tools, Software and its engineering]
Null dereference verification via over-approximated weakest pre-conditions analysis
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Null dereferences are a bane of programming in languages such as Java. In this paper we propose a sound, demand-driven, inter-procedurally context-sensitive dataflow analysis technique to verify a given dereference as safe or potentially unsafe. Our analysis uses an abstract lattice of formulas to find a pre-condition at the entry of the program such that a null-dereference can occur only if the initial state of the program satisfies this pre-condition. We use a simplified domain of formulas, abstracting out integer arithmetic, as well as unbounded access paths due to recursive data structures. For the sake of precision we model aliasing relationships explicitly in our abstract lattice, enable strong updates, and use a limited notion of path sensitivity. For the sake of scalability we prune formulas continually as they get propagated, reducing to true conjuncts that are less likely to be useful in validating or invalidating the formula. We have implemented our approach, and present an evaluation of it on a set of ten real Java programs. Our results show that the set of design features we have incorporated enable the analysis to (a) explore long, inter-procedural paths to verify each dereference, with (b) reasonable accuracy, and (c) very quick response time per dereference, making it suitable for use in desktop development environments.
[Software creation and management, Software verification and validation, Assertion checking, Assertions, Program verification, Functional verification, Theory of computation, Semantics and reasoning, Hardware validation, Hardware, Program reasoning, Software and its engineering]
F4F: taint analysis of framework-based web applications
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
This paper presents F4F (Framework For Frameworks), a system for effective taint analysis of framework-based web applications. Most modern web applications utilize one or more web frameworks, which provide useful abstractions for common functionality. Due to extensive use of reflective language constructs in framework implementations, existing static taint analyses are often ineffective when applied to framework-based applications. While previous work has included ad hoc support for certain framework constructs, adding support for a large number of frameworks in this manner does not scale from an engineering standpoint. F4F employs an initial analysis pass in which both application code and configuration files are processed to generate a specification of framework-related behaviors. A taint analysis engine can leverage these specifications to perform a much deeper, more precise analysis of framework-based applications. Our specification language has only a small number of simple but powerful constructs, easing analysis engine integration. With this architecture, new frameworks can be handled with no changes to the core analysis engine, yielding significant engineering benefits. We implemented specification generators for several web frameworks and added F4F support to a state-of-the-art taint-analysis engine. In an experimental evaluation, the taint analysis enhanced with F4F discovered 525 new issues across nine benchmarks, a harmonic mean of 2.10X more issues per benchmark. Furthermore, manual inspection of a subset of the new issues showed that many were exploitable or reflected bad security practice.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
RoleCast: finding missing security checks when you do not know what checks are
Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 46 ISSUE 10
2011
Web applications written in languages such as PHP and JSP are notoriously vulnerable to accidentally omitted authorization checks and other security bugs. Existing techniques that find missing security checks in library and system code assume that (1) security checks can be recognized syntactically and (2) the same pattern of checks applies universally to all programs. These assumptions do not hold for Web applications. Each Web application uses different variables and logic to check the user's permissions. Even within the application, security logic varies based on the user's role, e.g., regular users versus administrators. This paper describes ROLECAST, the first system capable of statically identifying security logic that mediates security-sensitive events (such as database writes) in Web applications, rather than taking a specification of this logic as input. We observe a consistent software engineering pattern-the code that implements distinct user role functionality and its security logic resides in distinct methods and files-and develop a novel algorithm for discovering this pattern in Web applications. Our algorithm partitions the set of file contexts (a coarsening of calling contexts) on which security-sensitive events are control dependent into roles. Roles are based on common functionality and security logic. ROLECAST identifies security-critical variables and applies rolespecific variable consistency analysis to find missing security checks. ROLECAST discovered 13 previously unreported, remotely exploitable vulnerabilities in 11 substantial PHP and JSP applications, with only 3 false positives. This paper demonstrates that (1) accurate inference of application- and role-specific security logic improves the security of Web applications without specifications, and (2) static analysis can discover security logic automatically by exploiting distinctive software engineering features.
[Validation, Cross-computing tools and techniques, Software creation and management, Empirical software validation, Software verification and validation, Program analysis, Theory of computation, Semantics and reasoning, Process validation, Program semantics, Program reasoning, General and reference, Software and its engineering]
Type-based safe resource deallocation for shared-memory concurrency
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We propose a type system to guarantee safe resource deallocation for shared-memory concurrent programs by extending the previous type system based on fractional ownerships. Here, safe resource deallocation means that memory cells, locks, or threads are not left allocated when a program terminates. Our framework supports (1) fork/join parallelism, (2) synchronization with locks, and (3) dynamically allocated memory cells and locks. The type system is proved to be sound. We also provide a type inference algorithm for the type system and a prototype implementation of the algorithm.
[Software creation and management, Software functional properties, Software verification and validation, Language types, Software notations and tools, Parallel programming languages, Program verification, Theory of computation, Semantics and reasoning, Distributed programming languages, General programming languages, Concurrent programming languages, Formal software verification, Program reasoning, Formal methods, Software organization and properties, Software and its engineering]
Uniqueness and reference immutability for safe parallelism
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
A key challenge for concurrent programming is that side-effects (memory operations) in one thread can affect the behavior of another thread. In this paper, we present a type system to restrict the updates to memory to prevent these unintended side-effects. We provide a novel combination of immutable and unique (isolated) types that ensures safe parallelism (race freedom and deterministic execution). The type system includes support for polymorphism over type qualifiers, and can easily create cycles of immutable objects. Key to the system's flexibility is the ability to recover immutable or externally unique references after violating uniqueness without any explicit alias tracking. Our type system models a prototype extension to C# that is in active use by a Microsoft team. We describe their experiences building large systems with this extension. We prove the soundness of the type system by an embedding into a program logic.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Concurrent programming structures, Program semantics, Software notations and tools, Program reasoning, Program analysis, Software and its engineering]
Safe compiler-driven transaction checkpointing and recovery
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Several studies have shown that a large fraction of the work performed inside memory transactions in representative programs is wasted due to the transaction experiencing a conflict and aborting. Aborts inside long running transactions are especially influential to performance and the simplicity of the TM programming model (relative to using finegrained locking) in synchronizing large critical sections means that large transactions are common and this exacerbates the problem of wasted work. In this paper we present a practical transaction checkpoint and recovery scheme in which transactions that experience a conflict can restore their state (including the local context in which they were executing) to some dynamic program point before this access and begin execution from that point. This state saving and restoration is implemented by checkpoint operations that are generated by a compiler into the transaction's body and are also optimized to reduce the amount of state that is saved and restored. We also describe a runtime system that manages these checkpointed states and orchestrates the restoration of the right checkpointed state for a conflict on a particular transactional access. Moreover the synthesis of these save and restore operations, their optimization and invocation at runtime are completely transparent to the programmer. We have implemented the checkpoint generation and optimization scheme in the LLVM compiler and runtime support for the TL2 STM system. Our experiments indicate that for many parallel programs using such checkpoint recovery schemes can result in upto several orders of magnitude reduction in number of aborts and significant execution time speedups relative to plain transactional programs for the same number of threads.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Towards a practical secure concurrent language
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We demonstrate that a practical concurrent language can be extended in a natural way with information security mechanisms that provably enforce strong information security guarantees. We extend the X10 concurrent programming language with coarse-grained information-flow control. Central to X10 concurrency abstractions is the notion of a place: a container for data and computation. We associate a security level with each place, and restrict each place to store only data appropriate for that security level. When places interact only with other places at the same security level, then our security mechanisms impose no restrictions. When places of differing security levels interact, our information security analysis prevents potentially dangerous information flows, including information flow through covert scheduling channels. The X10 concurrency mechanisms simplify reasoning about information flow in concurrent programs. We present a static analysis that enforces a noninterference-based extensional information security condition in a calculus that captures the key aspects of X10's place abstraction and async-finish parallelism. We extend this security analysis to support many of X10's language features, and have implemented a prototype compiler for the resulting language.
[Security and privacy, General programming languages, Language features, Software notations and tools, Systems security, Information flow control, Operating systems security, Software and its engineering]
Reducing the barriers to writing verified specifications
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Formally verifying a program requires significant skill not only because of complex interactions between program subcomponents, but also because of deficiencies in current verification interfaces. These skill barriers make verification economically unattractive by preventing the use of less-skilled (less-expensive) workers and distributed workflows (i.e., crowdsourcing). This paper presents VeriWeb, a web-based IDE for verification that decomposes the task of writing verifiable specifications into manageable subproblems. To overcome the information loss caused by task decomposition, and to reduce the skill required to verify a program, VeriWeb incorporates several innovative user interface features: drag and drop condition construction, concrete counterexamples, and specification inlining. To evaluate VeriWeb, we performed three experiments. First, we show that VeriWeb lowers the time and monetary cost of verification by performing a comparative study of VeriWeb and a traditional tool using 14 paid subjects contracted hourly from Exhedra Solution's vWorker online marketplace. Second, we demonstrate the dearth and insufficiency of current ad-hoc labor marketplaces for verification by recruiting workers from Amazon's Mechanical Turk to perform verification with VeriWeb. Finally, we characterize the minimal communication overhead incurred when VeriWeb is used collaboratively by observing two pairs of developers each use the tool simultaneously to verify a single program.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
GPUVerify: a verifier for GPU kernels
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We present a technique for verifying race- and divergence-freedom of GPU kernels that are written in mainstream kernel programming languages such as OpenCL and CUDA. Our approach is founded on a novel formal operational semantics for GPU programming termed synchronous, delayed visibility (SDV) semantics. The SDV semantics provides a precise definition of barrier divergence in GPU kernels and allows kernel verification to be reduced to analysis of a sequential program, thereby completely avoiding the need to reason about thread interleavings, and allowing existing modular techniques for program verification to be leveraged. We describe an efficient encoding for data race detection and propose a method for automatically inferring loop invariants required for verification. We have implemented these techniques as a practical verification tool, GPUVerify, which can be applied directly to OpenCL and CUDA source code. We evaluate GPUVerify with respect to a set of 163 kernels drawn from public and commercial sources. Our evaluation demonstrates that GPUVerify is capable of efficient, automatic verification of a large number of real-world kernels.
[Theory of computation, Semantics and reasoning, Program reasoning, Assertions, Program verification, Invariants]
Modular and verified automatic program repair
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We study the problem of suggesting code repairs at design time, based on the warnings issued by modular program verifiers. We introduce the concept of a verified repair, a change to a program's source that removes bad execution traces while increasing the number of good traces, where the bad/good traces form a partition of all the traces of a program. Repairs are property-specific. We demonstrate our framework in the context of warnings produced by the modular cccheck (a.k.a. Clousot) abstract interpreter, and generate repairs for missing contracts, incorrect locals and objects initialization, wrong conditionals, buffer overruns, arithmetic overflow and incorrect floating point comparisons. We report our experience with automatically generating repairs for the .NET framework libraries, generating verified repairs for over 80% of the warnings generated by cccheck.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Mitigating the compiler optimization phase-ordering problem using machine learning
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Today's compilers have a plethora of optimizations to choose from, and the correct choice of optimizations can have a significant impact on the performance of the code being optimized. Furthermore, choosing the correct order in which to apply those optimizations has been a long standing problem in compilation research. Each of these optimizations interacts with the code and in turn with all other optimizations in complicated ways. Traditional compilers typically apply the same set of optimization in a fixed order to all functions in a program, without regard the code being optimized. Understanding the interactions of optimizations is very important in determining a good solution to the phase-ordering problem. This paper develops a new approach that automatically selects good optimization orderings on a per method basis within a dynamic compiler. Our approach formulates the phase-ordering problem as a Markov process and uses a characterization of the current state of the code being optimized to creating a better solution to the phase ordering problem. Our technique uses neuro-evolution to construct an artificial neural network that is capable of predicting beneficial optimization ordering for a piece of code that is being optimized. We implemented our technique in Jikes RVM and achieved significant improvements on a set of standard Java benchmarks over a well-engineered fixed order.
[Source code generation, Neural networks, Machine learning, Computing methodologies, Machine learning approaches, Software notations and tools, Software and its engineering, Compilers]
Optimization coaching: optimizers learn to communicate with programmers
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Optimizing compilers map programs in high-level languages to high-performance target language code. To most programmers, such a compiler constitutes an impenetrable black box whose inner workings are beyond their understanding. Since programmers often must understand the workings of their compilers to achieve their desired performance goals, they typically resort to various forms of reverse engineering, such as examining compiled code or intermediate forms. Instead, optimizing compilers should engage programmers in a dialog. This paper introduces one such possible form of dialog: optimization coaching. An optimization coach watches while a program is compiled, analyzes the results, generates suggestions for enabling further compiler optimization in the source program, and presents a suitable synthesis of its results to the programmer. We present an evaluation based on case studies, which illustrate how an optimization coach can help programmers achieve optimizations resulting in substantial performance improvements.
[Software notations and tools, Software and its engineering, Compilers]
Adaptive multi-level compilation in a trace-based Java JIT compiler
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
This paper describes our multi-level compilation techniques implemented in a trace-based Java JIT compiler (trace-JIT). Like existing multi-level compilation for method-based compilers, we start JIT compilation with a small compilation scope and a low optimization level so the program can start running quickly. Then we identify hot paths with a timer-based sampling profiler, generate long traces that capture the hot paths, and recompile them with a high optimization level to improve the peak performance. A key to high performance is selecting long traces that effectively capture the entire hot paths for upgrade recompilations. To do this, we introduce a new technique to generate a directed graph representing the control flow, a TTgraph, and use the TTgraph in the trace selection engine to efficiently select long traces. We show that our multi-level compilation improves the peak performance of programs by up to 58.5% and 22.2% on average compared to compiling all of the traces only at a low optimization level. Comparing the performance with our multi-level compilation to the performance when compiling all of the traces at a high optimization level, our technique can reduce the startup times of programs by up to 61.1% and 31.3% on average without significant reduction in the peak performance. Our results show that our adaptive multi-level compilation can balance the peak performance and startup time by taking advantage of different optimization levels.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
On the benefits and pitfalls of extending a statically typed language JIT compiler for dynamic scripting languages
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Whenever the need to compile a new dynamically typed language arises, an appealing option is to repurpose an existing statically typed language Just-In-Time (JIT) compiler (repurposed JIT compiler). Existing repurposed JIT compilers (RJIT compilers), however, have not yet delivered the hoped-for performance boosts. The performance of JVM languages, for instance, often lags behind standard interpreter implementations. Even more customized solutions that extend the internals of a JIT compiler for the target language compete poorly with those designed specifically for dynamically typed languages. Our own Fiorano JIT compiler is an example of this problem. As a state-of-the-art, RJIT compiler for Python, the Fiorano JIT compiler outperforms two other RJIT compilers (Unladen Swallow and Jython), but still shows a noticeable performance gap compared to PyPy, today's best performing Python JIT compiler. In this paper, we discuss techniques that have proved effective in the Fiorano JIT compiler as well as limitations of our current implementation. More importantly, this work offers the first in-depth look at benefits and limitations of the repurposed JIT compiler approach. We believe the most common pitfall of existing RJIT compilers is not focusing sufficiently on specialization, an abundant optimization opportunity unique to dynamically typed languages. Unfortunately, the lack of specialization cannot be overcome by applying traditional optimizations.
[Interpreters, Software notations and tools, Incremental compilers, Software and its engineering, Compilers]
An abstract interpretation framework for refactoring with application to extract methods with contracts
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Method extraction is a common refactoring feature provided by most modern IDEs. It replaces a user-selected piece of code with a call to an automatically generated method. We address the problem of automatically inferring contracts (precondition, postcondition) for the extracted method. We require the inferred contract: (a) to be valid for the extracted method (validity); (b) to guard the language and programmer assertions in the body of the extracted method by an opportune precondition (safety); (c) to preserve the proof of correctness of the original code when analyzing the new method separately (completeness); and (d) to be the most general possible (generality). These requirements rule out trivial solutions (e.g., inlining, projection, etc). We propose two theoretical solutions to the problem. The first one is simple and optimal. It is valid, safe, complete and general but unfortunately not effectively computable (except for unrealistic finiteness/decidability hypotheses). The second one is based on an iterative forward/backward method. We show it to be valid, safe, and, under reasonable assumptions, complete and general. We prove that the second solution subsumes the first. All justifications are provided with respect to a new, set-theoretic version of Hoare logic (hence without logic), and abstractions of Hoare logic, revisited to avoid surprisingly unsound inference rules. We have implemented the new algorithms on the top of two industrial-strength tools (CCCheck and the Microsoft Roslyn CTP). Our experience shows that the analysis is both fast enough to be used in an interactive environment and precise enough to generate good annotations.
[Software creation and management, Software verification and validation, Extra-functional properties, Software notations and tools, Theory of computation, Software development process management, Process validation, Proof theory, Logic, Formal methods, Software organization and properties, Software and its engineering, Validation, Cross-computing tools and techniques, Empirical software validation, Software development methods, Software functional properties, Software reliability, Specification languages, Correctness, Software development techniques, System description languages, Formal software verification, Reliability, General and reference]
Refactoring android Java code for on-demand computation offloading
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Computation offloading is a promising way to improve the performance as well as reducing the battery power consumption of a smartphone application by executing some parts of the application on a remote server. Supporting such capability is not easy for smartphone application developers due to (1) correctness: some code, e.g., that for GPS, gravity, and other sensors, can run only on the smartphone so that developers have to identify which parts of the application cannot be offloaded; (2) effectiveness: the reduced execution time must be greater than the network delay caused by computation offloading so that developers need to calculate which parts are worth offloading; (3) adaptability: smartphone applications often face changes of user requirements and runtime environments so that developers need to implement the adaptation on offloading. More importantly, considering the large number of today's smartphone applications, solutions applicable for legacy applications will be much more valuable. In this paper, we present a tool, named DPartner, that automatically refactors Android applications to be the ones with computation offloading capability. For a given Android application, DPartner first analyzes its bytecode for discovering the parts worth offloading, then rewrites the bytecode to implement a special program structure supporting on-demand offloading, and finally generates two artifacts to be deployed onto an Android phone and the server, respectively. We evaluated DPartner on three real-world Android applications, demonstrating the reduction of execution time by 46%-97% and battery power consumption by 27%-83%.
[Management of computing and information systems, Software maintenance, Software creation and management, Object oriented languages, Language types, Professional topics, Software notations and tools, Software post-development issues, Distributed systems organizing principles, Computer systems organization, Software system structures, Distributed architectures, General programming languages, Software management, Social and professional topics, Software organization and properties, Software and its engineering, Architectures]
Kitsune: efficient, general-purpose dynamic software updating for C
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Dynamic software updating (DSU) systems allow programs to be updated while running, thereby permitting developers to add features and fix bugs without downtime. This paper introduces Kitsune, a new DSU system for C whose design has three notable features. First, Kitsune's updating mechanism updates the whole program, not individual functions. This mechanism is more flexible than most prior approaches and places no restrictions on data representations or allowed compiler optimizations. Second, Kitsune makes the important aspects of updating explicit in the program text, making the program's semantics easy to understand while minimizing programmer effort. Finally, the programmer can write simple specifications to direct Kitsune to generate code that traverses and transforms old-version state for use by new code; such state transformation is often necessary, and is significantly more difficult in prior DSU systems. We have used Kitsune to update five popular, open-source, single- and multi-threaded programs, and find that few program changes are required to use Kitsune, and that it incurs essentially no performance overhead.
[Availability, Computer systems organization, Cross-computing tools and techniques, Maintainability and maintenance, Dependable and fault-tolerant systems and networks, Reliability, General and reference]
Automating object transformations for dynamic software updating
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Dynamic software updating (DSU) systems eliminate costly downtime by dynamically fixing bugs and adding features to executing programs. Given a static code patch, most DSU systems construct runtime code changes automatically. However, a dynamic update must also specify how to change the running program's execution state, e.g., the stack and heap, to make it compatible with the new code. Constructing such state transformations correctly and automatically remains an open problem. This paper presents a solution called Targeted Object Synthesis (TOS). TOS first executes the same tests on the old and new program versions separately, observing the program heap state at a few corresponding points. Given two corresponding heap states, TOS matches objects in the two versions using key fields that uniquely identify objects and correlate old and new-version objects. Given example object pairs, TOS then synthesizes the simplest-possible function that transforms an old-version object to its new-version counterpart. We show that TOS is effective on updates to four open-source server programs for which it generates non-trivial transformation functions that use conditionals, operate on collections, and fix memory leaks. These transformations help programmers understand their changes and apply dynamic software updates.
[]
Exploring multi-threaded Java application performance on multicore hardware
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
While there have been many studies of how to schedule applications to take advantage of increasing numbers of cores in modern-day multicore processors, few have focused on multi-threaded managed language applications which are prevalent from the embedded to the server domain. Managed languages complicate performance studies because they have additional virtual machine threads that collect garbage and dynamically compile, closely interacting with application threads. Further complexity is introduced as modern multicore machines have multiple sockets and dynamic frequency scaling options, broadening opportunities to reduce both power and running time. In this paper, we explore the performance of Java applications, studying how best to map application and virtual machine (JVM) threads to a multicore, multi-socket environment. We explore both the cost of separating JVM threads from application threads, and the opportunity to speed up or slow down the clock frequency of isolated threads. We perform experiments with the multi-threaded DaCapo benchmarks and pseudojbb2005 running on the Jikes Research Virtual Machine, on a dual-socket, 8-core Intel Nehalem machine to reveal several novel, and sometimes counter-intuitive, findings. We believe these insights are a first but important step towards understanding and optimizing managed language performance on modern hardware.
[Garbage collection, Operating systems, Memory management, Software notations and tools, Runtime environments, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Work-stealing without the baggage
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Work-stealing is a promising approach for effectively exploiting software parallelism on parallel hardware. A programmer who uses work-stealing explicitly identifies potential parallelism and the runtime then schedules work, keeping otherwise idle hardware busy while relieving overloaded hardware of its burden. Prior work has demonstrated that work-stealing is very effective in practice. However, work-stealing comes with a substantial overhead: as much as 2x to 12x slowdown over orthodox sequential code. In this paper we identify the key sources of overhead in work-stealing schedulers and present two significant refinements to their implementation. We evaluate our work-stealing designs using a range of benchmarks, four different work-stealing implementations, including the popular fork-join framework, and a range of architectures. On these benchmarks, compared to orthodox sequential Java, our fastest design has an overhead of just 15%. By contrast, fork-join has a 2.3x overhead and the previous implementation of the system we use has an overhead of 4.1x. These results and our insight into the sources of overhead for work-stealing implementations give further hope to an already promising technique for exploiting increasingly available hardware parallelism.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering, Compilers]
Molecule: using monadic and streaming I/O to compose process networks on the JVM
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Molecule is a domain specific language library embedded in Scala for easing the creation of scalable and modular concurrent applications on the JVM. Concurrent applications are modeled as parallel process networks that exchange information over mobile and type-safe messaging interfaces. In this paper, we present a concurrent programming environment that combines functional and imperative programming. Using a monad, we structure the sequential or parallel coordination of user-level threads, without JVM modifications or compiler support. Our mobile channel interfaces expose reusable and parallelizable higher-order functions, as if they were streams in a lazily evaluated functional programming language. The support for graceful termination of entire process networks is simplified by integrating channel poisoning with monadic exceptions and resource control. Our runtime and system-level interfaces leverage message batching and a novel flow parallel scheduler to limit expensive context switches in multicore environments. We illustrate the expressiveness and performance benefits on a 24-core AMD Opteron machine with three classical examples: a thread ring, a genuine prime sieve and a chameneos-redux.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Recursion, Concurrent computing methodologies, Patterns, Software and its engineering]
A black-box approach to understanding concurrency in DaCapo
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Increasing levels of hardware parallelism are one of the main challenges for programmers and implementers of managed runtimes. Any concurrency or scalability improvements must be evaluated experimentally. However, application benchmarks available today may not reflect the highly concurrent applications we anticipate in the future. They may also behave in ways that VM developers do not expect. We provide a set of platform independent concurrency related metrics and an in-depth observational study of current state of the art benchmarks, discovering how concurrent they really are, how they scale the work and how they synchronise and communicate via shared memory.
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
Automatically enhancing locality for tree traversals with traversal splicing
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Generally applicable techniques for improving temporal locality in irregular programs, which operate over pointer-based data structures such as trees and graphs, are scarce. Focusing on a subset of irregular programs, namely, tree traversal algorithms like Barnes-Hut and nearest neighbor, previous work has proposed point blocking, a technique analogous to loop tiling in regular programs, to improve locality. However point blocking is highly dependent on point sorting, a technique to reorder points so that consecutive points will have similar traversals. Performing this a priori sort requires an understanding of the semantics of the algorithm and hence highly application specific techniques. In this work, we propose traversal splicing, a new, general, automatic locality optimization for irregular tree traversal codes, that is less sensitive to point order, and hence can deliver substantially better performance, even in the absence of semantic information. For six benchmark algorithms, we show that traversal splicing can deliver single-thread speedups of up to 9.147 (geometric mean: 3.095) over baseline implementations, and up to 4.752 (geometric mean: 2.079) over point-blocked implementations. Further, we show that in many cases, automatically applying traversal splicing to a baseline implementation yields performance that is better than carefully hand-optimized implementations.
[Software notations and tools, Software and its engineering, Compilers]
Elixir: a system for synthesizing concurrent graph programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Algorithms in new application areas like machine learning and network analysis use "irregular" data structures such as graphs, trees and sets. Writing efficient parallel code in these problem domains is very challenging because it requires the programmer to make many choices: a given problem can usually be solved by several algorithms, each algorithm may have many implementations, and the best choice of algorithm and implementation can depend not only on the characteristics of the parallel platform but also on properties of the input data such as the structure of the graph. One solution is to permit the application programmer to experiment with different algorithms and implementations without writing every variant from scratch. Auto-tuning to find the best variant is a more ambitious solution. These solutions require a system for automatically producing efficient parallel implementations from high-level specifications. Elixir, the system described in this paper, is the first step towards this ambitious goal. Application programmers write specifications that consist of an operator, which describes the computations to be performed, and a schedule for performing these computations. Elixir uses sophisticated inference techniques to produce efficient parallel code from such specifications. We used Elixir to automatically generate many parallel implementations for three irregular problems: breadth-first search, single source shortest path, and betweenness-centrality computation. Our experiments show that the best generated variants can be competitive with handwritten code for these problems from other research groups; for some inputs, they even outperform the handwritten versions.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
From clarity to efficiency for distributed algorithms
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
This paper describes a very high-level language for clear description of distributed algorithms and optimizations necessary for generating efficient implementations. The language supports high-level control flows where complex synchronization conditions can be expressed using high-level queries, especially logic quantifications, over message history sequences. Unfortunately, the programs would be extremely inefficient, including consuming unbounded memory, if executed straightforwardly. We present new optimizations that automatically transform complex synchronization conditions into incremental updates of necessary auxiliary values as messages are sent and received. The core of the optimizations is the first general method for efficient implementation of logic quantifications. We have developed an operational semantics of the language, implemented a prototype of the compiler and the optimizations, and successfully used the language and implementation on a variety of important distributed algorithms.
[Very high level languages, Computing methodologies, Language types, Software notations and tools, Distributed computing methodologies, Theory of computation, Semantics and reasoning, Distributed programming languages, General programming languages, Program specifications, Program reasoning, Logic, Software and its engineering]
Program extrapolation with jennisys
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
The desired behavior of a program can be described using an abstract model. Compiling such a model into executable code requires advanced compilation techniques known as synthesis. This paper presents an object-based language, called Jennisys, where programming is done by introducing an abstract model, defining a concrete data representation for the model, and then being aided by automatic synthesis to produce executable code. The paper also presents a synthesis technique for the language. The technique is built on an automatic program verifier that, via an underlying SMT solver, is capable of providing concrete models to failed verifications. The technique proceeds by obtaining sample input/output values from concrete models and then extrapolating programs from the sample points. The synthesis aims to produce code with assignments, branching structure, and possibly recursive calls. It is the first to synthesize code that creates and uses objects in dynamic data structures or aggregate objects. A prototype of the language and synthesis technique has been implemented.
[]
Bolt: on-demand infinite loop escape in unmodified binaries
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We present Bolt, a novel system for escaping from infinite and long-running loops. Directed by a user, Bolt can attach to a running process and determine if the program is executing an infinite loop. If so, Bolt can deploy multiple strategies to escape the loop, restore the responsiveness of the program, and enable the program to deliver useful output. Bolt operates on stripped x86 and x64 binaries, dynamically attaches and detaches to and from the program as needed, and dynamically detects loops and creates program state checkpoints to enable exploration of different escape strategies. Bolt can detect and escape from loops in off-the-shelf software, without available source code, and with no overhead in standard production use.
[Software creation and management, Software functional properties, Error handling and recovery, Software post-development issues, Correctness, Software development techniques, Software organization and properties, Software and its engineering, Maintaining software]
LEAN: simplifying concurrency bug reproduction via replay-supported execution reduction
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Debugging concurrent programs is known to be difficult due to scheduling non-determinism. The technique of multiprocessor deterministic replay substantially assists debugging by making the program execution reproducible. However, facing the huge replay traces and long replay time, the debugging task remains stunningly challenging for long running executions. We present a new technique, LEAN, on top of replay, that significantly reduces the complexity of the replay trace and the length of the replay time without losing the determinism in reproducing concurrency bugs. The cornerstone of our work is a redundancy criterion that characterizes the redundant computation in a buggy trace. Based on the redundancy criterion, we have developed two novel techniques to automatically identify and remove redundant threads and instructions in the bug reproduction execution. Our evaluation results with several real world concurrency bugs in large complex server programs demonstrate that LEAN is able to reduce the size, the number of threads, and the number of thread context switches of the replay trace by orders of magnitude, and accordingly greatly shorten the replay time.
[Software defect analysis, Traceability, Software creation and management, Software testing and debugging, Software verification and validation, Process validation, Software and its engineering]
IFRit: interference-free regions for dynamic data-race detection
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We propose a new algorithm for dynamic data-race detection. Our algorithm reports no false positives and runs on arbitrary C and C++ code. Unlike previous algorithms, we do not have to instrument every memory access or track a full happens-before relation. Our data-race detector, which we call IFRit, is based on a run-time abstraction called an interference-free region (IFR). An IFR is an interval of one thread's execution during which any write to a specific variable by a different thread is a data race. We insert instrumentation at compile time to monitor active IFRs at run-time. If the runtime observes overlapping IFRs for conflicting accesses to the same variable in two different threads, it reports a race. The static analysis aggregates information for multiple accesses to the same variable, avoiding the expense of having to instrument every memory access in the program. We directly compare IFRit to FastTrack and ThreadSanitizer, two state-of-the-art fully-precise data-race detectors. We show that IFRit imposes a fraction of the overhead of these detectors. We show that for the PARSEC benchmarks, and several real-world applications, IFRit finds many of the races detected by a fully-precise detector. We also demonstrate that sampling can further reduce IFRit's performance overhead without completely forfeiting precision.
[Software defect analysis, Middleware for databases, Software creation and management, Distributed transaction monitors, Software verification and validation, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Contextual software domains, Information systems, Software testing and debugging, Operating systems, General programming languages, Data management systems, Monitors, Software organization and properties, Software and its engineering, Process management]
Maple: a coverage-driven testing tool for multithreaded programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Testing multithreaded programs is a hard problem, because it is challenging to expose those rare interleavings that can trigger a concurrency bug. We propose a new thread interleaving coverage-driven testing tool called Maple that seeks to expose untested thread interleavings as much as possible. It memoizes tested interleavings and actively seeks to expose untested interleavings for a given test input to increase interleaving coverage. We discuss several solutions to realize the above goal. First, we discuss a coverage metric based on a set of interleaving idioms. Second, we discuss an online technique to predict untested interleavings that can potentially be exposed for a given test input. Finally, the predicted untested interleavings are exposed by actively controlling the thread schedule while executing for the test input. We discuss our experiences in using the tool to expose several known and unknown bugs in real-world applications such as Apache and MySQL.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Taming MATLAB
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
MATLAB is a dynamic scientific language used by scientists, engineers and students worldwide. Although MATLAB is very suitable for rapid prototyping and development, MATLAB users often want to convert their final MATLAB programs to a static language such as FORTRAN. This paper presents an extensible object-oriented toolkit for supporting the generation of static programs from dynamic MATLAB programs. Our open source toolkit, called the MATLAB Tamer, identifies a large tame subset of MATLAB, supports the generation of a specialized Tame IR for that subset, provides a principled approach to handling the large number of builtin MATLAB functions, and supports an extensible interprocedural value analysis for estimating MATLAB types and call graphs.
[Software notations and tools, Software and its engineering, Compilers]
Scaling symbolic execution using ranged analysis
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
This paper introduces a novel approach to scale symbolic execution --- a program analysis technique for systematic exploration of bounded execution paths---for test input generation. While the foundations of symbolic execution were developed over three decades ago, recent years have seen a real resurgence of the technique, specifically for systematic bug finding. However, scaling symbolic execution remains a primary technical challenge due to the inherent complexity of the path-based exploration that lies at core of the technique. Our key insight is that the state of the analysis can be represented highly compactly: a test input is all that is needed to effectively encode the state of a symbolic execution run. We present ranged symbolic execution, which embodies this insight and uses two test inputs to define a range, i.e., the beginning and end, for a symbolic execution run. As an application of our approach, we show how it enables scalability by distributing the path exploration---both in a sequential setting with a single worker node and in a parallel setting with multiple workers. As an enabling technology, we leverage the open-source, state-of-the-art symbolic execution tool KLEE. Experimental results using 71 programs chosen from the widely deployed GNU Coreutils set of Unix utilities show that our approach provides a significant speedup over KLEE. For example, using 10 worker cores, we achieve an average speed-up of 6.6X for the 71 programs.
[Theory of computation, Models of computation, Software creation and management, Semantics and reasoning, Abstract machines, Software verification and validation, Computing methodologies, Symbolic and algebraic manipulation, Program reasoning, Abstraction, Software and its engineering]
Higher-order symbolic execution via contracts
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We present a new approach to automated reasoning about higher-order programs by extending symbolic execution to use behavioral contracts as symbolic values, thus enabling symbolic approximation of higher-order behavior. Our approach is based on the idea of an abstract reduction semantics that gives an operational semantics to programs with both concrete and symbolic components. Symbolic components are approximated by their contract and our semantics gives an operational interpretation of contracts-as-values. The result is an executable semantics that soundly predicts program behavior, including contract failures, for all possible instantiations of symbolic components. We show that our approach scales to an expressive language of contracts including arbitrary programs embedded as predicates, dependent function contracts, and recursive contracts. Supporting this rich language of specifications leads to powerful symbolic reasoning using existing program constructs. We then apply our approach to produce a verifier for contract correctness of components, including a sound and computable approximation to our semantics that facilitates fully automated contract verification. Our implementation is capable of verifying contracts expressed in existing programs, and of justifying contract-elimination optimizations.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Software notations and tools, Verification, Formal languages and automata theory, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Formal language definitions, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Checking reachability using matching logic
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
This paper presents a verification framework that is parametric in a (trusted) operational semantics of some programming language. The underlying proof system is language-independent and consists of eight proof rules. The proof system is proved partially correct and relatively complete (with respect to the programming language configuration model). To show its practicality, the generic framework is instantiated with a fragment of C and evaluated with encouraging results.
[Theory of computation, Semantics and reasoning, Operational semantics, Program semantics]
The HipHop compiler for PHP
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Scripting languages are widely used to quickly accomplish a variety of tasks because of the high productivity they enable. Among other reasons, this increased productivity results from a combination of extensive libraries, fast development cycle, dynamic typing, and polymorphism. The dynamic features of scripting languages are traditionally associated with interpreters, which is the approach used to implement most scripting languages. Although easy to implement, interpreters are generally slow, which makes scripting languages prohibitive for implementing large, CPU-intensive applications. This efficiency problem is particularly important for PHP given that it is the most commonly used language for server-side web development. This paper presents the design, implementation, and an evaluation of the HipHop compiler for PHP. HipHop goes against the standard practice and implements a very dynamic language through static compilation. After describing the most challenging PHP features to support through static compilation, this paper presents HipHop's design and techniques that support almost all PHP features. We then present a thorough evaluation of HipHop running both standard benchmarks and the Facebook web site. Overall, our experiments demonstrate that HipHop is about 5.5x faster than standard, interpreted PHP engines. As a result, HipHop has reduced the number of servers needed to run Facebook and other web sites by a factor between 4 and 6, thus drastically cutting operating costs.
[Source code generation, Software notations and tools, Software and its engineering, Compilers]
Dependent types for JavaScript
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We present Dependent JavaScript (DJS), a statically typed dialect of the imperative, object-oriented, dynamic language. DJS supports the particularly challenging features such as run-time type-tests, higher-order functions, extensible objects, prototype inheritance, and arrays through a combination of nested refinement types, strong updates to the heap, and heap unrolling to precisely track prototype hierarchies. With our implementation of DJS, we demonstrate that the type system is expressive enough to reason about a variety of tricky idioms found in small examples drawn from several sources, including the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Inheritance, Software notations and tools, Programming logic, Program reasoning, Logic, Software and its engineering, Polymorphism]
Eval begone!: semi-automated removal of eval from javascript programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Eval endows JavaScript developers with great power. It allows developers and end-users, by turning text into executable code, to seamlessly extend and customize the behavior of deployed applications as they are running. With great power comes great responsibility, though not in our experience. In previous work we demonstrated through a large corpus study that programmers wield that power in rather irresponsible and arbitrary ways. We showed that most calls to eval fall into a small number of very predictable patterns. We argued that those patterns could easily be recognized by an automated algorithm and that they could almost always be replaced with safer JavaScript idioms. In this paper we set out to validate our claim by designing and implementing a tool, which we call Evalorizer, that can assist programmers in getting rid of their unneeded evals. We use the tool to remove eval from a real-world website and validated our approach over logs taken from the top 100 websites with a success rate over 97% under an open world assumption.
[Software creation and management, Software notations and tools, Software post-development issues, Software reverse engineering, Development frameworks and environments, Software and its engineering]
Formal specification of a JavaScript module system
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
The JavaScript programming language, originally developed as a simple scripting language, is now the language of choice for web applications. All the top 100 sites on the web use JavaScript and its use outside web pages is rapidly growing. However, JavaScript is not yet ready for programming in the large: it does not support a module system. Lack of namespaces introduces module patterns, and makes it difficult to use multiple JavaScript frameworks together. In this paper, we propose a formal specification of a JavaScript module system. A module system for JavaScript will allow safe and incremental development of JavaScript web applications. While the next version of the JavaScript standard proposes a module system, it informally describes its design in prose. We formally specify a module system as an extension to the existing JavaScript language, and rigorously describe its semantics via desugaring to LambdaJS, a prior core calculus for JavaScript. We implement the desugaring process and show its faithfulness using real-world test suites. Finally, we define a set of properties for valid JavaScript programs using modules and formally prove that the proposed module system satisfies the validity properties.
[General programming languages, Language features, Software notations and tools, Modules / packages, Software and its engineering]
AutoMan: a platform for integrating human-based and digital computation
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Humans can perform many tasks with ease that remain difficult or impossible for computers. Crowdsourcing platforms like Amazon's Mechanical Turk make it possible to harness human-based computational power at an unprecedented scale. However, their utility as a general-purpose computational platform remains limited. The lack of complete automation makes it difficult to orchestrate complex or interrelated tasks. Scheduling more human workers to reduce latency costs real money, and jobs must be monitored and rescheduled when workers fail to complete their tasks. Furthermore, it is often difficult to predict the length of time and payment that should be budgeted for a given task. Finally, the results of human-based computations are not necessarily reliable, both because human skills and accuracy vary widely, and because workers have a financial incentive to minimize their effort. This paper introduces AutoMan, the first fully automatic crowdprogramming system. AutoMan integrates human-based computations into a standard programming language as ordinary function calls, which can be intermixed freely with traditional functions. This abstraction lets AutoMan programmers focus on their programming logic. An AutoMan program specifies a confidence level for the overall computation and a budget. The AutoMan runtime system then transparently manages all details necessary for scheduling, pricing, and quality control. AutoMan automatically schedules human tasks for each computation until it achieves the desired confidence level; monitors, reprices, and restarts human tasks as necessary; and maximizes parallelism across human workers while staying under budget.
[Philosophical/theoretical foundations of artificial intelligence, Probabilistic algorithms, Human-centered computing, Computing methodologies, Context specific languages, Software notations and tools, Probabilistic reasoning algorithms, Human computer interaction (HCI), Specialized application languages, Probability and statistics, Sequential Monte Carlo methods, Cognitive science, Mathematics of computing, Artificial intelligence, Markov-chain Monte Carlo methods, Software and its engineering]
Talk versus work: characteristics of developer collaboration on the jazz platform
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
IBM's Jazz initiative offers a state-of-the-art collaborative development environment (CDE) facilitating developer interactions around interdependent units of work. In this paper, we analyze development data across two versions of a major IBM product developed on the Jazz platform, covering in total 19 months of development activity, including 17,000+ work items and 61,000+ comments made by more than 190 developers in 35 locations. By examining the relation between developer talk and work, we find evidence that developers maintain a reasonably high level of connectivity with peer developers with whom they share work dependencies, but the span of a developer's communication goes much beyond the known dependencies of his/her work items. Using multiple linear regression models, we find that the number of defects owned by a developer is impacted by the number of other developers (s)he is connected through talk, his/her interpersonal influence in the network of work dependencies, the number of work items (s)he comments on, and the number work items (s)he owns. These effects are maintained even after controlling for workload, role, work dependency, and connection related factors. We discuss the implications of our results for collaborative software development and project governance.
[Software creation and management, Software and its engineering]
Speculative analysis of integrated development environment recommendations
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Modern integrated development environments make recommendations and automate common tasks, such as refactorings, auto-completions, and error corrections. However, these tools present little or no information about the consequences of the recommended changes. For example, a rename refactoring may: modify the source code without changing program semantics; modify the source code and (incorrectly) change program semantics; modify the source code and (incorrectly) create compilation errors; show a name collision warning and require developer input; or show an error and not change the source code. Having to compute the consequences of a recommendation -- either mentally or by making source code changes -- puts an extra burden on the developers. This paper aims to reduce this burden with a technique that informs developers of the consequences of code transformations. Using Eclipse Quick Fix as a domain, we describe a plug-in, Quick Fix Scout, that computes the consequences of Quick Fix recommendations. In our experiments, developers completed compilation-error removal tasks 10% faster when using Quick Fix Scout than Quick Fix, although the sample size was not large enough to show statistical significance.
[Integrated and visual development environments, Software notations and tools, Development frameworks and environments, Software and its engineering]
An empirical study of the influence of static type systems on the usability of undocumented software
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Abstract Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented API with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion times using a static type system, while for others, the opposite held. We conduct an exploratory study to try and theorize why.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Software data-triggered threads
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
The data-triggered threads (DTT) programming and execution model can increase parallelism and eliminate redundant computation. However, the initial proposal requires significant architecture support, which impedes existing applications and architectures from taking advantage of this model. This work proposes a pure software solution that supports the DTT model without any hardware support. This research uses a prototype compiler and runtime libraries running on top of existing machines. Several enhancements to the initial software implementation are presented, which further improve the performance. The software runtime system improves the performance of serial C SPEC benchmarks by 15% on a Nehalem processor, but by over 7X over the full suite of single-thread applications. It is shown that the DTT model can work in conjunction with traditional parallelism. The DTT model provides up to 64X speedup over parallel applications exploiting traditional parallelism.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Efficiently combining parallel software using fine-grained, language-level, hierarchical resource management policies
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
This paper presents Poli-C, a language extension, runtime library, and system daemon enabling fine-grained, language-level, hierarchical resource management policies. Poli-C is suitable for use in applications that compose parallel libraries, frameworks, and programs. In particular, we have added a powerful new statement to C for expressing resource limits and guarantees in such a way that programmers can set resource management policies even when the source code of parallel libraries and frameworks is not available. Poli-C enables application programmers to manage any resource exposed by the underlying OS, for example cores or IO bandwidth. Additionally, we have developed a domain-specific language for defining high-level resource management policies, and a facility for extending the kinds of resources that can be managed with our language extension. Finally, through a number of useful variations, our design offers a high degree of composability. We evaluate Poli-C by way of three case-studies: a scientific application, an image processing webserver, and a pair of parallel database join implementations. We found that using Poli-C yields efficiency gains that require the addition of only a few lines of code to applications.
[General programming languages, Language features, Concurrent programming structures, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
Execution privatization for scheduler-oblivious concurrent programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Making multithreaded execution less non-deterministic is a promising solution to address the difficulty of concurrent programming plagued by the non-deterministic thread scheduling. In fact, a vast category of concurrent programs are scheduler-oblivious: their execution is deterministic, regardless of the scheduling behavior. We present and formally prove a fundamental observation of the privatizability property for scheduler-oblivious programs, that paves the theoretical foundation for privatizing shared data accesses on a path segment. With privatization, the non-deterministic thread interleavings on the privatized accesses are isolated and as the consequence many concurrency problems are alleviated. We further present a path and context sensitive privatization algorithm that safely privatizes the program without introducing any additional program behavior. Our evaluation results show that the privatization opportunity pervasively exists in real world large complex concurrent systems. Through privatization, several real concurrency bugs are fixed and notable performance improvements are also achieved on benchmarks.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Integrating task parallelism with actors
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
This paper introduces a unified concurrent programming model combining the previously developed Actor Model (AM) and the task-parallel Async-Finish Model (AFM). With the advent of multi-core computers, there is a renewed interest in programming models that can support a wide range of parallel programming patterns. The proposed unified model shows how the divide-and-conquer approach of the AFM and the no-shared mutable state and event-driven philosophy of the AM can be combined to solve certain classes of problems more efficiently and productively than either of the aforementioned models individually. The unified model adds actor creation and coordination to the AFM, while also enabling parallelization within actors. This paper describes two implementations of the unified model as extensions of Habanero-Java and Habanero-Scala. The unified model adds to the foundations of parallel programs, and to the tools available for the programmer to aid in productivity and performance while developing parallel software.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering]
A variability-aware module system
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Module systems enable a divide and conquer strategy to software development. To implement compile-time variability in software product lines, modules can be composed in different combinations. However, this way, variability dictates a dominant decomposition. As an alternative, we introduce a variability-aware module system that supports compile-time variability inside a module and its interface. So, each module can be considered a product line that can be type checked in isolation. Variability can crosscut multiple modules. The module system breaks with the antimodular tradition of a global variability model in product-line development and provides a path toward software ecosystems and product lines of product lines developed in an open fashion. We discuss the design and implementation of such a module system on a core calculus and provide an implementation for C as part of the TypeChef project. Our implementation supports variability inside modules from #ifdef preprocessor directives and variable linking at the composition level. With our implementation, we type check all configurations of all modules of the open source product line Busybox with 811~compile-time options, perform linker check of all configurations, and report found type and linker errors -- without resorting to a brute-force strategy.
[Software creation and management, Reusability, General programming languages, Language features, Software notations and tools, Modules / packages, Software development techniques, Software libraries and repositories, Software and its engineering]
Gradual typing for first-class classes
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Dynamic type-checking and object-oriented programming often go hand-in-hand; scripting languages such as Python, Ruby, and JavaScript all embrace object-oriented (OO) programming. When scripts written in such languages grow and evolve into large programs, the lack of a static type discipline reduces maintainability. A programmer may thus wish to migrate parts of such scripts to a sister language with a static type system. Unfortunately, existing type systems neither support the flexible OO composition mechanisms found in scripting languages nor accommodate sound interoperation with untyped code. In this paper, we present the design of a gradual typing system that supports sound interaction between statically- and dynamically-typed units of class-based code. The type system uses row polymorphism for classes and thus supports mixin-based OO composition. To protect migration of mixins from typed to untyped components, the system employs a novel form of contracts that partially seal classes. The design comes with a theorem that guarantees the soundness of the type system even in the presence of untyped components.
[Classes and objects, General programming languages, Language features, Software notations and tools, Software and its engineering]
Constrained kinds
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Modern object-oriented languages such as X10 require a rich framework for types capable of expressing both value-dependency and genericity, and supporting pluggable, domain-specific extensions. In earlier work, we presented a framework for constrained types in object-oriented languages, parametrized by an underlying constraint system. Types are viewed as formulas C{c} where C is the name of a class or an interface and c is a constraint on the immutable instance state (the properties) of C. Constraint systems are a very expressive framework for partial information. Many (value-)dependent type systems for object-oriented languages can be viewed as constrained types. This paper extends the constrained types approach to handle type-dependency ("genericity"). The key idea is to introduce constrained kinds: in the same way that constraints on values can be used to define constrained types, constraints on types can define constrained kinds. We develop a core programming language with constrained kinds. Generic types are supported by introducing type variables---literally, variables with "type" Type---and permitting programs to impose subtyping and equality constraints on such variables. We formalize the type-checking rules and establish soundness. While the language now intertwines constraints on types and values, its type system remains parametric in the choice of the value constraint system (language and solver). We demonstrate that constrained kinds are expressive and practical and sketch possible extensions with a discussion of the design and implementation of X10.
[Theory of computation, Semantics and reasoning, Semantics, General programming languages, Object oriented languages, Program semantics, Language types, Formal language definitions, Software notations and tools, Software and its engineering]
Energy types
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
This paper presents a novel type system to promote and facilitate energy-aware programming. Energy Types is built upon a key insight into today's energy-efficient systems and applications: despite the popular perception that energy and power can only be described in joules and watts, real-world energy management is often based on discrete phases and modes, which in turn can be reasoned about by type systems very effectively. A phase characterizes a distinct pattern of program workload, and a mode represents an energy state the program is expected to execute in. This paper describes a programming model where phases and modes can be intuitively specified by programmers or inferred by the compiler as type information. It demonstrates how a type-based approach to reasoning about phases and modes can help promote energy efficiency. The soundness of our type system and the invariants related to inter-phase and inter-mode interactions are rigorously proved. Energy Types is implemented as the core of a prototyped object-oriented language ET for smartphone programming. Preliminary studies show ET can lead to significant energy savings for Android Apps.
[Communication hardware, interfaces and storage, General programming languages, Language features, Data types and structures, Software notations and tools, Hardware, Software and its engineering]
Exploiting inter-sequence correlations for program behavior prediction
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Prediction of program dynamic behaviors is fundamental to program optimizations, resource management, and architecture reconfigurations. Most existing predictors are based on locality of program behaviors, subject to some inherent limitations. In this paper, we revisit the design philosophy and systematically explore a second source of clues: statistical correlations between the behavior sequences of different program entities. Concentrated on loops, it examines the correlations' existence, strength, and values in enhancing the design of program behavior predictors. It creates the first taxonomy of program behavior sequence patterns. It develops a new form of predictors, named sequence predictors, to effectively translate the correlations into large-scope, proactive predictions of program behavior sequences. It demonstrates the usefulness of the prediction in dynamic version selection and loop importance estimation, showing 19% average speedup on a number of real-world utility applications. By taking scope and timing of behavior prediction as the first-order design objectives, the new approach overcomes limitations of existing program behavior predictors, opening up many new opportunities for runtime optimizations at various layers of computing.
[Software notations and tools, Software and its engineering, Compilers]
k-Calling context profiling
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Calling context trees are one of the most fundamental data structures for representing the interprocedural control flow of a program, providing valuable information for program understanding and optimization. Nodes of a calling context tree associate performance metrics to whole distinct paths in the call graph starting from the root function. However, no explicit information is provided for detecting short hot sequences of activations, which may be a better optimization target in large modular programs where groups of related functions are reused in many different parts of the code. Furthermore, calling context trees can grow prohibitively large in some scenarios. Another classical approach, called edge profiling, collects performance metrics for caller-callee pairs in the call graph, allowing it to detect hot paths of fixed length one. We study a generalization of edge and context-sensitive profiles by introducing a novel data structure called k-calling context forest (k-CCF). Nodes in a k-CCF associate performance metrics to paths of length at most k that lead to each distinct routine of the program, providing edge profiles for k=1, full context-sensitive profiles for k equal to infinity, as well as any other intermediate point in the spectrum. We study the properties of the k-CCF both theoretically and experimentally on a large suite of prominent Linux applications, showing how to construct it efficiently and discussing its relationships with the calling context tree. Our experiments show that the k-CCF can provide effective space-accuracy tradeoffs for interprocedural contextual profiling, yielding useful clues to the hot spots of a program that may be hidden in a calling context tree and using less space for small values of k, which appear to be the most interesting in practice.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software notations and tools, Development frameworks and environments, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
Reim & ReImInfer: checking and inference of reference immutability and method purity
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Reference immutability ensures that a reference is not used to modify the referenced object, and enables the safe sharing of object structures. A pure method does not cause side-effects on the objects that existed in the pre-state of the method execution. Checking and inference of reference immutability and method purity enables a variety of program analyses and optimizations. We present ReIm, a type system for reference immutability, and ReImInfer, a corresponding type inference analysis. The type system is concise and context-sensitive. The type inference analysis is precise and scalable, and requires no manual annotations. In addition, we present a novel application of the reference immutability type system: method purity inference. To support our theoretical results, we implemented the type system and the type inference analysis for Java. We include a type checker to verify the correctness of the inference result. Empirical results on Java applications and libraries of up to 348kLOC show that our approach achieves both scalability and precision.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
White box sampling in uncertain data processing enabled by program analysis
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Sampling is a very important and low-cost approach to uncertain data processing, in which output variations caused by input errors are sampled. Traditional methods tend to treat a program as a blackbox. In this paper, we show that through program analysis, we can expose the internals of sample executions so that the process can become more selective and focused. In particular, we develop a sampling runtime that can selectively sample in input error bounds to expose discontinuity in output functions. It identifies all the program factors that can potentially lead to discontinuity and hash the values of such factors during execution in a cost-effective way. The hash values are used to guide the sampling process. Our results show that the technique is very effective for real-world programs. It can achieve the precision of a high sampling rate with the cost of a lower sampling rate.
[Theory of computation, Software defect analysis, Software creation and management, Semantics and reasoning, Software testing and debugging, Software verification and validation, Program semantics, Program reasoning, Program analysis, Software and its engineering]
Detecting problematic message sequences and frequencies in distributed systems
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Testing the components of a distributed system is challenging as it requires consideration of not just the state of a component, but also the sequence of messages it may receive from the rest of the system or the environment. Such messages may vary in type and content, and more particularly, in the frequency at which they are generated. All of these factors, in the right combination, may lead to faulty behavior. In this paper we present an approach to address these challenges by systematically analyzing a component in a distributed system to identify specific message sequences and frequencies at which a failure can occur. At the core of the analysis is the generation of a test driver that defines the space of message sequences to be generated, the exploration of that space through the use of dynamic symbolic execution, and the timing and analysis of the generated tests to identify problematic frequencies. We implemented our approach in the context of the popular Robotic Operating System and investigated its application to three systems of increasing complexity.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software verification and validation, Software functional properties, Verification, Software verification, Program verification, Theory of computation, Software development process management, Software testing and debugging, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Reusing debugging knowledge via trace-based bug search
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Some bugs, among the millions that exist, are similar to each other. One bug-fixing tactic is to search for similar bugs that have been reported and resolved in the past. A fix for a similar bug can help a developer understand a bug, or even directly fix it. Studying bugs with similar symptoms, programmers may determine how to detect or resolve them. To speed debugging, we advocate the systematic capture and reuse of debugging knowledge, much of which is currently wasted. The core challenge here is how to search for similar bugs. To tackle this problem, we exploit semantic bug information in the form of execution traces, which precisely capture bug semantics. This paper introduces novel tool and language support for semantically querying and analyzing bugs. We describe OSCILLOSCOPE, an Eclipse plugin, that uses a bug trace to exhaustively search its database for similar bugs and return their bug reports. OSCILLOSCOPE displays the traces of the bugs it returns against the trace of the target bug, so a developer can visually examine the quality of the matches. OSCILLOSCOPE rests on our bug query language (BQL), a flexible query language over traces. To realize OSCILLOSCOPE, we developed an open infrastructure that consists of a trace collection engine, BQL, a Hadoop-based query engine for BQL, a trace-indexed bug database, as well as a web-based frontend. OSCILLOSCOPE records and uploads bug traces to its infrastructure; it does so automatically when a JUnit test fails. We evaluated OSCILLOSCOPE on bugs collected from popular open-source projects. We show that OSCILLOSCOPE accurately and efficiently finds similar bugs, some of which could have been immediately used to fix open bugs.
[Software design techniques, Software defect analysis, Software creation and management, Software verification and validation, Software notations and tools, Formal languages and automata theory, Software implementation planning, Theory of computation, Designing software, Software development process management, Software testing and debugging, Formal language definitions, Software and its engineering]
Chaperones and impersonators: run-time support for reasonable interposition
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Chaperones and impersonators provide run-time support for interposing on primitive operations such as function calls, array access and update, and structure field access and update. Unlike most interposition support, chaperones and impersonators are restricted so that they constrain the behavior of the interposing code to reasonable interposition, which in practice preserves the abstraction mechanisms and reasoning that programmers and compiler analyses rely on. Chaperones and impersonators are particularly useful for implementing contracts, and our implementation in Racket allows us to improve both the expressiveness and the performance of Racket's contract system. Specifically, contracts on mutable data can be enforced without changing the API to that data; contracts on large data structures can be checked lazily on only the accessed parts of the structure; contracts on objects and classes can be implemented with lower overhead; and contract wrappers can preserve object equality where appropriate. With this extension, gradual typing systems, such as Typed Racket, that rely on contracts for interoperation with untyped code can now pass mutable values safely between typed and untyped modules.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Open and efficient type switch for C++
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Selecting operations based on the run-time type of an object is key to many object-oriented and functional programming techniques. We present a technique for implementing open and efficient type switching on hierarchical extensible data types. The technique is general and copes well with C++ multiple inheritance. To simplify experimentation and gain realistic performance using production-quality compilers and tool chains, we implement a type switch construct as an ISO C++11 library, called Mach7. This library-only implementation provides concise notation and outperforms the visitor design pattern, commonly used for case analysis on types in object-oriented programming. For closed sets of types, its performance roughly equals equivalent code in functional languages, such as OCaml and Haskell. The type-switching code is easier to use and is more expressive than hand-coded visitors are. The library is non-intrusive and circumvents most of the extensibility restrictions typical of the visitor design pattern. It was motivated by applications involving large, typed, abstract syntax trees.
[General programming languages, Object oriented languages, Language features, Language types, Software notations and tools, Software and its engineering]
Understanding the behavior of database operations under program control
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
Applications that combine general program logic with persistent databases (e.g., three-tier applications) often suffer large performance penalties from poor use of the database. We introduce a program analysis technique that combines information flow in the program with commutativity analysis of its database operations to produce a unified dependency graph for database statements, which provides programmers with a high-level view of how costly database operations are and how they are connected in the program. As an example application of our analysis we describe three optimizations that can be discovered by examining the structure of the dependency graph; each helps remove communication latency from the critical path of a multi-tier system. We implement our technique in a tool for Java applications using JDBC and experimentally validate it using the multi-tier component of the Dacapo benchmark.
[General programming languages, Object oriented languages, Language types, Software notations and tools, Software and its engineering]
Typestate-based semantic code search over partial programs
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
We present a novel code search approach for answering queries focused on API-usage with code showing how the API should be used. To construct a search index, we develop new techniques for statically mining and consolidating temporal API specifications from code snippets. In contrast to existing semantic-based techniques, our approach handles partial programs in the form of code snippets. Handling snippets allows us to consume code from various sources such as parts of open source projects, educational resources (e.g. tutorials), and expert code sites. To handle code snippets, our approach (i) extracts a possibly partial temporal specification from each snippet using a relatively precise static analysis tracking a generalized notion of typestate, and (ii) consolidates the partial temporal specifications, combining consistent partial information to yield consolidated temporal specifications, each of which captures a full(er) usage scenario. To answer a search query, we define a notion of relaxed inclusion matching a query against temporal specifications and their corresponding code snippets. We have implemented our approach in a tool called PRIME and applied it to search for API usage of several challenging APIs. PRIME was able to analyze and consolidate thousands of snippets per tested API, and our results indicate that the combination of a relatively precise analysis and consolidation allowed PRIME to answer challenging queries effectively.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Designing software, Requirements analysis, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Finding reusable data structures
Proceedings of the ACM international conference on Object oriented programming systems languages and applications
ACM SIGPLAN Notices VOLUME 47 ISSUE 10
2012
A big source of run-time performance problems in large-scale, object-oriented applications is the frequent creation of data structures (by the same allocation site) whose lifetimes are disjoint, and whose shapes and data content are always the same. Constructing these data structures and computing the same data values many times is expensive; significant performance improvements can be achieved by reusing their instances, shapes, and/or data values rather than reconstructing them. This paper presents a run-time technique that can be used to help programmers find allocation sites that create such data structures to improve performance. At the heart of the technique are three reusability definitions and novel summarization approaches that compute summaries for data structures based on these definitions. The computed summaries are used subsequently to find data structures that have disjoint lifetimes, and/or that have the same shapes and content. We have implemented this technique in the Jikes RVM and performed extensive studies on large-scale, real-world programs. We describe our experience using six case studies, in which we have achieved large performance gains by fixing problems reported by our tool.
[Garbage collection, Software notations and tools, Program analysis, Runtime environments, Contextual software domains, Theory of computation, Semantics and reasoning, Operating systems, Memory management, Program semantics, Program reasoning, Software organization and properties, Software and its engineering, Compilers]
Steering symbolic execution to less traveled paths
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Symbolic execution is a promising testing and analysis methodology. It systematically explores a program's execution space and can generate test cases with high coverage. One significant practical challenge for symbolic execution is how to effectively explore the enormous number of program paths in real-world programs. Various heuristics have been proposed for guiding symbolic execution, but they are generally inefficient and ad-hoc. In this paper, we introduce a novel, unified strategy to guide symbolic execution to less explored parts of a program. Our key idea is to exploit a specific type of path spectra, namely the length-n subpath program spectra, to systematically approximate full path information for guiding path exploration. In particular, we use frequency distributions of explored length-n subpaths to prioritize "less traveled" parts of the program to improve test coverage and error detection. We have implemented our general strategy in KLEE, a state-of-the-art symbolic execution engine. Evaluation results on the GNU Coreutils programs show that (1) varying the length n captures program-specific information and exhibits different degrees of effectiveness, and (2) our general approach outperforms traditional strategies in both coverage and error detection.
[Validation, Cross-computing tools and techniques, Software creation and management, Empirical software validation, Abstract machines, Software verification and validation, Computing methodologies, Symbolic and algebraic manipulation, Extra-functional properties, Software reliability, Abstraction, Theory of computation, Models of computation, Semantics and reasoning, Process validation, Program reasoning, Reliability, General and reference, Software organization and properties, Software and its engineering]
Verifying quantitative reliability for programs that execute on unreliable hardware
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Emerging high-performance architectures are anticipated to contain unreliable components that may exhibit soft errors, which silently corrupt the results of computations. Full detection and masking of soft errors is challenging, expensive, and, for some applications, unnecessary. For example, approximate computing applications (such as multimedia processing, machine learning, and big data analytics) can often naturally tolerate soft errors. We present Rely a programming language that enables developers to reason about the quantitative reliability of an application -- namely, the probability that it produces the correct result when executed on unreliable hardware. Rely allows developers to specify the reliability requirements for each value that a function produces. We present a static quantitative reliability analysis that verifies quantitative requirements on the reliability of an application, enabling a developer to perform sound and verified reliability engineering. The analysis takes a Rely program with a reliability specification and a hardware specification that characterizes the reliability of the underlying hardware components and verifies that the program satisfies its reliability specification when executed on the underlying unreliable hardware platform. We demonstrate the application of quantitative reliability analysis on six computations implemented in Rely.
[Theory of computation, Semantics and reasoning, Pre- and post-conditions, Program specifications, Programming logic, Program reasoning, Logic, Program verification]
Efficient context sensitivity for dynamic analyses via calling context uptrees and customized memory management
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
State-of-the-art dynamic bug detectors such as data race and memory leak detectors report program locations that are likely causes of bugs. However, programmers need more than static program locations to understand the behavior of increasingly complex and concurrent software. Dynamic calling context provides additional information, but it is expensive to record calling context frequently, e.g., at every read and write. Context-sensitive dynamic analyses can build and maintain a calling context tree (CCT) to track calling context--but in order to reuse existing nodes, CCT-based approaches require an expensive lookup. This paper introduces a new approach for context sensitivity that avoids this expensive lookup. The approach uses a new data structure called the calling context uptree (CCU) that adds low overhead by avoiding the lookup and instead allocating a new node for each context. A key contribution is that the approach can mitigate the costs of allocating many nodes by extending tracing garbage collection (GC): GC collects unused CCU nodes naturally and efficiently, and we extend GC to merge duplicate nodes lazily. We implement our CCU-based approach in a high-performance Java virtual machine and integrate it with a staleness-based memory leak detector and happens-before data race detector, so they can report context-sensitive program locations that cause bugs. We show that the CCU-based approach, in concert with an extended GC, provides a compelling alternative to CCT-based approaches for adding context sensitivity to dynamic analyses.
[Garbage collection, Software defect analysis, Software creation and management, Software verification and validation, Software notations and tools, Runtime environments, Contextual software domains, Software testing and debugging, Operating systems, Memory management, Software organization and properties, Software and its engineering, Compilers]
Miniboxing: improving the speed to code size tradeoff in parametric polymorphism translations
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Parametric polymorphism enables code reuse and type safety. Underneath the uniform interface exposed to programmers, however, its low level implementation has to cope with inherently non-uniform data: value types of different sizes and semantics (bytes, integers, floating point numbers) and reference types (pointers to heap objects). On the Java Virtual Machine, parametric polymorphism is currently translated to bytecode using two competing approaches: homogeneous and heterogeneous. Homogeneous translation requires boxing, and thus introduces indirect access delays. Heterogeneous translation duplicates and adapts code for each value type individually, producing more bytecode. Therefore bytecode speed and size are at odds with each other. This paper proposes a novel translation that significantly reduces the bytecode size without affecting the execution speed. The key insight is that larger value types (such as integers) can hold smaller ones (such as bytes) thus reducing the duplication necessary in heterogeneous translations. In our implementation, on the Scala compiler, we encode all primitive value types in long integers. The resulting bytecode approaches the performance of monomorphic code, matches the performance of the heterogeneous translation and obtains speedups of up to 22x over the homogeneous translation, all with modest increases in size.
[Information storage systems, General programming languages, Language features, Record storage alternatives, Software notations and tools, Record storage systems, Software and its engineering, Polymorphism, Information systems]
Taking off the gloves with reference counting Immix
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Despite some clear advantages and recent advances, reference counting remains a poor cousin to high-performance tracing garbage collectors. The advantages of reference counting include a) immediacy of reclamation, b) incrementality, and c) local scope of its operations. After decades of languishing with hopelessly bad performance, recent work narrowed the gap between reference counting and the fastest tracing collectors to within 10%. Though a major advance, this gap remains a substantial barrier to adoption in performance-conscious application domains.  Our work identifies heap organization as the principal source of the remaining performance gap. We present the design, implementation, and analysis of a new collector, RC Immix, that replaces reference counting's traditional free-list heap organization with the line and block heap structure introduced by the Immix collector. The key innovations of RC Immix are 1) to combine traditional reference counts with per-line live object counts to identify reusable memory and 2) to eliminate fragmentation by integrating copying with reference counting of new objects and with backup tracing cycle collection. In RC Immix, reference counting offers efficient collection and the line and block heap organization delivers excellent mutator locality and efficient allocation. With these advances, RC Immix closes the 10% performance gap, matching the performance of a highly tuned production generational collector. By removing the performance barrier, this work transforms reference counting into a serious alternative for meeting high performance objectives for garbage collected languages.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Resurrector: a tunable object lifetime profiling technique for optimizing real-world programs
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Modern object-oriented applications commonly suffer from severe performance problems that need to be optimized away for increased efficiency and user satisfaction. Many existing optimization techniques (such as object pooling and pretenuring) require precise identification of object lifetimes. However, it is particularly challenging to obtain object lifetimes both precisely and efficiently: precise profiling techniques such as Merlin introduce several hundred times slowdown even for small programs while efficient approximation techniques often sacrifice precision and produce less useful lifetime information. This paper presents a tunable profiling technique, called Resurrector, that explores the middle ground between high precision and high efficiency to find the precision-efficiency sweetspot for various livenessbased optimization techniques. Our evaluation shows that Resurrector is both more precise and more efficient than the GC-based approximation, and it is orders-of-magnitude faster than Merlin. To demonstrate Resurrector's usefulness, we have developed client analyses to find allocation sites that create large data structures with disjoint lifetimes. By inspecting program source code and reusing data structures created from these allocation sites, we have achieved significant performance gains. We have also improved the precision of an existing optimization technique using the lifetime information collected by Resurrector.
[Garbage collection, Software notations and tools, Program analysis, Runtime environments, Contextual software domains, Theory of computation, Semantics and reasoning, Operating systems, Memory management, Program semantics, Program reasoning, Software organization and properties, Software and its engineering, Compilers]
CDSchecker: checking concurrent data structures written with C/C++ atomics
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Writing low-level concurrent software has traditionally required intimate knowledge of the entire toolchain and often has involved coding in assembly. New language standards have extended C and C++ with support for low-level atomic operations and a weak memory model, enabling developers to write portable and efficient multithreaded code. Developing correct low-level concurrent code is well-known to be especially difficult under a weak memory model, where code behavior can be surprising. Building reliable concurrent software using C/C++ low-level atomic operations will likely require tools that help developers discover unexpected program behaviors. In this paper we present CDSChecker, a tool for exhaustively exploring the behaviors of concurrent code under the C/C++ memory model. We develop several novel techniques for modeling the relaxed behaviors allowed by the memory model and for minimizing the number of execution behaviors that CDSChecker must explore. We have used CDSChecker to exhaustively unit test several concurrent data structure implementations on specific inputs and have discovered errors in both a recently published C11 implementation of a work-stealing queue and a single producer, single consumer queue implementation.
[Theory of computation, Verification by model checking, Semantics and reasoning, Software functional properties, Model checking, Program reasoning, Logic, Formal methods, Software organization and properties, Program verification, Software and its engineering]
Effective race detection for event-driven programs
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Like shared-memory multi-threaded programs, event-driven programs such as client-side web applications are susceptible to data races that are hard to reproduce and debug. Race detection for such programs is hampered by their pervasive use of ad hoc synchronization, which can lead to a prohibitive number of false positives. Race detection also faces a scalability challenge, as a large number of short-running event handlers can quickly overwhelm standard vector-clock-based techniques. This paper presents several novel contributions that address both of these challenges. First, we introduce race coverage, a systematic method for exposing ad hoc synchronization and other (potentially harmful) races to the user, significantly reducing false positives. Second, we present an efficient connectivity algorithm for computing race coverage. The algorithm is based on chain decomposition and leverages the structure of event-driven programs to dramatically decrease the overhead of vector clocks. We implemented our techniques in a tool called EventRacer and evaluated it on a number of public web sites. The results indicate substantial performance and precision improvements of our approach over the state-of-the-art. Using EventRacer, we found many harmful races, most of which are beyond the reach of current techniques.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Storage strategies for collections in dynamically typed languages
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Dynamically typed language implementations often use more memory and execute slower than their statically typed cousins, in part because operations on collections of elements are unoptimised. This paper describes storage strategies, which dynamically optimise collections whose elements are instances of the same primitive type. We implement storage strategies in the PyPy virtual machine, giving a performance increase of 18% on wide-ranging benchmarks of real Python programs. We show that storage strategies are simple to implement, needing only 1500LoC in PyPy, and have applicability to a wide range of virtual machines.
[Source code generation, Interpreters, Software notations and tools, Runtime environments, Incremental compilers, Software and its engineering, Compilers]
Instant pickles: generating object-oriented pickler combinators for fast and extensible serialization
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
As more applications migrate to the cloud, and as "big data" edges into even more production environments, the performance and simplicity of exchanging data between compute nodes/devices is increasing in importance. An issue central to distributed programming, yet often under-considered, is serialization or pickling, i.e., persisting runtime objects by converting them into a binary or text representation. Pickler combinators are a popular approach from functional programming; their composability alleviates some of the tedium of writing pickling code by hand, but they don't translate well to object-oriented programming due to qualities like open class hierarchies and subtyping polymorphism. Furthermore, both functional pickler combinators and popular, Java-based serialization frameworks tend to be tied to a specific pickle format, leaving programmers with no choice of how their data is persisted. In this paper, we present object-oriented pickler combinators and a framework for generating them at compile-time, called scala/pickling, designed to be the default serialization mechanism of the Scala programming language. The static generation of OO picklers enables significant performance improvements, outperforming Java and Kryo in most of our benchmarks. In addition to high performance and the need for little to no boilerplate, our framework is extensible: using the type class pattern, users can provide both (1) custom, easily interchangeable pickle formats and (2) custom picklers, to override the default behavior of the pickling framework. In benchmarks, we compare scala/pickling with other popular industrial frameworks, and present results on time, memory usage, and size when pickling/unpickling a number of data types used in real-world, large-scale distributed applications and frameworks.
[Communications management, Object oriented languages, Input / output, Multiparadigm languages, Language types, Software notations and tools, Contextual software domains, Operating systems, General programming languages, Functional languages, Software organization and properties, Software and its engineering]
Interacting with dead objects
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Debugging and analyzing a snapshot of a crashed program's memory is far more difficult than working with a live program, because debuggers can no longer execute code to help make sense of the program state. We present an architecture that supports the restricted execution of ordinary code starting from the snapshot, as if the dead objects within it had been restored, but without access to their original external environment. We demonstrate the feasibility of this approach via an implementation for Java that does not require a custom virtual machine, show that it performs competitively with live execution, and use it to diagnose an unresolved memory leak in a mature mainstream application.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Python: the full monty
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We present a small-step operational semantics for the Python programming language. We present both a core language for Python, suitable for tools and proofs, and a translation process for converting Python source to this core. We have tested the composition of translation and evaluation of the core for conformance with the primary Python implementation, thereby giving confidence in the fidelity of the semantics. We briefly report on the engineering of these components. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern that even impacts features that might be considered orthogonal.
[Applied computing, Life and medical sciences, Systems biology, Genetics, Computational biology]
Forsaking inheritance: supercharged delegation in DelphJ
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We propose DelphJ: a Java-based OO language that eschews inheritance completely, in favor of a combination of class morphing and (deep) delegation. Compared to past delegation approaches, the novel aspect of our design is the ability to emulate the best aspects of inheritance while retaining maximum flexibility: using morphing, a class can select any of the methods of its delegatee and export them (if desired) or transform them (e.g., to add extra arguments or modify type signatures), yet without needing to name these methods explicitly and handle them one-by-one. Compared to past work on morphing, our approach adopts and adapts advanced delegation mechanisms, in order to add late binding capabilities and, thus, provide a full substitute of inheritance. Additionally, we explore complex semantic issues in the interaction of delegation with late binding. We present our language design both informally, with numerous examples, and formally in a core calculus.
[]
Set-based pre-processing for points-to analysis
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We present set-based pre-analysis: a virtually universal optimization technique for flow-insensitive points-to analysis. Points-to analysis computes a static abstraction of how object values flow through a program's variables. Set-based pre-analysis relies on the observation that much of this reasoning can take place at the set level rather than the value level. Computing constraints at the set level results in significant optimization opportunities: we can rewrite the input program into a simplified form with the same essential points-to properties. This rewrite results in removing both local variables and instructions, thus simplifying the subsequent value-based points-to computation. Effectively, set-based pre-analysis puts the program in a normal form optimized for points-to analysis.  Compared to other techniques for off-line optimization of points-to analyses in the literature, the new elements of our approach are the ability to eliminate statements, and not just variables, as well as its modularity: set-based pre-analysis can be performed on the input just once, e.g., allowing the pre-optimization of libraries that are subsequently reused many times and for different analyses. In experiments with Java programs, set-based pre-analysis eliminates 30% of the program's local variables and 30% or more of computed context-sensitive points-to facts, over a wide set of benchmarks and analyses, resulting in a ~20% average speedup (max: 110%, median: 18%).
[Theory of computation, Semantics and reasoning, Program semantics, Software notations and tools, Program reasoning, Program analysis, Software and its engineering, Compilers]
MrCrypt: static analysis for secure cloud computations
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
In a common use case for cloud computing, clients upload data and computation to servers that are managed by a third-party infrastructure provider. We describe MrCrypt, a system that provides data confidentiality in this setting by executing client computations on encrypted data. MrCrypt statically analyzes a program to identify the set of operations on each input data column, in order to select an appropriate homomorphic encryption scheme for that column, and then transforms the program to operate over encrypted data. The encrypted data and transformed program are uploaded to the server and executed as usual, and the result of the computation is decrypted on the client side. We have implemented MrCrypt for Java and illustrate its practicality on three standard benchmark suites for the Hadoop MapReduce framework. We have also formalized the approach and proven several soundness and security guarantees.
[Theory of computation, Software creation and management, Software post-development issues, Formal language definitions, Software notations and tools, Software reverse engineering, Formal languages and automata theory, Software and its engineering]
Ironclad C++: a library-augmented type-safe subset of c++
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
The C++ programming language remains widely used, despite inheriting many unsafe features from C---features that often lead to failures of type or memory safety that manifest as buffer overflows, use-after-free vulnerabilities, or abstraction violations. Malicious attackers can exploit such violations to compromise application and system security. This paper introduces Ironclad C++, an approach to bringing the benefits of type and memory safety to C++. Ironclad C++ is, in essence, a library-augmented, type-safe subset of C++. All Ironclad C++ programs are valid C++ programs that can be compiled using standard, off-the-shelf C++ compilers. However, not all valid C++ programs are valid Ironclad C++ programs: a syntactic source-code validator statically prevents the use of unsafe C++ features. To enforce safety properties that are difficult to check statically, Ironclad C++ applies dynamic checks via templated ``smart pointer'' classes. Using a semi-automatic refactoring tool, we have ported nearly 50K lines of code to Ironclad C++. These benchmarks incur a performance overhead of 12% on average, compared to the original unsafe C++ code.
[Dynamic compilers, Operating systems, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Flexible access control for javascript
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Providing security guarantees for systems built out of untrusted components requires the ability to define and enforce access control policies over untrusted code. In Web 2.0 applications, JavaScript code from different origins is often combined on a single page, leading to well-known vulnerabilities. We present a security infrastructure which allows users and content providers to specify access control policies over subsets of a JavaScript program by leveraging the concept of delimited histories with revocation. We implement our proposal in WebKit and evaluate it with three policies on 50 widely used websites with no changes to their JavaScript code and report performance overheads and violations.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Semi-automatic rename refactoring for JavaScript
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Modern IDEs support automated refactoring for many programming languages, but support for JavaScript is still primitive. To perform renaming, which is one of the fundamental refactorings, there is often no practical alternative to simple syntactic search-and-replace. Although more sophisticated alternatives have been developed, they are limited by whole-program assumptions and poor scalability. We propose a technique for semi-automatic refactoring for JavaScript, with a focus on renaming. Unlike traditional refactoring algorithms, semi-automatic refactoring works by a combination of static analysis and interaction with the programmer. With this pragmatic approach, we can provide scalable and effective refactoring support for real-world code, including libraries and incomplete applications. Through a series of experiments that estimate how much manual effort our technique demands from the programmer, we show that our approach is a useful improvement compared to search-and-replace tools.
[Software creation and management, Software post-development issues, Software reverse engineering, Software and its engineering]
Refactoring with synthesis
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Refactoring has become an integral part of modern software development, with wide support in popular integrated development environments (IDEs). Modern IDEs provide a fixed set of supported refactorings, listed in a refactoring menu. But with IDEs supporting more and more refactorings, it is becoming increasingly difficult for programmers to discover and memorize all their names and meanings. Also, since the set of refactorings is hard-coded, if a programmer wants to achieve a slightly different code transformation, she has to either apply a (possibly non-obvious) sequence of several built-in refactorings, or just perform the transformation by hand. We propose a novel approach to refactoring, based on synthesis from examples, which addresses these limitations. With our system, the programmer need not worry how to invoke individual refactorings or the order in which to apply them. Instead, a transformation is achieved via three simple steps: the programmer first indicates the start of a code refactoring phase; then she performs some of the desired code changes manually; and finally, she asks the tool to complete the refactoring. Our system completes the refactoring by first extracting the difference between the starting program and the modified version, and then synthesizing a sequence of refactorings that achieves (at least) the desired changes. To enable scalable synthesis, we introduce local refactorings, which allow for first discovering a refactoring sequence on small program fragments and then extrapolating it to a full refactoring sequence. We implemented our approach as an Eclipse plug-in, with an architecture that is easily extendable with new refactorings. The experimental results are encouraging: with only minimal user input, the synthesizer was able to quickly discover complex refactoring sequences for several challenging realistic examples.
[Integrated and visual development environments, Software notations and tools, Development frameworks and environments, Software and its engineering]
Bottle graphs: visualizing scalability bottlenecks in multi-threaded applications
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Understanding and analyzing multi-threaded program performance and scalability is far from trivial, which severely complicates parallel software development and optimization. In this paper, we present bottle graphs, a powerful analysis tool that visualizes multi-threaded program performance, in regards to both per-thread parallelism and execution time. Each thread is represented as a box, with its height equal to the share of that thread in the total program execution time, its width equal to its parallelism, and its area equal to its total running time. The boxes of all threads are stacked upon each other, leading to a stack with height equal to the total program execution time. Bottle graphs show exactly how scalable each thread is, and thus guide optimization towards those threads that have a smaller parallel component (narrower), and a larger share of the total execution time (taller), i.e. to the 'neck' of the bottle. Using light-weight OS modules, we calculate bottle graphs for unmodified multi-threaded programs running on real processors with an average overhead of 0.68%. To demonstrate their utility, we do an extensive analysis of 12 Java benchmarks running on top of the Jikes JVM, which introduces many JVM service threads. We not only reveal and explain scalability limitations of several well-known Java benchmarks; we also analyze the reasons why the garbage collector itself does not scale, and in fact performs optimally with two collector threads for all benchmarks, regardless of the number of application threads. Finally, we compare the scalability of Jikes versus the OpenJDK JVM. We demonstrate how useful and intuitive bottle graphs are as a tool to analyze scalability and help optimize multi-threaded applications.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
Ball-Larus path profiling across multiple loop iterations
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Identifying the hottest paths in the control flow graph of a routine can direct optimizations to portions of the code where most resources are consumed. This powerful methodology, called path profiling, was introduced by Ball and Larus in the mid 90's [4] and has received considerable attention in the last 15 years for its practical relevance. A shortcoming of the Ball-Larus technique was the inability to profile cyclic paths, making it difficult to mine execution patterns that span multiple loop iterations. Previous results, based on rather complex algorithms, have attempted to circumvent this limitation at the price of significant performance losses even for a small number of iterations. In this paper, we present a new approach to multi-iteration path profiling, based on data structures built on top of the original Ball-Larus numbering technique. Our approach allows the profiling of all executed paths obtained as a concatenation of up to k Ball-Larus acyclic paths, where k is a user-defined parameter. We provide examples showing that this method can reveal optimization opportunities that acyclic-path profiling would miss. An extensive experimental investigation on a large variety of Java benchmarks on the Jikes RVM shows that our approach can be even faster than Ball-Larus due to fewer operations on smaller hash tables, producing compact representations of cyclic paths even for large values of k.
[Measurement, Traceability, Cross-computing tools and techniques, Metrics, Software creation and management, Software verification and validation, Process validation, Software notations and tools, General and reference, Development frameworks and environments, Software and its engineering]
Data-driven equivalence checking
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We present a data driven algorithm for equivalence checking of two loops. The algorithm infers simulation relations using data from test runs. Once a candidate simulation relation has been obtained, off-the-shelf SMT solvers are used to check whether the simulation relation actually holds. The algorithm is sound: insufficient data will cause the proof to fail. We demonstrate a prototype implementation, called DDEC, of our algorithm, which is the first sound equivalence checker for loops written in x86 assembly.
[Theory of computation, Software functional properties, Software notations and tools, Proof theory, Logic, Correctness, Software organization and properties, Software and its engineering, Compilers]
Synthesis modulo recursive functions
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We describe techniques for synthesis and verification of recursive functional programs over unbounded domains. Our techniques build on top of an algorithm for satisfiability modulo recursive functions, a framework for deductive synthesis, and complete synthesis procedures for algebraic data types. We present new counterexample-guided algorithms for constructing verified programs. We have implemented these algorithms in an integrated environment for interactive verification and synthesis from relational specifications. Our system was able to synthesize a number of useful recursive functions that manipulate unbounded numbers and data structures.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Logic, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Code optimizations using formally verified properties
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Formal program verification offers strong assurance of correctness, backed by the strength of mathematical proof. Constructing these proofs requires humans to identify program invariants, and show that they are always maintained. These invariants are then used to prove that the code adheres to its specification. In this paper, we explore the overlap between formal verification and code optimization. We propose two approaches to reuse the invariants derived in formal proofs and integrate them into compilation. The first applies invariants extracted from the proof, while the second leverages the property of program safety (i.e., the absence of bugs). We reuse this information to improve the performance of generated object code. We evaluated these methods on seL4, a real-world formally-verified microkernel, and obtained improvements in average runtime performance (up to 28%) and in worst-case execution time (up to 25%). In macro-benchmarks, we found the performance of para-virtualized Linux running on the microkernel improved by 6-16%.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Software performance, Extra-functional properties, Software notations and tools, Formal software verification, Formal methods, Performance, General and reference, Software organization and properties, Software and its engineering, Compilers]
Inductive invariant generation via abductive inference
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
This paper presents a new method for generating inductive loop invariants that are expressible as boolean combinations of linear integer constraints. The key idea underlying our technique is to perform a backtracking search that combines Hoare-style verification condition generation with a logical abduction procedure based on quantifier elimination to speculate candidate invariants. Starting with true, our method iteratively strengthens loop invariants until they are inductive and strong enough to verify the program. A key feature of our technique is that it is lazy: It only infers those invariants that are necessary for verifying program correctness. Furthermore, our technique can infer arbitrary boolean combinations (including disjunctions) of linear invariants. We have implemented the proposed approach in a tool called HOLA. Our experiments demonstrate that HOLA can infer interesting invariants that are beyond the reach of existing state-of-the-art invariant generation tools.
[Theory of computation, Semantics and reasoning, Program reasoning, Logic]
Do developers benefit from generic types?: an empirical comparison of generic and raw types in java
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Type systems that permit developers to express themselves more precisely are one of the primary topics in programming language research, as well as in industrial software development. While it seems plausible that an expressive static type system increases developer productivity, there is little empirical evidence for or against this hypothesis. Generic types in Java are an example: as an extension of Java's original type system, some claim that Java 1.5 improves the type system's "expressiveness." Even if this claim is true, there exists little empirical evidence that claimed expressiveness leads to a measurable increase in developer productivity. This paper introduces an experiment where generic types (in comparison to raw types) have been evaluated in three different directions: (1) the documentation impact on undocumented APIs, (2) the time required for fixing type errors, and (3) the extensibility of a generic type hierarchy. The results of the experiment suggest that generic types improve documentation and reduce extensibility -- without revealing a difference in the time required for fixing type errors.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Option contracts
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Many languages support behavioral software contracts so that programmers can describe a component's obligations and promises via logical assertions in its interface. The contract system monitors program execution, checks whether the assertions hold, and, if not, blames the guilty component. Pinning down the violator gets the debugging process started in the right direction. Quality contracts impose a serious run-time cost, however, and programmers therefore compromise in many ways. Some turn off contracts for deployment, but then contracts and code quickly get out of sync during maintenance. Others test contracts randomly or probabilistically. In all cases, programmers have to cope with lack of blame information when the program eventually fails. In response, we propose option contracts as an addition to the contract tool box. Our key insight is that in ordinary contract systems, server components impose their contract on client components, giving them no choice whether to trust the server's promises or check them. With option contracts, server components may choose to tag a contract as an option and clients may choose to exercise the option or accept it, in which case they also shoulder some responsibility. We show that option contracts permit programmers to specify flexible checking policies, that their cost is reasonable, and that they satisfy a complete monitoring theorem.
[Validation, Cross-computing tools and techniques, Software creation and management, Software verification and validation, Reliability, General and reference, Software and its engineering]
Language support for dynamic, hierarchical data partitioning
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Applications written for distributed-memory parallel architectures must partition their data to enable parallel execution. As memory hierarchies become deeper, it is increasingly necessary that the data partitioning also be hierarchical to match. Current language proposals perform this hierarchical partitioning statically, which excludes many important applications where the appropriate partitioning is itself data dependent and so must be computed dynamically. We describe Legion, a region-based programming system, where each region may be partitioned into subregions. Partitions are computed dynamically and are fully programmable. The division of data need not be disjoint and subregions of a region may overlap, or alias one another. Computations use regions with certain privileges (e.g., expressing that a computation uses a region read-only) and data coherence (e.g., expressing that the computation need only be atomic with respect to other operations on the region), which can be controlled on a per-region (or subregion) basis. We present the novel aspects of the Legion design, in particular the combination of static and dynamic checks used to enforce soundness. We give an extended example illustrating how Legion can express computations with dynamically determined relationships between computations and data partitions. We prove the soundness of Legion's type system, and show Legion type checking improves performance by up to 71% by eliding provably safe memory checks. In particular, we show that the dynamic checks to detect aliasing at runtime at the region granularity have negligible overhead. We report results for three real-world applications running on distributed memory machines, achieving up to 62.5X speedup on 96 GPUs on the Keeneland supercomputer.
[Computing methodologies, Language types, Software notations and tools, Formal languages and automata theory, Theory of computation, Semantics and reasoning, General programming languages, Program semantics, Concurrent programming languages, Formal language definitions, Concurrent computing methodologies, Software and its engineering]
Class hierarchy complementation: soundly completing a partial type graph
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We present the problem of class hierarchy complementation: given a partially known hierarchy of classes together with subtyping constraints ("A has to be a transitive subtype of B") complete the hierarchy so that it satisfies all constraints. The problem has immediate practical application to the analysis of partial programs--e.g., it arises in the process of providing a sound handling of "phantom classes" in the Soot program analysis framework. We provide algorithms to solve the hierarchy complementation problem in the single inheritance and multiple inheritance settings. We also show that the problem in a language such as Java, with single inheritance but multiple subtyping and distinguished class vs. interface types, can be decomposed into separate single- and multiple-subtyping instances. We implement our algorithms in a tool, JPhantom, which complements partial Java bytecode programs so that the result is guaranteed to satisfy the Java verifier requirements. JPhantom is highly scalable and runs in mere seconds even for large input applications and complex constraints (with a maximum of 14s for a 19MB binary).
[Theory of computation, Semantics and reasoning, General programming languages, Object oriented languages, Program semantics, Language types, Software notations and tools, Program reasoning, Program analysis, Software and its engineering]
Multiverse: efficiently supporting distributed high-level speculation
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Algorithmic speculation or high-level speculation is a promising programming paradigm which allows programmers to speculatively branch an execution into multiple independent parallel sections and then choose the best (perhaps fastest) amongst them. The continuing execution after the speculatively branched section sees only the modifications made by the best one. This programming paradigm allows programmers to harness parallelism and can provide dramatic performance improvements. In this paper we present the Multiverse speculative programming model. Multiverse allows programmers to exploit parallelism through high-level speculation. It can effectively harness large amounts of parallelism by speculating across an entire cluster and is not bound by the parallelism available in a single machine. We present abstractions and a runtime which allow programmers to introduce large scale high-level speculative parallelism into applications with minimal effort. We introduce a novel on-demand address space sharing mechanism which provide speculations efficient transparent access to the original address space of the application (including the use of pointers) across machine boundaries. Multiverse provides single commit semantics across speculations while guaranteeing isolation between them. We also introduce novel mechanisms to deal with scalability bottlenecks when there are a large number of speculations. We demonstrate that for several benchmarks, Multiverse achieves impressive speedups and good scalability across entire clusters. We study the overheads of the runtime and demonstrate how our special scalability mechanisms are crucial in scaling cluster wide.
[Distributed programming languages, General programming languages, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Distributed computing methodologies, Software and its engineering]
Fully concurrent garbage collection of actors on many-core machines
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Disposal of dead actors in actor-model languages is as important as disposal of unreachable objects in object-oriented languages. In current practice, programmers are required to either manually terminate actors, or they have to rely on garbage collection systems that monitor actor mutation through write barriers, thread coordination through locks etc. These techniques, however, prevent the collector from being fully concurrent. We developed a protocol that allows garbage collection to run fully concurrently with all actors. The main challenges in concurrent garbage collection is the detection of cycles of sleeping actors in the actors graph, in the presence of concurrent mutation of this graph. Our protocol is solely built on message passing: it uses deferred direct reference counting, a dedicated actor for the detection of (cyclic) garbage, and a confirmation protocol (to deal with the mutation of the actor graph). We present our ideas informally through an example, and then present a formal model, prove soundness and argue completeness. We have implemented the protocol as part of a runtime library. As a preliminary performance evaluation, we discuss the performance of our approach as currently used at a financial institution, and use four benchmarks from the literature to compare our approach with other actor-model systems. These preliminary results indicate that the overhead of our approach is small.
[Garbage collection, Language types, Software notations and tools, Parallel programming languages, Contextual software domains, Distributed programming languages, Operating systems, General programming languages, Memory management, Concurrent programming languages, Software organization and properties, Software and its engineering]
Isolation for nested task parallelism
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Isolation--the property that a task can access shared data without interference from other tasks--is one of the most basic concerns in parallel programming. Whilethere is a large body of past work on isolated task-parallelism, the integration of isolation, task-parallelism, and nesting of tasks has been a difficult and unresolved challenge. In this pa- per, we present a programming and execution model called Otello where isolation is extended to arbitrarily nested parallel tasks with irregular accesses to heap data. At the same time, no additional burden is imposed on the programmer, who only exposes parallelism by creating and synchronizing parallel tasks, leaving the job of ensuring isolation to the underlying compiler and runtime system. Otello extends our past work on Aida execution model and the delegated isolation mechanism [22] to the setting of nested parallelism. The basic runtime construct in Aida and Otello is an assembly: a task equipped with a region in the shared heap that it owns. When an assembly A conflicts with an assembly B, A transfers--or delegates--its code and owned region to a carefully selected assembly C in a way that will ensure isolation with B, leaving the responsibility of re-executing task A to C. The choice of C depends on the nesting relationship between A and B.We have implemented Otello on top of the Habanero Java (HJ) parallel programming language [8], and used this implementation to evaluate Otello on collections of nested task-parallel benchmarks and non-nested transactional benchmarks from past work. On the nested task-parallel benchmarks, Otello achieves scalability comparable to HJ programs without built-in isolation, and the relative overhead of Otello is lower than that of many published data-race detection algorithms that detect the isolation violations (but do not enforce isolation). For the transactional benchmarks, Otello incurs lower overhead than a state-of-the-art software transactional memory system (Deuce STM).
[Distributed programming languages, General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Parallel programming languages, Software and its engineering]
Turning nondeterminism into parallelism
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Nondeterminism is a useful and prevalent concept in the design and implementation of software systems. An important property of nondeterminism is its latent parallelism: A nondeterministic action can evaluate to multiple behaviors. If at least one of these behaviors does not conflict with concurrent tasks, then there is an admissible execution of the action in parallel with these tasks. Unfortunately, existing implementations of the atomic paradigm - optimistic as well as pessimistic - are unable to fully exhaust the parallelism potential of nondeterministic actions, lacking the means to guide concurrent tasks toward nondeterministic choices that minimize interference. This paper investigates the problem of utilizing parallelism due to nondeterminism. We observe that nondeterminism occurs in many real-world codes. We motivate the need for devising coordination mechanisms that can utilize available nondeterminism. We have developed a system featuring such mechanisms, which leverages nondeterminism in a wide class of query operations, allowing a task to look into the future of concurrent tasks that mutate the shared state during query evaluation and reduce conflict accordingly. We evaluate our system on a suite of 12 algorithmic benchmarks of wide applicability, as well as an industrial application. The results are encouraging.
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
Barrier invariants: a shared state abstraction for the analysis of data-dependent GPU kernels
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Data-dependent GPU kernels, whose data or control flow are dependent on the input of the program, are difficult to verify because they require reasoning about shared state manipulated by many parallel threads. Existing verification techniques for GPU kernels achieve soundness and scalability by using a two-thread reduction and making the contents of the shared state nondeterministic each time threads synchronise at a barrier, to account for all possible thread interactions. This coarse abstraction prohibits verification of data-dependent kernels. We present barrier invariants, a novel abstraction technique which allows key properties about the shared state of a kernel to be preserved across barriers during formal reasoning. We have integrated barrier invariants with the GPUVerify tool, and present a detailed case study showing how they can be used to verify three prefix sum algorithms, allowing efficient modular verification of a stream compaction kernel, a key building block for GPU programming. This analysis goes significantly beyond what is possible using existing verification techniques for GPU kernels.
[Theory of computation, Semantics and reasoning, Program reasoning, Logic]
Guided GUI testing of android apps with minimal restart and approximate learning
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Smartphones and tablets with rich graphical user interfaces (GUI) are becoming increasingly popular. Hundreds of thousands of specialized applications, called apps, are available for such mobile platforms. Manual testing is the most popular technique for testing graphical user interfaces of such apps. Manual testing is often tedious and error-prone. In this paper, we propose an automated technique, called Swift-Hand, for generating sequences of test inputs for Android apps. The technique uses machine learning to learn a model of the app during testing, uses the learned model to generate user inputs that visit unexplored states of the app, and uses the execution of the app on the generated inputs to refine the model. A key feature of the testing algorithm is that it avoids restarting the app, which is a significantly more expensive operation than executing the app on a sequence of inputs. An important insight behind our testing algorithm is that we do not need to learn a precise model of an app, which is often computationally intensive, if our goal is to simply guide test execution into unexplored parts of the state space. We have implemented our testing algorithm in a publicly available tool for Android apps written in Java. Our experimental results show that we can achieve significantly better coverage than traditional random testing and L*-based testing in a given time budget. Our algorithm also reaches peak coverage faster than both random and L*-based testing.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Targeted and depth-first exploration for systematic testing of android apps
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Systematic exploration of Android apps is an enabler for a variety of app analysis and testing tasks. Performing the exploration while apps run on actual phones is essential for exploring the full range of app capabilities. However, exploring real-world apps on real phones is challenging due to non-determinism, non-standard control flow, scalability and overhead constraints. Relying on end-users to conduct the exploration might not be very effective: we performed a 7-use study on popular Android apps, and found that the combined 7-use coverage was 30.08% of the app screens and 6.46% of the app methods. Prior approaches for automated exploration of Android apps have run apps in an emulator or focused on small apps whose source code was available. To address these problems, we present A3E, an approach and tool that allows substantial Android apps to be explored systematically while running on actual phones, yet without requiring access to the app's source code. The key insight of our approach is to use a static, taint-style, dataflow analysis on the app bytecode in a novel way, to construct a high-level control flow graph that captures legal transitions among activities (app screens). We then use this graph to develop an exploration strategy named Targeted Exploration that permits fast, direct exploration of activities, including activities that would be difficult to reach during normal use. We also developed a strategy named Depth-first Exploration that mimics user actions for exploring activities and their constituents in a slower, but more systematic way. To measure the effectiveness of our techniques, we use two metrics: activity coverage (number of screens explored) and method coverage. Experiments with using our approach on 25 popular Android apps including BBC News, Gas Buddy, Amazon Mobile, YouTube, Shazam Encore, and CNN, show that our exploration techniques achieve 59.39--64.11% activity coverage and 29.53--36.46% method coverage.
[Software defect analysis, Validation, Cross-computing tools and techniques, Software creation and management, Empirical software validation, Software verification and validation, Extra-functional properties, Software reliability, Traceability, Software testing and debugging, Process validation, Reliability, General and reference, Software organization and properties, Software and its engineering]
The latency, accuracy, and battery (LAB) abstraction: programmer productivity and energy efficiency for continuous mobile context sensing
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Emerging mobile applications that sense context are poised to delight and entertain us with timely news and events, health tracking, and social connections. Unfortunately, sensing algorithms quickly drain the phone's battery. Developers can overcome battery drain by carefully optimizing context sensing but that makes programming with context arduous and ties applications to current sensing hardware. These types of applications embody a twist on the classic tension between programmer productivity and performance due to their combination of requirements. This paper identifies the latency, accuracy, battery (LAB) abstraction to resolve this tension. We implement and evaluate LAB in a system called Senergy. Developers specify their LAB requirements independent of inference algorithms and sensors. Senergy delivers energy efficient context while meeting the requirements and adapts as hardware changes. We demonstrate LAB's expressiveness by using it to implement 22 context sensing algorithms for four types of context (location, driving, walking, and stationary) and six diverse applications. To demonstrate LAB's energy optimizations, we show often an order of magnitude improvements in energy efficiency on applications compared to prior approaches. This relatively simple, priority based API, may serve as a blueprint for future API design in an increasingly complex design space that must tradeoff latency, accuracy, and efficiency to meet application needs and attain portability across evolving, sensor-rich, heterogeneous, and power constrained hardware.
[Information retrieval, Information systems, Evaluation of retrieval results]
Input-covering schedules for multithreaded programs
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We propose constraining multithreaded execution to small sets of input-covering schedules, which we define as follows: given a program P, we say that a set of schedules &#8721; covers all inputs of program P if, when given any input, P's execution can be constrained to some schedule in &#8721; and still produce a semantically valid result. Our approach is to first compute a small &#8721; for a given program P, and then, at runtime, constrain P's execution to always follow some schedule in &#8721;, and never deviate. We have designed an algorithm that uses symbolic execution to systematically enumerate a set of input-covering schedules, &#8721;. To deal with programs that run for an unbounded length of time, we partition execution into bounded epochs, find input-covering schedules for each epoch in isolation, and then piece the schedules together at runtime. We have implemented this algorithm along with a constrained execution runtime for pthreads programs, and we report results Our approach has the following advantage: because all possible runtime schedules are known a priori, we can seek to validate the program by thoroughly verifying each schedule in &#8721;, in isolation, without needing to reason about the huge space of thread interleavings that arises due to conventional nondeterministic execution.
[General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Runtime environments, Concurrent computing methodologies, Software and its engineering, Compilers]
OCTET: capturing and controlling cross-thread dependences efficiently
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Parallel programming is essential for reaping the benefits of parallel hardware, but it is notoriously difficult to develop and debug reliable, scalable software systems. One key challenge is that modern languages and systems provide poor support for ensuring concurrency correctness properties - atomicity, sequential consistency, and multithreaded determinism - because all existing approaches are impractical. Dynamic, software-based approaches slow programs by up to an order of magnitude because capturing and controlling cross-thread dependences (i.e., conflicting accesses to shared memory) requires synchronization at virtually every access to potentially shared memory. This paper introduces a new software-based concurrency control mechanism called OCTET that soundly captures cross-thread dependences and can be used to build dynamic analyses for concurrency correctness. OCTET achieves low overheads by tracking the locality state of each potentially shared object. Non-conflicting accesses conform to the locality state and require no synchronization; only conflicting accesses require a state change and heavyweight synchronization. This optimistic tradeoff leads to significant efficiency gains in capturing cross-thread dependences: a prototype implementation of OCTET in a high-performance Java virtual machine slows real-world concurrent programs by only 26% on average. A dependence recorder, suitable for record & replay, built on top of OCTET adds an additional 5% overhead on average. These results suggest that OCTET can provide a foundation for developing low-overhead analyses that check and enforce concurrency correctness.
[Software notations and tools, Runtime environments, Software and its engineering, Compilers]
Online feedback-directed optimizations for parallel Java code
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
The performance of parallel code significantly depends on the parallel task granularity (PTG). If the PTG is too coarse, performance suffers due to load imbalance; if the PTG is too fine, performance suffers from the overhead that is induced by parallel task creation and scheduling. This paper presents a software platform that automatically determines the PTG at run-time. Automatic PTG selection is enabled by concurrent calls, which are special source language constructs that provide a late decision (at run-time) of whether concurrent calls are executed sequentially or concurrently (as a parallel task). Furthermore, the execution semantics of concurrent calls permits the runtime system to merge two (or more) concurrent calls thereby coarsening the PTG. We present an integration of concurrent calls into the Java programming language, the Java Memory Model, and show how the Java Virtual Machine can adapt the PTG based on dynamic profiling. The performance evaluation shows that our runtime system performs competitively to Java programs for which the PTG is tuned manually. Compared to an unfortunate choice of the PTG, this approach performs up to 3x faster than standard Java code.
[Software notations and tools, Software and its engineering, Compilers]
River trail: a path to parallelism in JavaScript
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
JavaScript is the most popular language on the web and is a crucial component of HTML5 applications and services that run on consumer platforms ranging from desktops to phones. However, despite ample amount of hardware parallelism available to web applications on such platforms, JavaScript web applications remain predominantly sequential. Common parallel programming solutions accepted by other programming languages failed to transfer themselves to JavaScript due to differences in programming models, the additional requirements of the web and different developer expectations. In this paper we present River Trail - a parallel programming model and API for JavaScript that provides safe, portable, programmer-friendly, deterministic parallelism to JavaScript applications. River Trail allows web applications to effectively utilize multiple cores, vector instructions, and GPUs on client platforms while allowing the web developer to remain within the environment of JavaScript. We describe the implementation of the River Trail compiler and runtime and present experimental results that show the impact of River Trail on performance and scalability for a variety of realistic HTML5 applications. Our experiments show that River Trail has a dramatic positive impact on overall performance and responsiveness of computationally intense JavaScript based applications achieving up to 33.6 times speedup for kernels and up to 11.8 times speedup for realistic web applications compared to sequential JavaScript. Moreover, River Trail enables new interactive web usages that are simply not even possible with standard sequential JavaScript.
[General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering, Compilers]
Combining concern input with program analysis for bloat detection
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Framework based software tends to get bloated by accumulating optional features (or concerns) just-in-case they are needed. The good news is that such feature bloat need not always cause runtime execution bloat. The bad news is that often enough, only a few statements from an optional concern may cause execution bloat that may result in as much as 50% runtime overhead. We present a novel technique to analyze the connection between optional concerns and the potential sources of execution bloat induced by them. Our analysis automatically answers questions such as (1) whether a given set of optional concerns could lead to execution bloat and (2) which particular statements are the likely sources of bloat when those concerns are not required. The technique combines coarse grain concern input from an external source with a fine-grained static analysis. Our experimental evaluation highlights the effectiveness of such concern augmented program analysis in execution bloat assessment of ten programs.
[Software defect analysis, Theory of computation, Software creation and management, Software testing and debugging, Semantics and reasoning, Software verification and validation, Program semantics, Program reasoning, Program analysis, Software and its engineering]
Injecting mechanical faults to localize developer faults for evolving software
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
This paper presents a novel methodology for localizing faults in code as it evolves. Our insight is that the essence of failure-inducing edits made by the developer can be captured using mechanical program transformations (e.g., mutation changes). Based on the insight, we present the FIFL framework, which uses both the spectrum information of edits (obtained using the existing FaultTracer approach) as well as the potential impacts of edits (simulated by mutation changes) to achieve more accurate fault localization. We evaluate FIFL on real-world repositories of nine Java projects ranging from 5.7KLoC to 88.8KLoC. The experimental results show that FIFL is able to outperform the state-of-the-art FaultTracer technique for localizing failure-inducing program edits significantly. For example, all 19 FIFL strategies that use both the spectrum information and simulated impact information for each edit outperform the existing FaultTracer approach statistically at the significance level of 0.01. In addition, FIFL with its default settings outperforms FaultTracer by 2.33% to 86.26% on 16 of the 26 studied version pairs, and is only inferior than FaultTracer on one version pair.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Efficient concurrency-bug detection across inputs
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
In the multi-core era, it is critical to efficiently test multi-threaded software and expose concurrency bugs before software release. Previous work has made significant progress in detecting and validating concurrency bugs under a given input. Unfortunately, software testing always faces large sets of test inputs, and existing techniques are still too expensive to be applied to every test input in practice. In this paper, we use open-source software to study how existing concurrency-bug detection tools work for a set of inputs. The study shows that an interleaving pattern, such as a data race or an atomicity violation, can often be exposed by many inputs. Consequently, existing bug detectors would inevitably waste their bug detection effort to generate duplicate bug reports, when applied to a set of inputs. Guided by the above study, we propose a coverage metric, Concurrent Function Pairs (CFP), to efficiently approximate how interleavings overlap across inputs. Using CFP, we have designed a new approach to detecting data races and atomicity-violation bugs for a set of inputs. Our evaluation on open-source C/C++ applications shows that our CFP-guided approach can effectively accelerate concurrency-bug detection for a set of inputs by reducing redundant detection effort across inputs.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Detecting API documentation errors
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
When programmers encounter an unfamiliar API library, they often need to refer to its documentations, tutorials, or discussions on development forums to learn its proper usage. These API documents contain valuable information, but may also mislead programmers as they may contain errors (e.g., broken code names and obsolete code samples). Although most API documents are actively maintained and updated, studies show that many new and latent errors do exist. It is tedious and error-prone to find such errors manually as API documents can be enormous with thousands of pages. Existing tools are ineffective in locating documentation errors because traditional natural language (NL) tools do not understand code names and code samples, and traditional code analysis tools do not understand NL sentences. In this paper, we propose the first approach, DOCREF, specifically designed and developed to detect API documentation errors. We formulate a class of inconsistencies to indicate potential documentation errors, and combine NL and code analysis techniques to detect and report such inconsistencies. We have implemented DOCREF and evaluated its effectiveness on the latest documentations of five widely-used API libraries. DOCREF has detected more than 1,000 new documentation errors, which we have reported to the authors. Many of the errors have already been confirmed and fixed, after we reported them.
[Applied computing, Software creation and management, Document management and text processing, Documentation, Software notations and tools, Software post-development issues, Document preparation, Hypertext / hypermedia creation, Software libraries and repositories, Software and its engineering]
On-the-fly detection of instability problems in floating-point program execution
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
The machine representation of floating point values has limited precision such that errors may be introduced during execution. These errors may get propagated and magnified by the following operations, leading to instability problems, e.g., control flow path may be undesirably altered and faulty output may be emitted. In this paper, we develop an on-the-fly efficient monitoring technique that can predict if an execution is stable. The technique does not explicitly compute errors as doing so incurs high overhead. Instead, it detects possible places where an error becomes substantially inflated regarding the corresponding value, and then tags the value with one bit to denote that it has an inflated error. It then tracks inflation bit propagation, taking care of operations that may cut off such propagation. It reports instability if any inflation bit reaches a critical execution point, such as a predicate, where the inflated error may induce substantial execution difference, such as different execution paths. Our experiment shows that with appropriate thresholds, the technique can correctly detect that over 99.999996% of the inputs of all the programs we studied are stable while a traditional technique relying solely on inflation detection mistakenly classifies majority of the inputs as unstable for some of the programs. Compared to the state of the art technique that is based on high precision computation and causes several hundred times slowdown, our technique only causes 7.91 times slowdown on average and can report all the true unstable executions with the appropriate thresholds.
[Theory of computation, Software defect analysis, Software creation and management, Semantics and reasoning, Numerical analysis, Software testing and debugging, Mathematical analysis, Software verification and validation, Program semantics, Mathematics of computing, Software and its engineering]
Bounded partial-order reduction
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
Eliminating concurrency errors is increasingly important as systems rely more on parallelism for performance. Exhaustively exploring the state-space of a program's thread interleavings finds concurrency errors and provides coverage guarantees, but suffers from exponential state-space explosion. Two prior approaches alleviate state-space explosion. (1) Dynamic partial-order reduction (DPOR) provides full coverage and explores only one interleaving of independent transitions. (2) Bounded search provides bounded coverage by enumerating interleavings that do not exceed a bound. In particular, we focus on preemption-bounding. Combining partial-order reduction with preemption-bounding had remained an open problem. We show that preemption-bounded search explores the same partial orders repeatedly and consequently explores more executions than unbounded DPOR, even for small bounds. We further show that if DPOR simply uses the preemption bound to prune the state space as it explores new partial orders, it misses parts of the state space reachable in the bound and is therefore unsound. The bound essentially induces dependences between otherwise independent transitions in the DPOR state space. We introduce Bounded Partial Order Reduction (BPOR), a modification of DPOR that compensates for bound dependences. We identify properties that determine how well bounds combine with partial-order reduction. We prove sound coverage and empirically evaluate BPOR with preemption and fairness bounds. We show that by eliminating redundancies, BPOR significantly reduces testing time compared to bounded search. BPOR's faster incremental guarantees will help testers verify larger concurrent programs.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
On-the-fly capacity planning
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
When resolving performance problems, a simple histogram of hot call stacks does not cut it, especially given the highly fluid nature of modern deployments. Why bother tuning, when adding a few CPUs via the management console will quickly resolve the problem? The findings of these tools are also presented without any sense of context: e.g. string conversion may be expensive, but only matters if it contributes greatly to the response time of user logins. Historically, these concerns have been the purview of capacity planning. The power of planners lies in their ability to weigh demand versus capacity, and to do so in terms of the important units of work in the application (such as user logins). Unfortunately, they rely on measurements of rates and latencies, and both quantities are difficult to obtain. Even if possible, when all is said and done, these planners only relate to the code as a black-box: but, why bother adding CPUs, when easy code changes will fix the problem? We present a way to do planning on-the-fly: with a few call stack samples taken from an already-running system, we predict the benefit of a proposed tuning plan. We accomplish this by simulating the effect of a tuning action upon execution speed and the way it shifts resource demand. To identify existing problems, we show how to generate tuning actions automatically, guided by the desire to maximize speedup without needless expense, and that these generated plans may span resource and code changes. We show that it is possible to infer everything needed from these samples alone: levels of resource demand and the units of work in the application. We evaluate our planner on a suite of microbenchmarks and a suite of 15,000 data sets that come from real applications running in the wild.
[Availability, Computer systems organization, Cross-computing tools and techniques, Maintainability and maintenance, Dependable and fault-tolerant systems and networks, Reliability, General and reference]
Relaxed separation logic: a program logic for C11 concurrency
Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications
ACM SIGPLAN Notices VOLUME 48 ISSUE 10
2013
We introduce relaxed separation logic (RSL), the first program logic for reasoning about concurrent programs running under the C11 relaxed memory model. From a user's perspective, RSL is an extension of concurrent separation logic (CSL) with proof rules for the various kinds of C11 atomic accesses. As in CSL, individual threads are allowed to access non-atomically only the memory that they own, thus preventing data races. Ownership can, however, be transferred via certain atomic accesses. For SC-atomic accesses, we permit arbitrary ownership transfer; for acquire/release atomic accesses, we allow ownership transfer only in one direction; whereas for relaxed atomic accesses, we rule out ownership transfer completely. We illustrate RSL with a few simple examples and prove its soundness directly over the axiomatic C11 weak memory model.
[Theory of computation, Semantics and reasoning, Formal language definitions, Software notations and tools, Program reasoning, Formal languages and automata theory, Logic, Software and its engineering]
Checking correctness of TypeScript interfaces for JavaScript libraries
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
The TypeScript programming language adds optional types to JavaScript, with support for interaction with existing JavaScript libraries via interface declarations. Such declarations have been written for hundreds of libraries, but they can be difficult to write and often contain errors, which may affect the type checking and misguide code completion for the application code in IDEs.  We present a pragmatic approach to check correctness of TypeScript declaration files with respect to JavaScript library implementations. The key idea in our algorithm is that many declaration errors can be detected by an analysis of the library initialization state combined with a light-weight static analysis of the library function code.  Our experimental results demonstrate the effectiveness of the approach: it has found 142 errors in the declaration files of 10 libraries, with an analysis time of a few minutes per library and with a low number of false positives. Our analysis of how programmers use library interface declarations furthermore reveals some practical limitations of the TypeScript type system.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Determinacy in static analysis for jQuery
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Static analysis for JavaScript can potentially help programmers find errors early during development. Although much progress has been made on analysis techniques, a major obstacle is the prevalence of libraries, in particular jQuery, which apply programming patterns that have detrimental consequences on the analysis precision and performance. Previous work on dynamic determinacy analysis has demonstrated how information about program expressions that always resolve to a fixed value in some call context may lead to significant scalability improvements of static analysis for such code. We present a static dataflow analysis for JavaScript that infers and exploits determinacy information on-the-fly, to enable analysis of some of the most complex parts of jQuery. The analysis combines selective context and path sensitivity, constant propagation, and branch pruning, based on a systematic investigation of the main causes of analysis imprecision when using a more basic analysis. The techniques are implemented in the TAJS analysis tool and evaluated on a collection of small programs that use jQuery. Our results show that the proposed analysis techniques boost both precision and performance, specifically for inferring type information and call graphs.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
EventBreak: analyzing the responsiveness of user interfaces through performance-guided test generation
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Event-driven user interface applications typically have a single thread of execution that processes event handlers in response to input events triggered by the user, the network, or other applications. Programmers must ensure that event handlers terminate after a short amount of time because otherwise, the application may become unresponsive. This paper presents EventBreak, a performance-guided test generation technique to identify and analyze event handlers whose execution time may gradually increase while using the application. The key idea is to systematically search for pairs of events where triggering one event increases the execution time of the other event. For example, this situation may happen because one event accumulates data that is processed by the other event. We implement the approach for JavaScript-based web applications and apply it to three real-world applications. EventBreak discovers events with an execution time that gradually increases in an unbounded way, which makes the application unresponsive, and events that, if triggered repeatedly, reveal a severe scalability problem, which makes the application unusable. The approach reveals two known bugs and four previously unknown responsiveness problems. Furthermore, we show that EventBreak helps in testing that event handlers avoid such problems by bounding a handler's execution time.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Metrics, Software testing and debugging, Software verification and validation, General and reference, Software and its engineering]
Using web corpus statistics for program analysis
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Several program analysis tools - such as plagiarism detection and bug finding - rely on knowing a piece of code's relative semantic importance. For example, a plagiarism detector should not bother reporting two programs that have an identical simple loop counter test, but should report programs that share more distinctive code. Traditional program analysis techniques (e.g., finding data and control dependencies) are useful, but do not say how surprising or common a line of code is. Natural language processing researchers have encountered a similar problem and addressed it using an n-gram model of text frequency, derived from statistics computed over text corpora. We propose and compute an n-gram model for programming languages, computed over a corpus of 2.8 million JavaScript programs we downloaded from the Web. In contrast to previous techniques, we describe a code n-gram as a subgraph of the program dependence graph that contains all nodes and edges reachable in n steps from the statement. We can count n-grams in a program and count the frequency of n-grams in the corpus, enabling us to compute tf-idf-style measures that capture the differing importance of different lines of code. We demonstrate the power of this approach by implementing a plagiarism detector with accuracy that beats previous techniques, and a bug-finding tool that discovered over a dozen previously unknown bugs in a collection of real deployed programs.
[Theory of computation, Software defect analysis, Software creation and management, Semantics and reasoning, Software testing and debugging, Software verification and validation, Program semantics, Program reasoning, Program analysis, Program verification, Software and its engineering]
Phosphor: illuminating dynamic data flow in commodity jvms
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Dynamic taint analysis is a well-known information flow analysis problem with many possible applications. Taint tracking allows for analysis of application data flow by assigning labels to data, and then propagating those labels through data flow. Taint tracking systems traditionally compromise among performance, precision, soundness, and portability. Performance can be critical, as these systems are often intended to be deployed to production environments, and hence must have low overhead. To be deployed in security-conscious settings, taint tracking must also be sound and precise. Dynamic taint tracking must be portable in order to be easily deployed and adopted for real world purposes, without requiring recompilation of the operating system or language interpreter, and without requiring access to application source code. We present Phosphor, a dynamic taint tracking system for the Java Virtual Machine (JVM) that simultaneously achieves our goals of performance, soundness, precision, and portability. Moreover, to our knowledge, it is the first portable general purpose taint tracking system for the JVM. We evaluated Phosphor's performance on two commonly used JVM languages (Java and Scala), on two successive revisions of two commonly used JVMs (Oracle's HotSpot and OpenJDK's IcedTea) and on Android's Dalvik Virtual Machine, finding its performance to be impressive: as low as 3% (53% on average; 220% at worst) using the DaCapo macro benchmark suite. This paper describes our approach toward achieving portable taint tracking in the JVM.
[Security and privacy, General programming languages, Language features, Software notations and tools, Systems security, Information flow control, Operating systems security, Software and its engineering]
Rubah: DSU for Java on a stock JVM
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
This paper presents Rubah, the first dynamic software updating system for Java that: is portable, implemented via libraries and bytecode rewriting on top of a standard JVM; is efficient, imposing essentially no overhead on normal, steady-state execution; is flexible, allowing nearly arbitrary changes to classes between updates; and isnon-disruptive, employing either a novel eager algorithm that transforms the program state with multiple threads, or a novel lazy algorithm that transforms objects as they are demanded, post-update. Requiring little programmer effort, Rubah has been used to dynamically update five long-running applications: the H2 database, the Voldemort key-value store, the Jake2 implementation of the Quake 2 shooter game, the CrossFTP server, and the JavaEmailServer.
[Availability, Computer systems organization, Cross-computing tools and techniques, Maintainability and maintenance, Dependable and fault-tolerant systems and networks, Reliability, General and reference]
Fast conservative garbage collection
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Garbage collectors are exact or conservative. An exact collector identifies all references precisely and may move referents and update references, whereas a conservative collector treats one or more of stack, register, and heap references as ambiguous. Ambiguous references constrain collectors in two ways. (1) Since they may be pointers, the collectors must retain referents. (2) Since they may be values, the collectors cannot modify them, pinning their referents. We explore conservative collectors for managed languages, with ambiguous stacks and registers. We show that for Java benchmarks they retain and pin remarkably few heap objects: < 0.01% are falsely retained and 0.03% are pinned. The larger effect is collector design. Prior conservative collectors (1) use mark-sweep and unnecessarily forgo moving all objects, or (2) use mostly copying and pin entire pages. Compared to generational collection, overheads are substantial: 12% and 45% respectively. We introduce high performance conservative Immix and reference counting (RC). Immix is a mark-region collector with fine line-grain pinning and opportunistic copying of unambiguous referents. Deferred RC simply needs an object map to deliver the first conservative RC. We implement six exact collectors and their conservative counterparts. Conservative Immix and RC come within 2 to 3% of their exact counterparts. In particular, conservative RC Immix is slightly faster than a well-tuned exact generational collector. These findings show that for managed languages, conservative collection is compatible with high performance.
[Garbage collection, Operating systems, Memory management, Contextual software domains, Software organization and properties, Software and its engineering]
Region-based memory management for GPU programming languages: enabling rich data structures on a spartan host
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Graphics processing units (GPUs) can effectively accelerate many applications, but their applicability has been largely limited to problems whose solutions can be expressed neatly in terms of linear algebra. Indeed, most GPU programming languages limit the user to simple data structures - typically only multidimensional rectangular arrays of scalar values. Many algorithms are more naturally expressed using higher level language features, such as algebraic data types (ADTs) and first class procedures, yet building these structures in a manner suitable for a GPU remains a challenge. We present a region-based memory management approach that enables rich data structures in Harlan, a language for data parallel computing. Regions enable rich data structures by providing a uniform representation for pointers on both the CPU and GPU and by providing a means of transferring entire data structures between CPU and GPU memory. We demonstrate Harlan's increased expressiveness on several example programs and show that Harlan performs well on more traditional data-parallel problems.
[Garbage collection, Language types, Software notations and tools, Parallel programming languages, Runtime environments, Contextual software domains, Distributed programming languages, Operating systems, General programming languages, Memory management, Functional languages, Concurrent programming languages, Software organization and properties, Software and its engineering, Compilers]
Smten with satisfiability-based search
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) have been used in solving a wide variety of important and challenging problems, including automatic test generation, model checking, and program synthesis. For these applications to scale to larger problem instances, developers cannot rely solely on the sophistication of SAT and SMT solvers to efficiently solve their queries; they must also optimize their own orchestration and construction of queries. We present Smten, a high-level language for orchestrating and constructing satisfiability-based search queries. We show that applications developed using Smten require significantly fewer lines of code and less developer effort to achieve results comparable to standard SMT-based tools.
[Software implementation planning, Software design techniques, Designing software, Software development process management, Software creation and management, General programming languages, Language features, Software notations and tools, Software and its engineering]
StreamJIT: a commensal compiler for high-performance stream programming
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
There are many domain libraries, but despite the performance benefits of compilation, domain-specific languages are comparatively rare due to the high cost of implementing an optimizing compiler. We propose commensal compilation, a new strategy for compiling embedded domain-specific languages by reusing the massive investment in modern language virtual machine platforms. Commensal compilers use the host language's front-end, use host platform APIs that enable back-end optimizations by the host platform JIT, and use an autotuner for optimization selection. The cost of implementing a commensal compiler is only the cost of implementing the domain-specific optimizations. We demonstrate the concept by implementing a commensal compiler for the stream programming language StreamJIT atop the Java platform. Our compiler achieves performance 2.8 times better than the StreamIt native code (via GCC) compiler with considerably less implementation effort.
[Source code generation, Data flow languages, Distributed programming languages, General programming languages, Language types, Software notations and tools, Concurrent programming languages, Parallel programming languages, Software and its engineering, Compilers]
SurveyMan: programming and automatically debugging surveys
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Surveys can be viewed as programs, complete with logic, control flow, and bugs. Word choice or the order in which questions are asked can unintentionally bias responses. Vague, confusing, or intrusive questions can cause respondents to abandon a survey. Surveys can also have runtime errors: inattentive respondents can taint results. This effect is especially problematic when deploying surveys in uncontrolled settings, such as on the web or via crowdsourcing platforms. Because the results of surveys drive business decisions and inform scientific conclusions, it is crucial to make sure they are correct. We present SurveyMan, a system for designing, deploying, and automatically debugging surveys. Survey authors write their surveys in a lightweight domain-specific language aimed at end users. SurveyMan statically analyzes the survey to provide feedback to survey authors before deployment. It then compiles the survey into JavaScript and deploys it either to the web or a crowdsourcing platform. SurveyMan's dynamic analyses automatically find survey bugs, and control for the quality of responses. We evaluate SurveyMan's algorithms analytically and empirically, demonstrating its effectiveness with case studies of social science surveys conducted via Amazon's Mechanical Turk.
[General programming languages, Language types, Context specific languages, Software notations and tools, Specialized application languages, Software and its engineering]
Rate types for stream programs
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
We introduce RATE TYPES, a novel type system to reason about and optimize data-intensive programs. Built around stream languages, RATE TYPES performs static quantitative reasoning about stream rates -- the frequency of data items in a stream being consumed, processed, and produced. Despite the fact that streams are fundamentally dynamic, we find two essential concepts of stream rate control -- throughput ratio and natural rate -- are intimately related to the program structure itself and can be effectively reasoned about by a type system. RATE TYPES is proven to correspond with a time-aware and parallelism-aware operational semantics. The strong correspondence result tolerates arbitrary schedules, and does not require any synchronization between stream filters.We further implement RATE TYPES, demonstrating its effectiveness in predicting stream data rates in real-world stream programs.
[Theory of computation, Semantics and reasoning, Program constructs, Type structures]
Foundations of path-dependent types
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
A scalable programming language is one in which the same concepts can describe small as well as large parts. Towards this goal, Scala unifies concepts from object and module systems. An essential ingredient of this unification is the concept of objects with type members, which can be referenced through path-dependent types. Unfortunately, path-dependent types are not well-understood, and have been a roadblock in grounding the Scala type system on firm theory. We study several calculi for path-dependent types. We present DOT which captures the essence - DOT stands for Dependent Object Types. We explore the design space bottom-up, teasing apart inherent from accidental complexities, while fully mechanizing our models at each step. Even in this simple setting, many interesting patterns arise from the interaction of structural and nominal features. Whereas our simple calculus enjoys many desirable and intuitive properties, we demonstrate that the theory gets much more complicated once we add another Scala feature, type refinement, or extend the subtyping relation to a lattice. We discuss possible remedies and trade-offs in modeling type systems for Scala-like languages.
[Classes and objects, Language features, Software notations and tools, Program constructs, Object oriented constructs, Theory of computation, Semantics and reasoning, General programming languages, Abstract data types, Type structures, Software and its engineering, Polymorphism]
Confined gradual typing
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Gradual typing combines static and dynamic typing flexibly and safely in a single programming language. To do so, gradually typed languages implicitly insert casts where needed, to ensure at runtime that typing assumptions are not violated by untyped code. However, the implicit nature of cast insertion, especially on higher-order values, can jeopardize reliability and efficiency: higher-order casts can fail at any time, and are costly to execute. We propose Confined Gradual Typing, which extends gradual typing with two new type qualifiers that let programmers control the flow of values between the typed and the untyped worlds, and thereby trade some flexibility for more reliability and performance. We formally develop two variants of Confined Gradual Typing that capture different flexibility/guarantee tradeoffs. We report on the implementation of Confined Gradual Typing in Gradualtalk, a gradually-typed Smalltalk, which confirms the performance advantage of avoiding unwanted higher-order casts and the low overhead of the approach.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Refactoring Java generics by inferring wildcards, in practice
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Wildcard annotations can improve the generality of Java generic libraries, but require heavy manual effort. We present an algorithm for refactoring and inferring more general type instantiations of Java generics using wildcards. Compared to past approaches, our work is practical and immediately applicable: we assume no changes to the Java type system, while taking into account all its intricacies. Our system allows users to select declarations (variables, method parameters, return types, etc.) to generalize and considers declarations not declared in available source code. It then performs an inter-procedural flow analysis and a method body analysis, in order to generalize type signatures. We evaluate our technique on six Java generic libraries. We find that 34% of available declarations of variant type signatures can be generalized - i.e., relaxed with more general wildcard types. On average, 146 other declarations need to be updated when a declaration is generalized, showing that this refactoring would be too tedious and error-prone to perform manually.
[Classes and objects, General programming languages, Language features, Software notations and tools, Abstract data types, Software and its engineering, Polymorphism]
Continuously measuring critical section pressure with the free-lunch profiler
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Today, Java is regularly used to implement large multi-threaded server-class applications that use locks to protect access to shared data. However, understanding the impact of locks on the performance of a system is complex, and thus the use of locks can impede the progress of threads on configurations that were not anticipated by the developer, during specific phases of the execution. In this paper, we propose Free Lunch, a new lock profiler for Java application servers, specifically designed to identify, in-vivo, phases where the progress of the threads is impeded by a lock. Free Lunch is designed around a new metric, critical section pressure (CSP), which directly correlates the progress of the threads to each of the locks. Using Free Lunch, we have identified phases of high CSP, which were hidden with other lock profilers, in the distributed Cassandra NoSQL database and in several applications from the DaCapo 9.12, the SPECjvm2008 and the SPECjbb2005 benchmark suites. Our evaluation of Free Lunch shows that its overhead is never greater than 6%, making it suitable for in-vivo use.
[Cross-computing tools and techniques, Management of computing and information systems, Software selection and adaptation, Software performance, Professional topics, Extra-functional properties, Software management, Social and professional topics, Performance, General and reference, Software organization and properties, Software and its engineering]
Chisel: reliability- and accuracy-aware optimization of approximate computational kernels
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
The accuracy of an approximate computation is the distance between the result that the computation produces and the corresponding fully accurate result. The reliability of the computation is the probability that it will produce an acceptably accurate result. Emerging approximate hardware platforms provide approximate operations that, in return for reduced energy consumption and/or increased performance, exhibit reduced reliability and/or accuracy.  We present Chisel, a system for reliability- and accuracy-aware optimization of approximate computational kernels that run on approximate hardware platforms. Given a combined reliability and/or accuracy specification, Chisel automatically selects approximate kernel operations to synthesize an approximate computation that minimizes energy consumption while satisfying its reliability and accuracy specification.  We evaluate Chisel on five applications from the image processing, scientific computing, and financial analysis domains. The experimental results show that our implemented optimization algorithm enables Chisel to optimize our set of benchmark kernels to obtain energy savings from 8.7% to 19.8% compared to the fully reliable kernel implementations while preserving important reliability guarantees.
[Software notations and tools, Software and its engineering, Compilers]
An experimental survey of energy management across the stack
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Modern demand for energy-efficient computation has spurred research at all levels of the stack, from devices to microarchitecture, operating systems, compilers, and languages. Unfortunately, this breadth has resulted in a disjointed space, with technologies at different levels of the system stack rarely compared, let alone coordinated. This work begins to remedy the problem, conducting an experimental survey of the present state of energy management across the stack. Focusing on settings that are exposed to software, we measure the total energy, average power, and execution time of 41 benchmark applications in 220 configurations, across a total of 200,000 program executions. Some of the more important findings of the survey include that effective parallelization and compiler optimizations have the potential to save far more energy than Linux's frequency tuning algorithms; that certain non-complementary energy strategies can undercut each other's savings by half when combined; and that while the power impacts of most strategies remain constant across applications, the runtime impacts vary, resulting in inconsistent energy impacts.
[Measurement, Cross-computing tools and techniques, Metrics, Performance, General and reference]
Understanding energy behaviors of thread management constructs
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Java programmers are faced with numerous choices in managing concurrent execution on multicore platforms. These choices often have different trade-offs (e.g., performance, scalability, and correctness guarantees). This paper analyzes an additional dimension, energy consumption. It presents an empirical study aiming to illuminate the relationship between the choices and settings of thread management constructs and energy consumption. We consider three important thread management constructs in concurrent programming: explicit thread creation, fixed-size thread pooling, and work stealing. We further shed light on the energy/performance trade-off of three ``tuning knobs'' of these constructs: the number of threads, the task division strategy, and the characteristics of processed data. Through an extensive experimental space exploration over real-world Java programs, we produce a list of findings about the energy behaviors of concurrent programs, which are not always obvious. The study serves as a first step toward improving energy efficiency of concurrent programs on parallel architectures.
[Design, Cross-computing tools and techniques, General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, General and reference, Software and its engineering]
Distributed REScala: an update algorithm for distributed reactive programming
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Reactive programming improves the design of reactive applications by relocating the logic for managing dependencies between dependent values away from the application logic to the language implementation. Many distributed applications are reactive. Yet, existing change propagation algorithms are not suitable in a distributed setting. We propose Distributed REScala, a reactive language with a change propagation algorithm that works without centralized knowledge about the topology of the dependency structure among reactive values and avoids unnecessary propagation of changes, while retaining safety guarantees (glitch freedom). Distributed REScala enables distributed reactive programming, bringing the benefits of reactive programming to distributed applications. We demonstrate the enabled design improvements by a case study. We also empirically evaluate the performance of our algorithm in comparison to other algorithms in a simulated distributed setting.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
From object algebras to attribute grammars
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Oliveira and Cook (2012) and Oliveira et al. (2013) have recently introduced object algebras as a program structuring technique to improve the modularity and extensibility of programs. We analyze the relationship between object algebras and attribute grammars (AGs), a formalism to augment context-free grammars with attributes. We present an extension of the object algebra technique with which the full class of L-attributed grammars - an important class of AGs that corresponds to one-pass compilers - can be encoded in Scala. The encoding is modular (attributes can be defined and type-checked separately), scalable (the size of the encoding is linear in the size of the AG specification) and compositional (each AG artifact is represented as a semantic object of the host language). To evaluate these claims, we have formalized the encoding and re-implemented a one-pass compiler for a subset of C with our technique. We also discuss how advanced features of modern AG systems, such as higher-order and parameterized attributes, reference attributes, and forwarding can be supported.
[Theory of computation, General programming languages, Object oriented languages, Language types, Software notations and tools, Formal language definitions, Formal languages and automata theory, Software and its engineering]
Late data layout: unifying data representation transformations
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Values need to be represented differently when interacting with certain language features. For example, an integer has to take an object-based representation when interacting with erased generics, although, for performance reasons, the stack-based value representation is better. To abstract over these implementation details, some programming languages choose to expose a unified high-level concept (the integer) and let the compiler choose its exact representation and insert coercions where necessary. This pattern appears in multiple language features such as value classes, specialization and multi-stage programming: they all expose a unified concept which they later refine into multiple representations. Yet, the underlying compiler implementations typically entangle the core mechanism with assumptions about the alternative representations and their interaction with other language features. In this paper we present the Late Data Layout mechanism, a simple but versatile type-driven generalization that subsumes and improves the state-of-the-art representation transformations. In doing so, we make two key observations: (1) annotated types conveniently capture the semantics of using multiple representations and (2) local type inference can be used to consistently and optimally introduce coercions. We validated our approach by implementing three language features as Scala compiler extensions: value classes, specialization (using the miniboxing representation) and a simplified multi-stage programming mechanism.
[Classes and objects, Language features, Software notations and tools, Record storage systems, Program constructs, Object oriented constructs, Information systems, Theory of computation, Semantics and reasoning, Information storage systems, General programming languages, Software and its engineering, Polymorphism]
i3QL: language-integrated live data views
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
An incremental computation updates its result based on a change to its input, which is often an order of magnitude faster than a recomputation from scratch. In particular, incrementalization can make expensive computations feasible for settings that require short feedback cycles, such as interactive systems, IDEs, or (soft) real-time systems. This paper presents i3QL, a general-purpose programming language for specifying incremental computations. i3QL provides a declarative SQL-like syntax and is based on incremental versions of operators from relational algebra, enriched with support for general recursion. We integrated i3QL into Scala as a library, which enables programmers to use regular Scala code for non-incremental subcomputations of an i3QL query and to easily integrate incremental computations into larger software projects. To improve performance, i3QL optimizes user-defined queries by applying algebraic laws and partial evaluation. We describe the design and implementation of i3QL and its optimizations, demonstrate its applicability, and evaluate its performance.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Atlas: leveraging locks for non-volatile memory consistency
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Non-volatile main memory, such as memristors or phase change memory, can revolutionize the way programs persist data. In-memory objects can themselves be persistent without the need for a separate persistent data storage format. However, the challenge is to ensure that such data remains consistent if a failure occurs during execution. In this paper, we present our system, called Atlas, which adds durability semantics to lock-based code, typically allowing us to automatically maintain a globally consistent state even in the presence of failures. We identify failure-atomic sections of code based on existing critical sections and describe a log-based implementation that can be used to recover a consistent state after a failure. We discuss several subtle semantic issues and implementation tradeoffs. We confirm the ability to rapidly flush CPU caches as a core implementation bottleneck and suggest partial solutions. Experimental results confirm the practicality of our approach and provide insight into the overheads of such a system.
[General programming languages, Language features, Concurrent programming structures, Software notations and tools, Software and its engineering]
Fast splittable pseudorandom number generators
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
We describe a new algorithm SplitMix for an object-oriented and splittable pseudorandom number generator (PRNG) that is quite fast: 9 64-bit arithmetic/logical operations per 64 bits generated. A conventional linear PRNG object provides a generate method that returns one pseudorandom value and updates the state of the PRNG, but a splittable PRNG object also has a second operation, split, that replaces the original PRNG object with two (seemingly) independent PRNG objects, by creating and returning a new such object and updating the state of the original object. Splittable PRNG objects make it easy to organize the use of pseudorandom numbers in multithreaded programs structured using fork-join parallelism. No locking or synchronization is required (other than the usual memory fence immediately after object creation). Because the generate method has no loops or conditionals, it is suitable for SIMD or GPU implementation. We derive SplitMix from the DotMix algorithm of Leiserson, Schardl, and Sukha by making a series of program transformations and engineering improvements. The end result is an object-oriented version of the purely functional API used in the Haskell library for over a decade, but SplitMix is faster and produces pseudorandom sequences of higher quality; it is also far superior in quality and speed to java.util.Random, and has been included in Java JDK8 as the class java.util.SplittableRandom. We have tested the pseudorandom sequences produced by SplitMix using two standard statistical test suites (DieHarder and TestU01) and they appear to be adequate for "everyday" use, such as in Monte Carlo algorithms and randomized data structures where speed is important.
[General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Probability and statistics, Probabilistic reasoning algorithms, Mathematics of computing, Concurrent computing methodologies, Random number generation, Software and its engineering]
Multithreaded test synthesis for deadlock detection
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Designing and implementing thread-safe multithreaded libraries can be a daunting task as developers of these libraries need to ensure that their implementations are free from concurrency bugs, including deadlocks. The usual practice involves employing software testing and/or dynamic analysis to detect deadlocks. Their effectiveness is dependent on well-designed multithreaded test cases. Unsurprisingly, developing multithreaded tests is significantly harder than developing sequential tests for obvious reasons. In this paper, we address the problem of automatically synthesizing multithreaded tests that can induce deadlocks. The key insight to our approach is that a subset of the properties observed when a deadlock manifests in a concurrent execution can also be observed in a single threaded execution. We design a novel, automatic, scalable and directed approach that identifies these properties and synthesizes a deadlock revealing multithreaded test. The input to our approach is the library implementation under consideration and the output is a set of deadlock revealing multithreaded tests. We have implemented our approach as part of a tool, named OMEN1. OMEN is able to synthesize multithreaded tests on many multithreaded Java libraries. Applying a dynamic deadlock detector on the execution of the synthesized tests results in the detection of a number of deadlocks, including 35 real deadlocks in classes documented as thread-safe. Moreover, our experimental results show that dynamic analysis on multithreaded tests that are either synthesized randomly or developed by third-party programmers are ineffective in detecting the deadlocks.
[Software defect analysis, Traceability, Software creation and management, Software testing and debugging, Software verification and validation, Process validation, Software and its engineering]
Symbolic execution of multithreaded programs from arbitrary program contexts
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
We describe an algorithm to perform symbolic execution of a multithreaded program starting from an arbitrary program context. We argue that this can enable more efficient symbolic exploration of deep code paths in multithreaded programs by allowing the symbolic engine to jump directly to program contexts of interest. The key challenge is modeling the initial context with reasonable precision - an overly approximate model leads to exploration of many infeasible paths during symbolic execution, while a very precise model would be so expensive to compute that computing it would defeat the purpose of jumping directly to the initial context in the first place. We propose a context-specific dataflow analysis that approximates the initial context cheaply, but precisely enough to avoid some common causes of infeasible-path explosion. This model is necessarily approximate - it may leave portions of the memory state unconstrained, leaving our symbolic execution unable to answer simple questions such as "which thread holds lock A?". For such cases, we describe a novel algorithm for evaluating symbolic synchronization during symbolic execution. Our symbolic execution semantics are sound and complete up to the limits of the underlying SMT solver. We describe initial experiments on an implementation in Cloud 9.
[Theory of computation, Models of computation, Software creation and management, Semantics and reasoning, Abstract machines, Software verification and validation, Computing methodologies, Symbolic and algebraic manipulation, Program reasoning, Abstraction, Software and its engineering]
CheckCell: data debugging for spreadsheets
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Testing and static analysis can help root out bugs in programs, but not in data. This paper introduces data debugging, an approach that combines program analysis and statistical analysis to automatically find potential data errors. Since it is impossible to know a priori whether data are erroneous, data debugging instead locates data that has a disproportionate impact on the computation. Such data is either very important, or wrong. Data debugging is especially useful in the context of data-intensive programming environments that intertwine data with programs in the form of queries or formulas. We present the first data debugging tool, CheckCell, an add-in for Microsoft Excel. CheckCell identifies cells that have an unusually high impact on the spreadsheet's computations. We show that CheckCell is both analytically and empirically fast and effective. We show that it successfully finds injected typographical errors produced by a generative model trained with data entry from 169,112 Mechanical Turk tasks. CheckCell is more precise and efficient than standard outlier detection techniques. CheckCell also automatically identifies a key flaw in the infamous Reinhart and Rogoff spreadsheet.
[Software defect analysis, Applied computing, Personal computers and PC applications, Software creation and management, Software testing and debugging, Software verification and validation, Spreadsheets, Computers in other domains, Software and its engineering]
Finding minimum type error sources
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Automatic type inference is a popular feature of functional programming languages. If a program cannot be typed, the compiler typically reports a single program location in its error message. This location is the point where the type inference failed, but not necessarily the actual source of the error. Other potential error sources are not even considered. Hence, the compiler often misses the true error source, which increases debugging time for the programmer. In this paper, we present a general framework for automatic localization of type errors. Our algorithm finds all minimum error sources, where the exact definition of minimum is given in terms of a compiler-specific ranking criterion. Compilers can use minimum error sources to produce more meaningful error reports, and for automatic error correction. Our approach works by reducing the search for minimum error sources to an optimization problem that we formulate in terms of weighted maximum satisfiability modulo theories (MaxSMT). The reduction to weighted MaxSMT allows us to build on SMT solvers to support rich type systems and at the same time abstract from the concrete criterion that is used for ranking the error sources. We have implemented an instance of our framework targeted at Hindley-Milner type systems and evaluated it on existing OCaml benchmarks for type error localization. Our evaluation shows that our approach has the potential to significantly improve the quality of type error reports produced by state of the art compilers.
[Theory of computation, Software creation and management, Semantics and reasoning, Software verification and validation, Program semantics, Program reasoning, Program analysis, Software and its engineering]
Flint: fixing linearizability violations
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Writing concurrent software while achieving both correctness and efficiency is a grand challenge. To facilitate this task, concurrent data structures have been introduced into the standard library of popular languages like Java and C#. Unfortunately, while the operations exposed by concurrent data structures are atomic (or linearizable), compositions of these operations are not necessarily atomic. Recent studies have found many erroneous implementations of composed concurrent operations.  We address the problem of fixing nonlinearizable composed operations such that they behave atomically. We introduce Flint, an automated fixing algorithm for composed Map operations. Flint accepts as input a composed operation suffering from atomicity violations. Its output, if fixing succeeds, is a composed operation that behaves equivalently to the original operation in sequential runs and is guaranteed to be atomic. To our knowledge, Flint is the first general algorithm for fixing incorrect concurrent compositions.  We have evaluated Flint on 48 incorrect compositions from 27 popular applications, including Tomcat and MyFaces. The results are highly encouraging: Flint is able to correct 96% of the methods, and the fixed version is often the same as the fix by an expert programmer and as efficient as the original code.
[General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Statistical debugging for real-world performance problems
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Design and implementation defects that lead to inefficient computation widely exist in software. These defects are difficult to avoid and discover. They lead to severe performance degradation and energy waste during production runs, and are becoming increasingly critical with the meager increase of single-core hardware performance and the increasing concerns about energy constraints. Effective tools that diagnose performance problems and point out the inefficiency root cause are sorely needed. The state of the art of performance diagnosis is preliminary. Profiling can identify the functions that consume the most computation resources, but can neither identify the ones that waste the most resources nor explain why. Performance-bug detectors can identify specific type of inefficient computation, but are not suited for diagnosing general performance problems. Effective failure diagnosis techniques, such as statistical debugging, have been proposed for functional bugs. However, whether they work for performance problems is still an open question. In this paper, we first conduct an empirical study to understand how performance problems are observed and reported by real-world users. Our study shows that statistical debugging is a natural fit for diagnosing performance problems, which are often observed through comparison-based approaches and reported together with both good and bad inputs. We then thoroughly investigate different design points in statistical debugging, including three different predicates and two different types of statistical models, to understand which design point works the best for performance diagnosis. Finally, we study how some unique nature of performance bugs allows sampling techniques to lower the overhead of run-time performance diagnosis without extending the diagnosis latency.
[Theory of computation, Software defect analysis, Software creation and management, Semantics and reasoning, Software testing and debugging, Software verification and validation, Program reasoning, Program verification, Software and its engineering]
Adaptive LL(*) parsing: the power of dynamic analysis
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Despite the advances made by modern parsing strategies such as PEG, LL(*), GLR, and GLL, parsing is not a solved problem. Existing approaches suffer from a number of weaknesses, including difficulties supporting side-effecting embedded actions, slow and/or unpredictable performance, and counter-intuitive matching strategies. This paper introduces the ALL(*) parsing strategy that combines the simplicity, efficiency, and predictability of conventional top-down LL(k) parsers with the power of a GLR-like mechanism to make parsing decisions. The critical innovation is to move grammar analysis to parse-time, which lets ALL(*) handle any non-left-recursive context-free grammar. ALL(*) is O(n4) in theory but consistently performs linearly on grammars used in practice, outperforming general strategies such as GLL and GLR by orders of magnitude. ANTLR 4 generates ALL(*) parsers and supports direct left-recursion through grammar rewriting. Widespread ANTLR 4 use (5000 downloads/month in 2013) provides evidence that ALL(*) is effective for a wide variety of applications.
[Theory of computation, Semantics and reasoning, Parsing, Formal language definitions, Software notations and tools, Program reasoning, Syntax, Software and its engineering]
Automated migration of build scripts using dynamic analysis and search-based refactoring
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
The efficiency of a build system is an important factor for developer productivity. As a result, developer teams have been increasingly adopting new build systems that allow higher build parallelization. However, migrating the existing legacy build scripts to new build systems is a tedious and error-prone process. Unfortunately, there is insufficient support for automated migration of build scripts, making the migration more problematic. We propose the first dynamic approach for automated migration of build scripts to new build systems. Our approach works in two phases. First, from a set of execution traces, we synthesize build scripts that accurately capture the intent of the original build. The synthesized build scripts are typically long and hard to maintain. Second, we apply refactorings that raise the abstraction level of the synthesized scripts (e.g., introduce functions for similar fragments). As different refactoring sequences may lead to different build scripts, we use a search-based approach that explores various sequences to identify the best (e.g., shortest) build script. We optimize search-based refactoring with partial-order reduction to faster explore refactoring sequences. We implemented the proposed two phase migration approach in a tool called METAMORPHOSIS that has been recently used at Microsoft.
[Software and its engineering]
MIX10: compiling MATLAB to X10 for high performance
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
MATLAB is a popular dynamic array-based language commonly used by students, scientists and engineers who appreciate the interactive development style, the rich set of array operators, the extensive builtin library, and the fact that they do not have to declare static types. Even though these users like to program in MATLAB, their computations are often very compute-intensive and are better suited for emerging high performance computing systems. This paper reports on MIX10, a source-to-source compiler that automatically translates MATLAB programs to X10, a language designed for "Performance and Productivity at Scale"; thus, helping scientific programmers make better use of high performance computing systems. There is a large semantic gap between the array-based dynamically-typed nature of MATLAB and the object-oriented, statically-typed, and high-level array abstractions of X10. This paper addresses the major challenges that must be overcome to produce sequential X10 code that is competitive with state-of-the-art static compilers for MATLAB which target more conventional imperative languages such as C and Fortran. Given that efficient basis, the paper then provides a translation for the MATLAB parfor construct that leverages the powerful concurrency constructs in X10. The MIX10 compiler has been implemented using the McLab compiler tools, is open source, and is available both for compiler researchers and end-user MATLAB programmers. We have used the implementation to perform many empirical measurements on a set of 17 MATLAB benchmarks. We show that our best MIX10-generated code is significantly faster than the de facto Mathworks' MATLAB system, and that our results are competitive with state-of-the-art static compilers that target C and Fortran. We also show the importance of finding the correct approach to representing the arrays in the generated X10 code, and the necessity of an IntegerOkay' analysis that determines which double variables can be safely represented as integers. Finally, we show that our X10-based handling of the MATLAB parfor greatly outperforms the de facto MATLAB implementation.
[Software notations and tools, Software and its engineering, Compilers]
Staged parser combinators for efficient data processing
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Parsers are ubiquitous in computing, and many applications depend on their performance for decoding data efficiently. Parser combinators are an intuitive tool for writing parsers: tight integration with the host language enables grammar specifications to be interleaved with processing of parse results. Unfortunately, parser combinators are typically slow due to the high overhead of the host language abstraction mechanisms that enable composition. We present a technique for eliminating such overhead. We use staging, a form of runtime code generation, to dissociate input parsing from parser composition, and eliminate intermediate data structures and computations associated with parser composition at staging time. A key challenge is to maintain support for input dependent grammars, which have no clear stage distinction. Our approach applies to top-down recursive-descent parsers as well as bottom-up non-deterministic parsers with key applications in dynamic programming on sequences, where we auto-generate code for parallel hardware. We achieve performance comparable to specialized, hand-written parsers.
[Parsers, Source code generation, Software notations and tools, Software and its engineering, Compilers]
Bounded exhaustive test input generation from hybrid invariants
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
We present a novel technique for producing bounded exhaustive test suites from hybrid invariants, i.e., invariants that are expressed imperatively, declaratively, or as a combination of declarative and imperative predicates. Hybrid specifications are processed using known mechanisms for the imperative and declarative parts, but combined in a way that enables us to exploit information from the declarative side, such as tight bounds computed from the declarative specification, to improve the search both on the imperative and declarative sides. Moreover, our technique automatically evaluates different possible ways of processing the imperative side, and the alternative settings (imperative or declarative) for parts of the invariant available both declaratively and imperatively, to decide the most convenient invariant configuration with respect to efficiency in test generation. This is achieved by transcoping, i.e., by assessing the efficiency of the different alternatives on small scopes (where generation times are negligible), and then extrapolating the results to larger scopes. We also show experiments involving collection classes that support the effectiveness of our technique, by demonstrating that (i) bounded exhaustive suites can be computed from hybrid invariants significantly more efficiently than doing so using state-of-the-art purely imperative and purely declarative approaches, and (ii) our technique is able to automatically determine efficient hybrid invariants, in the sense that they lead to an efficient computation of bounded exhaustive suites, using transcoping.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Compiler verification meets cross-language linking via data abstraction
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Many real programs are written in multiple different programming languages, and supporting this pattern creates challenges for formal compiler verification. We describe our Coq verification of a compiler for a high-level language, such that the compiler correctness theorem allows us to derive partial-correctness Hoare-logic theorems for programs built by linking the assembly code output by our compiler and assembly code produced by other means. Our compiler supports such tricky features as storable cross-language function pointers, without giving up the usual benefits of being able to verify different compiler phases (including, in our case, two classic optimizations) independently. The key technical innovation is a mixed operational and axiomatic semantics for the source language, with a built-in notion of abstract data types, such that compiled code interfaces with other languages only through axiomatically specified methods that mutate encapsulated private data, represented in whatever formats are most natural for those languages.
[Theory of computation, Semantics and reasoning, Software notations and tools, Program reasoning, Program verification, Software and its engineering, Compilers]
GPS: navigating weak memory with ghosts, protocols, and separation
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Weak memory models formalize the inconsistent behaviors that one can expect to observe in multithreaded programs running on modern hardware. In so doing, however, they complicate the already-difficult task of reasoning about correctness of concurrent code. Worse, they render impotent the sophisticated formal methods that have been developed to tame concurrency, which almost universally assume a strong (i.e. sequentially consistent) memory model. This paper introduces GPS, the first program logic to provide a full-fledged suite of modern verification techniques - including ghost state, protocols, and separation logic - for high-level, structured reasoning about weak memory. We demonstrate the effectiveness of GPS by applying it to challenging examples drawn from the Linux kernel as well as lock-free data structures. We also define the semantics of GPS and prove in Coq that it is sound with respect to the axiomatic C11 weak memory model.
[Theory of computation, Semantics and reasoning, Formal language definitions, Software notations and tools, Formal languages and automata theory, Program reasoning, Logic, Software and its engineering]
Natural proofs for asynchronous programs using almost-synchronous reductions
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
We consider the problem of provably verifying that an asynchronous message-passing system satisfies its local assertions. We present a novel reduction scheme for asynchronous event-driven programs that finds almost-synchronous invariants - invariants consisting of global states where message buffers are close to empty. The reduction finds almost-synchronous invariants and simultaneously argues that they cover all local states. We show that asynchronous programs often have almost-synchronous invariants and that we can exploit this to build natural proofs that they are correct. We implement our reduction strategy, which is sound and complete, and show that it is more effective in proving programs correct as well as more efficient in finding bugs in several programs, compared to current search strategies which almost always diverge. The high point of our experiments is that our technique can prove the Windows Phone USB Driver written in P [9]correct for the responsiveness property, which was hitherto not provable using state-of-the-art model-checkers.
[Software functional properties, Computing methodologies, Language types, Software notations and tools, Distributed computing methodologies, Correctness, Theory of computation, Verification by model checking, Distributed programming languages, General programming languages, Model checking, Proof theory, Logic, Formal methods, Software organization and properties, Software and its engineering]
Accelerating iterators in optimizing AST interpreters
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Generators offer an elegant way to express iterators. However, their performance has always been their Achilles heel and has prevented widespread adoption. We present techniques to efficiently implement and optimize generators. We have implemented our optimizations in ZipPy, a modern, light-weight AST interpreter based Python 3 implementation targeting the Java virtual machine. Our implementation builds on a framework that optimizes AST interpreters using just-in-time compilation. In such a system, it is crucial that AST optimizations do not prevent subsequent optimizations. Our system was carefully designed to avoid this problem. We report an average speedup of 3.58x for generator-bound programs. As a result, using generators no longer has downsides and programmers are free to enjoy their upsides.
[Source code generation, Interpreters, Software notations and tools, Software and its engineering, Compilers]
Call sequence prediction through probabilistic calling automata
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Predicting a sequence of upcoming function calls is important for optimizing programs written in modern managed languages (e.g., Java, Javascript, C#.) Existing function call predictions are mainly built on statistical patterns, suitable for predicting a single call but not a sequence of calls. This paper presents a new way to enable call sequence prediction, which exploits program structures through Probabilistic Calling Automata (PCA), a new program representation that captures both the inherent ensuing relations among function calls, and the probabilistic nature of execution paths. It shows that PCA-based prediction outperforms existing predictions, yielding substantial speedup when being applied to guide Just-In-Time compilation. By enabling accurate, efficient call sequence prediction for the first time, PCA-based predictors open up many new opportunities for dynamic program optimizations.
[Software notations and tools, Software and its engineering, Compilers]
Space-efficient multi-versioning for input-adaptive feedback-driven program optimizations
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Function versioning is an approach to addressing input-sensitivity of program optimizations. A major side effect of it is notable code size increase, which has been hindering its broad applications to large code bases and space-stringent environments. In this paper, we initiate a systematic exploration into the problem, providing answers to some fundamental questions: Given a space constraint, to which function we should apply versioning? How many versions of a function should we include in the final executable? Is the optimal selection feasible to do in polynomial time? This study proves selecting the best set of versions under a space constraint is NP-complete and proposes a heuristic algorithm named CHoGS which yields near optimal results in quadratic time. We implement the algorithm and conduct experiments through the IBM XL compilers. We observe significant performance enhancement with only slight code size increase; the results from CHoGS show factors of higher space efficiency than those from traditional hotness-based methods.
[Source code generation, Software notations and tools, Software and its engineering, Compilers]
The hiphop virtual machine
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
The HipHop Virtual Machine (HHVM) is a JIT compiler and runtime for PHP. While PHP values are dynamically typed, real programs often have latent types that are useful for optimization once discovered. Some types can be proven through static analysis, but limitations in the ahead-of-time approach leave some types to be discovered at run time. And even though many values have latent types, PHP programs can also contain polymorphic variables and expressions, which must be handled without catastrophic slowdown. HHVM discovers latent types by structuring its JIT around the concept of a tracelet. A tracelet is approximately a basic block specialized for a particular set of run-time types for its input values. Tracelets allow HHVM to exactly and efficiently learn the types observed by the program, while using a simple compiler. This paper shows that this approach enables HHVM to achieve high levels of performance, without sacrificing compatibility or interactivity.
[Software notations and tools, Software and its engineering, Compilers]
Validation of memory accesses through symbolic analyses
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
The C programming language does not prevent out-of-bounds memory accesses. There exist several techniques to secure C programs; however, these methods tend to slow down these programs substantially, because they populate the binary code with runtime checks. To deal with this problem, we have designed and tested two static analyses - symbolic region and range analysis - which we combine to remove the majority of these guards. In addition to the analyses themselves, we bring two other contributions. First, we describe live range splitting strategies that improve the efficiency and the precision of our analyses. Secondly, we show how to deal with integer overflows, a phenomenon that can compromise the correctness of static algorithms that validate memory accesses. We validate our claims by incorporating our findings into AddressSanitizer. We generate SPEC CINT 2006 code that is 17% faster and 9% more energy efficient than the code produced originally by this tool. Furthermore, our approach is 50% more effective than Pentagons, a state-of-the-art analysis to sanitize memory accesses.
[Software notations and tools, Software and its engineering, Compilers]
Abstract semantic differencing via speculative correlation
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
We address the problem of computing semantic differences between a program and a patched version of the program. Our goal is to obtain a precise characterization of the difference between program versions, or establish their equivalence. We focus on infinite-state numerical programs, and use abstract interpretation to compute an over-approximation of program differences. Computing differences and establishing equivalence under abstraction requires abstracting relationships between variables in the two programs. Towards that end, we use a correlating abstract domain to compute a sound approximation of these relationships which captures semantic difference. This approximation can be computed over any interleaving of the two programs. However, the choice of interleaving can significantly affect precision. We present a speculative search algorithm that aims to find an interleaving of the two programs with minimal abstract semantic difference. This method is unique as it allows the analysis to dynamically alternate between several interleavings. We have implemented our approach and applied it to real-world examples including patches from Git, GNU Coreutils, as well as a few handpicked patches from the Linux kernel and the Mozilla Firefox web browser. Our evaluation shows that we compute precise approximations of semantic differences, and report few false differences.
[Theory of computation, Semantics and reasoning, Program semantics, Program reasoning, Program analysis]
Efficient subcubic alias analysis for C
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Inclusion-based alias analysis for C can be formulated as a context-free language (CFL) reachability problem. It is well known that the traditional cubic CFL-reachability algorithm does not scale well in practice. We present a highly scalable and efficient CFL-reachability-based alias analysis for C. The key novelty of our algorithm is to propagate reachability information along only original graph edges and bypass a large portion of summary edges, while the traditional CFL-reachability algorithm propagates along all summary edges. We also utilize the Four Russians' Trick - a key enabling technique in the subcubic CFL-reachability algorithm - in our alias analysis. We have implemented our subcubic alias analysis and conducted extensive experiments on widely-used C programs from the pointer analysis literature. The results demonstrate that our alias analysis scales extremely well in practice. In particular, it can analyze the recent Linux kernel (which consists of 10M SLOC) in about 30 seconds.
[Theory of computation, Semantics and reasoning, Program semantics, Software notations and tools, Program reasoning, Program analysis, Software and its engineering, Compilers]
Static analysis for independent app developers
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Mobile app markets have lowered the barrier to market entry for software producers. As a consequence, an increasing number of independent app developers offer their products, and recent platforms such as the MIT App Inventor and Microsoft's TouchDevelop enable even lay programmers to develop apps and distribute them in app markets. A major challenge in this distribution model is to ensure the quality of apps. Besides the usual sources of software errors, mobile apps are susceptible to errors caused by the non-determinism of an event-based execution model, a volatile environment, diverse hardware, and others. Many of these errors are difficult to detect during testing, especially for independent app developers, who are not supported by test teams and elaborate test infrastructures. To address this problem, we propose a static program analysis that captures the specifics of mobile apps and is efficient enough to provide feedback during the development process. Experiments involving 51,456 published TouchDevelop scripts show that our analysis analyzes 98% of the scripts in under a minute, and five seconds on average. Manual inspection of the analysis results for a selection of all scripts shows that most of the alarms are real errors.
[Cross-computing tools and techniques, Extra-functional properties, Program analysis, Software reliability, Theory of computation, Semantics and reasoning, Program semantics, Program reasoning, Reliability, General and reference, Software organization and properties, Software and its engineering]
ASPIRE: exploiting asynchronous parallelism in iterative algorithms using a relaxed consistency based DSM
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Many vertex-centric graph algorithms can be expressed using asynchronous parallelism by relaxing certain read-after-write data dependences and allowing threads to compute vertex values using stale (i.e., not the most recent) values of their neighboring vertices. We observe that on distributed shared memory systems, by converting synchronous algorithms into their asynchronous counterparts, algorithms can be made tolerant to high inter-node communication latency. However, high inter-node communication latency can lead to excessive use of stale values causing an increase in the number of iterations required by the algorithms to converge. Although by using bounded staleness we can restrict the slowdown in the rate of convergence, this also restricts the ability to tolerate communication latency. In this paper we design a relaxed memory consistency model and consistency protocol that simultaneously tolerate communication latency and minimize the use of stale values. This is achieved via a coordinated use of best effort refresh policy and bounded staleness. We demonstrate that for a range of asynchronous graph algorithms and PDE solvers, on an average, our approach outperforms algorithms based upon: prior relaxed memory models that allow stale values by at least 2.27x; and Bulk Synchronous Parallel (BSP) model by 4.2x. We also show that our approach frequently outperforms GraphLab, a popular distributed graph processing framework.
[Distributed programming languages, General programming languages, Language features, Concurrent programming structures, Computing methodologies, Language types, Software notations and tools, Distributed computing methodologies, Software and its engineering]
Alembic: automatic locality extraction via migration
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
Partitioned Global Address Space (PGAS) environments simplify writing parallel code for clusters because they make data movement implicit - dereferencing global pointers automatically moves data around. However, it does not free the programmer from needing to reason about locality - poor placement of data can lead to excessive and even unnecessary communication. For this reason, modern PGAS languages such as X10, Chapel, and UPC allow programmers to express data-layout constraints and explicitly move computation. This places an extra burden on the programmer, and is less effective for applications with limited or data-dependent locality (e.g., graph analytics). This paper proposes Alembic, a new static analysis that frees programmers from having to manually move computation to exploit locality in PGAS programs. It works by determining regions of code that access the same cluster node, then transforming the code to migrate parts of the execution to increase the proportion of accesses to local data. We implement the analysis and transformation for C++ in LLVM and show that in irregular application kernels, Alembic can achieve 82% of the performance of hand-tuned communication (for comparison, na&#239;ve compiler-generated communication achieves only 13%).
[Distributed programming languages, General programming languages, Language types, Software notations and tools, Concurrent programming languages, Parallel programming languages, Runtime environments, Software and its engineering, Compilers]
Cybertron: pushing the limit on I/O reduction in data-parallel programs
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
I/O reduction has been a major focus in optimizing data-parallel programs for big-data processing. While the current state-of-the-art techniques use static program analysis to reduce I/O, Cybertron proposes a new direction that incorporates runtime mechanisms to push the limit further on I/O reduction. In particular, Cybertron tracks how data is used in the computation accurately at runtime to filter unused data at finer granularity dynamically, beyond what current static-analysis based mechanisms are capable of, and to facilitate a new mechanism called constraint based encoding for more efficient encoding. Cybertron has been implemented and applied to production data-parallel programs; our extensive evaluations on real programs and real data have shown its effectiveness on I/O reduction over the existing mechanisms at reasonable CPU cost, and its improvement on end-to-end performance in various network environments.
[General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Translating imperative code to MapReduce
Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications
ACM SIGPLAN Notices VOLUME 49 ISSUE 10
2014
We present an approach for automatic translation of sequential, imperative code into a parallel MapReduce framework. Automating such a translation is challenging: imperative updates must be translated into a functional MapReduce form in a manner that both preserves semantics and enables parallelism. Our approach works by first translating the input code into a functional representation, with loops succinctly represented by fold operations. Then, guided by rewrite rules, our system searches a space of equivalent programs for an effective MapReduce implementation. The rules include a novel technique for handling irregular loop-carried dependencies using group-by operations to enable greater parallelism. We have implemented our technique in a tool called Mold. It translates sequential Java code into code targeting the Apache Spark runtime. We evaluated Mold on several real-world kernels and found that in most cases Mold generated the desired MapReduce program, even for codes with complex indirect updates.
[Source code generation, General programming languages, Computing methodologies, Parallel computing methodologies, Language types, Software notations and tools, Parallel programming languages, Software and its engineering, Compilers]
Detecting redundant CSS rules in HTML5 applications: a tree rewriting approach
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
HTML5 applications normally have a large set of CSS (Cascading Style Sheets) rules for data display. Each CSS rule consists of a node selector and a declaration block (which assigns values to selected nodes&#039; display attributes). As web applications evolve, maintaining CSS files can easily become problematic. Some CSS rules will be replaced by new ones, but these obsolete (hence redundant) CSS rules often remain in the applications. Not only does this &#8220;bloat&#8221; the applications &#8211; increasing the bandwidth requirement &#8211; but it also significantly increases web browsers&#039; processing time. Most works on detecting redundant CSS rules in HTML5 applications do not consider the dynamic behaviours of HTML5 (specified in JavaScript); in fact, the only proposed method that takes these into account is dynamic analysis, which cannot soundly prove redundancy of CSS rules. In this paper, we introduce an abstraction of HTML5 applications based on monotonic tree-rewriting and study its "redundancy problem". We establish the precise complexity of the problem and various subproblems of practical importance (ranging from P to EXP). In particular, our algorithm relies on an efficient reduction to an analysis of symbolic pushdown systems (for which highly optimised solvers are available), which yields a fast method for checking redundancy in practice. We implemented our algorithm and demonstrated its efficacy in detecting redundant CSS rules in HTML5 applications.
[Theory of computation, Semantics and reasoning, Program semantics]
SATCheck: SAT-directed stateless model checking for SC and TSO
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Writing low-level concurrent code is well known to be challenging and error prone. The widespread deployment of multi-core hardware and the shift towards using low-level concurrent data structures has moved the problem into the mainstream. Finding bugs in such code may require finding a specific bug-revealing thread interleaving out of a huge space of parallel executions. Model-checking is a powerful technique for exhaustively testing code. However, scaling model checking presents a significant challenge. In this paper we present a new and more scalable technique for model checking concurrent code, based on concrete execution. Our technique observes concrete behaviors, builds a model of these behaviors, encodes the model in SAT, and leverages SAT solver technology to find executions that reveal new behaviors. It then runs the new execution, incorporates the newly observed behavior, and repeats the process until it has explored all reachable behaviors. We have implemented a prototype of our approach in the SATCheck tool. Our tool supports both the Total Store Ordering (TSO) and Sequentially Consistent (SC) memory models. We evaulate SATCheck by testing several concurrent data structure implementations and comparing its performance to the original DPOR stateless model checking algorithm implemented in CDSChecker, the source DPOR algorithm implemented in Nidhugg, and CheckFence. Our experiments show that SATCheck scales better than previous approaches while at the same time operating on concrete executions.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Stateless model checking of event-driven applications
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Modern event-driven applications, such as, web pages and mobile apps, rely on asynchrony to ensure smooth end-user experience. Unfortunately, even though these applications are executed by a single event-loop thread, they can still exhibit nondeterministic behaviors depending on the execution order of interfering asynchronous events. As in classic shared-memory concurrency, this nondeterminism makes it challenging to discover errors that manifest only in specific schedules of events. In this work we propose the first stateless model checker for event-driven applications, called R4. Our algorithm systematically explores the nondeterminism in the application and concisely exposes its overall effect, which is useful for bug discovery. The algorithm builds on a combination of three key insights: (i) a dynamic partial order reduction (DPOR) technique for reducing the search space, tailored to the domain of event-driven applications, (ii) conflict-reversal bounding based on a hypothesis that most errors occur with a small number of event reorderings, and (iii) approximate replay of event sequences, which is critical for separating harmless from harmful nondeterminism. We instantiate R4 for the domain of client-side web applications and use it to analyze event interference in a number of real-world programs. The experimental results indicate that the precision and overall exploration capabilities of our system significantly exceed that of existing techniques.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Synthesis of layout engines from relational constraints
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We present an algorithm for synthesizing efficient document layout engines from compact relational specifications. These specifications are compact in that a single specification can produce multiple engines, each for a distinct layout situation, i.e., a different combination of known vs. unknown attributes. Technically, our specifications are relational attribute grammars, while our engines are functional attribute grammars. By synthesizing functions from relational constraints, we obviate the need for constraint solving at runtime, because functional attribute grammars can be easily evaluated according to a fixed schedule, sidestepping the backtracking search performed by constraint solvers. Our experiments show that we can generate layout engines for non-trivial data visualizations, and that our synthesized engines are between 39- and 200-times faster than general-purpose constraint solvers. Relational specifications of layout give rise to synthesis problems that have previously proved intractable. Our algorithm exploits the hierarchical, grammar-based structure of the specification, decomposing the specification into smaller subproblems, which can be tackled with off-the-shelf synthesis procedures. The new synthesis problem then becomes the composition of the functions thus generated into a correct attribute grammar, which might be recursive. We show how to solve this problem by efficient reduction to an SMT problem.
[]
A sound and optimal incremental build system with dynamic dependencies
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Build systems are used in all but the smallest software projects to invoke the right build tools on the right files in the right order. A build system must be sound (after a build, generated files consistently reflect the latest source files) and efficient (recheck and rebuild as few build units as possible). Contemporary build systems provide limited efficiency because they lack support for expressing fine-grained file dependencies. We present a build system called pluto that supports the definition of reusable, parameterized, interconnected builders. When run, a builder notifies the build system about dynamically required and produced files as well as about other builders whose results are needed. To support fine-grained file dependencies, we generalize the traditional notion of time stamps to allow builders to declare their actual requirements on a file&#039;s content. pluto collects the requirements and products of a builder with their stamps in a build summary. This enables pluto to provides provably sound and optimal incremental rebuilding. To support dynamic dependencies, our rebuild algorithm interleaves dependency analysis and builder execution and enforces invariants on the dependency graph through a dynamic analysis. We have developed pluto as a Java API and used it to implement more than 25 builders. We describe our experience with migrating a larger Ant build script to pluto and compare the respective build times.
[Management of computing and information systems, Project and people management, Software creation and management, Professional topics, Software notations and tools, Software architectures, Software configuration management and version control systems, Software development process management, Software system structures, Social and professional topics, Software organization and properties, Software and its engineering]
FlashMeta: a framework for inductive program synthesis
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Inductive synthesis, or programming-by-examples (PBE) is gaining prominence with disruptive applications for automating repetitive tasks in end-user programming. However, designing, developing, and maintaining an effective industrial-quality inductive synthesizer is an intellectual and engineering challenge, requiring 1-2 man-years of effort. Our novel observation is that many PBE algorithms are a natural fall-out of one generic meta-algorithm and the domain-specific properties of the operators in the underlying domain-specific language (DSL). The meta-algorithm propagates example-based constraints on an expression to its subexpressions by leveraging associated witness functions, which essentially capture the inverse semantics of the underlying operator. This observation enables a novel program synthesis methodology called data-driven domain-specific deduction (D4), where domain-specific insight, provided by the DSL designer, is separated from the synthesis algorithm. Our FlashMeta framework implements this methodology, allowing synthesizer developers to generate an efficient synthesizer from the mere DSL definition (if properties of the DSL operators have been modeled). In our case studies, we found that 10+ existing industrial-quality mass-market applications based on PBE can be cast as instances of D4. Our evaluation includes reimplementation of some prior works, which in FlashMeta become more efficient, maintainable, and extensible. As a result, FlashMeta-based PBE tools are deployed in several industrial products, including Microsoft PowerShell 3.0 for Windows 10, Azure Operational Management Suite, and Microsoft Cortana digital assistant.
[Software creation and management, Reusability, Software notations and tools, Software development techniques, Software libraries and repositories, Software and its engineering]
Scrap your boilerplate with object algebras
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Traversing complex Abstract Syntax Trees (ASTs) typically requires large amounts of tedious boilerplate code. For many operations most of the code simply walks the structure, and only a small portion of the code implements the functionality that motivated the traversal in the first place. This paper presents a type-safe Java framework called Shy that removes much of this boilerplate code. In Shy object algebras are used to describe complex and extensible AST structures. Using Java annotations Shy generates generic boilerplate code for various types of traversals. For a concrete traversal, users of Shy can then inherit from the generated code and override only the interesting cases. Consequently, the amount of code that users need to write is significantly smaller. Moreover, traversals using the Shy framework are also much more structure shy, becoming more adaptive to future changes or extensions to the AST structure. To prove the effectiveness of the approach, we applied Shy in the implementation of a domain-specific questionnaire language. Our results show that for a large number of traversals there was a significant reduction in the amount of user-defined code.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Language types, Software notations and tools, Program constructs, Software and its engineering]
Conditionally correct superoptimization
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
The aggressive optimization of heavily used kernels is an important problem in high-performance computing. However, both general purpose compilers and highly specialized tools such as superoptimizers often do not have sufficient static knowledge of restrictions on program inputs that could be exploited to produce the very best code. For many applications, the best possible code is conditionally correct: the optimized kernel is equal to the code that it replaces only under certain preconditions on the kernel&#039;s inputs. The main technical challenge in producing conditionally correct optimizations is in obtaining non-trivial and useful conditions and proving conditional equivalence formally in the presence of loops. We combine abstract interpretation, decision procedures, and testing to yield a verification strategy that can address both of these problems. This approach yields a superoptimizer for x86 that in our experiments produces binaries that are often multiple times faster than those produced by production compilers.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering, Compilers]
Selective control-flow abstraction via jumping
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We present jumping, a form of selective control-flow abstraction useful for improving the scalability of goal-directed static analyses. Jumping is useful for analyzing programs with complex control-flow such as event-driven systems. In such systems, accounting for orderings between certain events is important for precision, yet analyzing the product graph of all possible event orderings is intractable. Jumping solves this problem by allowing the analysis to selectively abstract away control-flow between events irrelevant to a goal query while preserving information about the ordering of relevant events. We present a framework for designing sound jumping analyses and create an instantiation of the framework for per- forming precise inter-event analysis of Android applications. Our experimental evaluation showed that using jumping to augment a precise goal-directed analysis with inter-event reasoning enabled our analysis to prove 90&#8211;97% of dereferences safe across our benchmarks.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Automating grammar comparison
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We consider from a practical perspective the problem of checking equivalence of context-free grammars. We present techniques for proving equivalence, as well as techniques for finding counter-examples that establish non-equivalence. Among the key building blocks of our approach is a novel algorithm for efficiently enumerating and sampling words and parse trees from arbitrary context-free grammars; the algorithm supports polynomial time random access to words belonging to the grammar. Furthermore, we propose an algorithm for proving equivalence of context-free grammars that is complete for LL grammars, yet can be invoked on any context-free grammar, including ambiguous grammars. Our techniques successfully find discrepancies between different syntax specifications of several real-world languages, and are capable of detecting fine-grained incremental modifications performed on grammars. Our evaluation shows that our tool improves significantly on the existing available state of the art tools. In addition, we used these algorithms to develop an online tutoring system for grammars that we then used in an undergraduate course on computer language processing. On questions involving grammar constructions, our system was able to automatically evaluate the correctness of 95% of the solutions submitted by students: it disproved 74% of cases and proved 21% of them.
[Software defect analysis, Software creation and management, Software verification and validation, Professional topics, Computing education, Software notations and tools, Formal languages and automata theory, Computing education programs, Information science education, Theory of computation, Software testing and debugging, Formal language definitions, Computer science education, Social and professional topics, Software and its engineering, Compilers]
Reasoning about the POSIX file system: local update and global pathnames
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We introduce a program logic for specifying a core sequential subset of the POSIX file system and for reasoning abstractly about client programs working with the file system. The challenge is to reason about the combination of local directory update and global pathname traversal (including &#039;..&#039; and symbolic links) which may overlap the directories being updated. Existing reasoning techniques are either based on first-order logic and do not scale, or on separation logic and can only handle linear pathnames (no &#039;..&#039; or symbolic links). We introduce fusion logic for reasoning about local update and global pathname traversal, introducing a novel effect frame rule to propagate the effect of a local update on overlapping pathnames. We apply our reasoning to the standard recursive remove utility (rm -r), discovering bugs in well-known implementations.
[Theory of computation, Semantics and reasoning, Program reasoning, Logic]
AutoMO: automatic inference of memory order parameters for C/C++11
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Many concurrent data structures are initially designed for the sequential consistency (SC) memory model. Developers often implement these data structures on real-world systems with weaker memory models by adding sufficient fences to ensure that their implementation on the weak memory model exhibits the same executions as the SC memory model. Recently, the C11 and C++11 standards have added a weak memory model to the C and C++ languages. Developing and debugging code for weak memory models can be extremely challenging. We present AutoMO, a framework to support porting data structures designed for the SC memory model to the C/C++11 memory model. AutoMO provides support across the porting process: (1) it automatically infers initial settings for the memory order parameters, (2) it detects whether a C/C++11 execution is equivalent to some SC execution, and (3) it simplifies traces to make them easier to understand. We have used AutoMO to successfully infer memory order parameters for a range of data structures and to check whether executions of several concurrent data structure implementations are SC.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Computing methodologies, Language types, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Concurrent programming languages, Program reasoning, Formal software verification, Formal methods, Concurrent computing methodologies, General and reference, Software organization and properties, Software and its engineering]
Valor: efficient, software-only region conflict exceptions
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Data races complicate programming language semantics, and a data race is often a bug. Existing techniques detect data races and define their semantics by detecting conflicts between synchronization-free regions (SFRs). However, such techniques either modify hardware or slow programs dramatically, preventing always-on use today. This paper describes Valor, a sound, precise, software-only region conflict detection analysis that achieves high performance by eliminating the costly analysis on each read operation that prior approaches require. Valor instead logs a region&#039;s reads and lazily detects conflicts for logged reads when the region ends. As a comparison, we have also developed FastRCD, a conflict detector that leverages the epoch optimization strategy of the FastTrack data race detector. We evaluate Valor, FastRCD, and FastTrack, showing that Valor dramatically outperforms FastRCD and FastTrack. Valor is the first region conflict detector to provide strong semantic guarantees for racy program executions with under 2X slowdown. Overall, Valor advances the state of the art in always-on support for strong behavioral guarantees for data races.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software notations and tools, Software and its engineering, Compilers]
Automatic memory reclamation for lock-free data structures
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Lock-free data-structures are widely employed in practice, yet designing lock-free memory reclamation for them is notoriously difficult. In particular, all known lock-free reclamation schemes are ``manual&#039;&#039; in the sense that the developer has to specify when nodes have retired and may be reclaimed. Retiring nodes adequately is non-trivial and often requires the modification of the original lock-free algorithm. In this paper we present an automatic lock-free reclamation scheme for lock-free data-structures in the spirit of a mark-sweep garbage collection. The proposed algorithm works with any normalized lock-free algorithm and with no need for the programmer to retire nodes or make changes to the algorithm. Evaluation of the proposed scheme on a linked-list and a hash table shows that it performs similarly to the best manual (lock-free) memory reclamation scheme.
[File systems management, Computing methodologies, Language types, Software notations and tools, Contextual software domains, Information systems, Information storage systems, Operating systems, Storage management, Memory management, General programming languages, Concurrent programming languages, Concurrent computing methodologies, Software organization and properties, Software and its engineering]
Protocol-based verification of message-passing parallel programs
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We present ParTypes, a type-based methodology for the verification of Message Passing Interface (MPI) programs written in the C programming language. The aim is to statically verify programs against protocol specifications, enforcing properties such as fidelity and absence of deadlocks. We develop a protocol language based on a dependent type system for message-passing parallel programs, which includes various communication operators, such as point-to-point messages, broadcast, reduce, array scatter and gather. For the verification of a program against a given protocol, the protocol is first translated into a representation read by VCC, a software verifier for C. We successfully verified several MPI programs in a running time that is independent of the number of processes or other input parameters. This contrasts with alternative techniques, notably model checking and runtime verification, that suffer from the state-explosion problem or that otherwise depend on parameters to the program itself. We experimentally evaluated our approach against state-of-the-art tools for MPI to conclude that our approach offers a scalable solution.
[Software creation and management, Software verification and validation, Software notations and tools, Formal languages and automata theory, Software verification, Theory of computation, Software development process management, Semantics and reasoning, Concurrent programming languages, Program reasoning, Logic, Formal methods, Software organization and properties, Software and its engineering, Cross-computing tools and techniques, Software functional properties, Computing methodologies, Language types, Verification, Program verification, General programming languages, Formal language definitions, Formal software verification, Concurrent computing methodologies, General and reference]
Interactively verifying absence of explicit information flows in Android apps
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
App stores are increasingly the preferred mechanism for distributing software, including mobile apps (Google Play), desktop apps (Mac App Store and Ubuntu Software Center), computer games (the Steam Store), and browser extensions (Chrome Web Store). The centralized nature of these stores has important implications for security. While app stores have unprecedented ability to audit apps, users now trust hosted apps, making them more vulnerable to malware that evades detection and finds its way onto the app store. Sound static explicit information flow analysis has the potential to significantly aid human auditors, but it is handicapped by high false positive rates. Instead, auditors currently rely on a combination of dynamic analysis (which is unsound) and lightweight static analysis (which cannot identify information flows) to help detect malicious behaviors. We propose a process for producing apps certified to be free of malicious explicit information flows. In practice, imprecision in the reachability analysis is a major source of false positive information flows that are difficult to understand and discharge. In our approach, the developer provides tests that specify what code is reachable, allowing the static analysis to restrict its search to tested code. The app hosted on the store is instrumented to enforce the provided specification (i.e., executing untested code terminates the app). We use abductive inference to minimize the necessary instrumentation, and then interact with the developer to ensure that the instrumentation only cuts unreachable code. We demonstrate the effectiveness of our approach in verifying a corpus of 77 Android apps&#8212;our interactive verification process successfully discharges 11 out of the 12 false positives.
[Theory of computation, Semantics and reasoning, Program semantics, Program reasoning, Logic]
ShamDroid: gracefully degrading functionality in the presence of limited resource access
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Given a program whose functionality depends on access to certain external resources, we investigate the question of how to gracefully degrade functionality when a subset of those resources is unavailable. The concrete setting motivating this problem statement is mobile applications, which rely on contextual data (e.g., device identifiers, user location and contacts, etc.) to fulfill their functionality. In particular, we focus on the Android platform, which mediates access to resources via an installation-time permission model. On the one hand, granting an app the permission to access a resource (e.g., the device ID) entails privacy threats (e.g., releasing the device ID to advertising servers). On the other hand, denying access to a resource could render the app useless (e.g., if inability to read the device ID is treated as an error state). Our goal is to specialize an existing Android app in such a way that it is disabled from accessing certain sensitive resources (or contextual data) as specified by the user, while still being able to execute functionality that does not depend on those resources. We present ShamDroid, a program transformation algorithm, based on specialized forms of program slicing, backwards static analysis and constraint solving, that enables the use of Android apps with partial permissions. We rigorously state the guarantees provided by ShamDroid w.r.t. functionality maximization. We provide an evaluation over the top 500 Google Play apps and report on an extensive comparative evaluation of ShamDroid against three other state-of-the-art solutions (APM, XPrivacy, and Google App Ops) that mediate resource access at the system (rather than app) level. ShamDroid performs better than all of these tools by a significant margin, leading to abnormal behavior in only 1 out of 27 apps we manually investigated, compared to the other solutions, which cause crashes and abnormalities in 9 or more of the apps. This demonstrates the importance of performing app-sensitive mocking.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program semantics, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Scalable race detection for Android applications
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We present a complete end-to-end dynamic analysis system for finding data races in mobile Android applications. The capabilities of our system significantly exceed the state of the art: our system can analyze real-world application interactions in minutes rather than hours, finds errors inherently beyond the reach of existing approaches, while still (critically) reporting very few false positives. Our system is based on three key concepts: (i) a thorough happens-before model of Android-specific concurrency, (ii) a scalable analysis algorithm for efficiently building and querying the happens-before graph, and (iii) an effective set of domain-specific filters that reduce the number of reported data races by several orders of magnitude. We evaluated the usability and performance of our system on 354 real-world Android applications (e.g., Facebook). Our system analyzes a minute of end-user interaction with the application in about 24 seconds, while current approaches take hours to complete. Inspecting the results for 8 large open-source applications revealed 15 harmful bugs of diverse kinds. Some of the bugs we reported were confirmed and fixed by developers.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Versatile yet lightweight record-and-replay for Android
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Recording and replaying the execution of smartphone apps is useful in a variety of contexts, from reproducing bugs to profiling and testing. Achieving effective record-and-replay is a balancing act between accuracy and overhead. On smartphones, the act is particularly complicated, because smartphone apps receive a high-bandwidth stream of input (e.g., network, GPS, camera, microphone, touchscreen) and concurrency events, but the stream has to be recorded and replayed with minimal overhead, to avoid interfering with app execution. Prior record-and-replay approaches have focused on replaying machine instructions or system calls, which is not a good fit on smartphones. We propose a novel, stream-oriented record-and-replay approach which achieves high-accuracy and low-overhead by aiming at a sweet spot: recording and replaying sensor and network input, event schedules, and inter-app communication via intents. To demonstrate the versatility of our approach, we have constructed a tool named VALERA that supports record-and-replay on the Android platform. VALERA works with apps running directly on the phone, and does not require access to the app source code. Through an evaluation on 50 popular Android apps, we show that: VALERA&#039;s replay fidelity far exceeds current record-and-replay approaches for Android; VALERA&#039;s precise timing control and low overhead (about 1% for either record or replay) allows it to replay high-throughput, timing-sensitive apps such as video/audio capture and recognition; and VALERA&#039;s support for event schedule replay enables the construction of useful analyses, such as reproducing event-driven race bugs.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Declarative fence insertion
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Previous work has shown how to insert fences that enforce sequential consistency. However, for many concurrent algorithms, sequential consistency is unnecessarily strong and can lead to high execution overhead. The reason is that, often, correctness relies on the execution order of a few specific pairs of instructions. Algorithm designers can declare those execution orders and thereby enable memory-model-independent reasoning about correctness and also ease implementation of algorithms on multiple platforms. The literature has examples of such reasoning, while tool support for enforcing the orders has been lacking until now. In this paper we present a declarative approach to specify and enforce execution orders. Our fence insertion algorithm first identifies the execution orders that a given memory model enforces automatically, and then inserts fences that enforce the rest. Our benchmarks include three off-the-shelf transactional memory algorithms written in C/C++ for which we specify suitable execution orders. For those benchmarks, our experiments with the x86 and ARMv7 memory models show that our tool inserts fences that are competitive with those inserted by the original authors. Our tool is the first to insert fences into transactional memory algorithms and it solves the long-standing problem of how to easily port such algorithms to a novel memory model.
[Theory of computation, Semantics and reasoning, Operating systems, Program semantics, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers, Process management]
Finding deep compiler bugs via guided stochastic program mutation
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Compiler testing is important and challenging. Equivalence Modulo Inputs (EMI) is a recent promising approach for compiler validation. It is based on mutating the unexecuted statements of an existing program under some inputs to produce new equivalent test programs w.r.t. these inputs. Orion is a simple realization of EMI by only randomly deleting unexecuted statements. Despite its success in finding many bugs in production compilers, Orion&#8217;s effectiveness is still limited by its simple, blind mutation strategy. To more effectively realize EMI, this paper introduces a guided, advanced mutation strategy based on Bayesian optimization. Our goal is to generate diverse programs to more thoroughly exercise compilers. We achieve this with two techniques: (1) the support of both code deletions and insertions in the unexecuted regions, leading to a much larger test program space; and (2) the use of an objective function that promotes control-flow-diverse programs for guiding Markov Chain Monte Carlo (MCMC) optimization to explore the search space. Our technique helps discover deep bugs that require elaborate mutations. Our realization, Athena, targets C compilers. In 19 months, Athena has found 72 new bugs &#8212; many of which are deep and important bugs &#8212; in GCC and LLVM. Developers have confirmed all 72 bugs and fixed 68 of them.
[Software defect analysis, Software creation and management, Software testing and debugging, Information storage systems, Software verification and validation, General programming languages, Language types, Information retrieval, Software notations and tools, Software and its engineering, Information systems]
Vectorization of apply to reduce interpretation overhead of R
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
R is a popular dynamic language designed for statistical computing. Despite R&#039;s huge user base, the inefficiency in R&#039;s language implementation becomes a major pain-point in everyday use as well as an obstacle to apply R to solve large scale analytics problems. The two most common approaches to improve the performance of dynamic languages are: implementing more efficient interpretation strategies and extending the interpreter with Just-In-Time (JIT) compiler. However, both approaches require significant changes to the interpreter, and complicate the adoption by development teams as a result. This paper presents a new approach to improve execution efficiency of R programs by vectorizing the widely used Apply class of operations. Apply accepts two parameters: a function and a collection of input data elements. The standard implementation of Apply iteratively invokes the input function with each element in the data collection. Our approach combines data transformation and function vectorization to convert the looping-over-data execution of the standard Apply into a single invocation of a vectorized function that contains a sequence of vector operations over the input data. This conversion can significantly speed-up the execution of Apply operations in R by reducing the number of interpretation steps. We implemented the vectorization transformation as an R package. To enable the optimization, all that is needed is to invoke the package, and the user can use a normal R interpreter without any changes. The evaluation shows that the proposed method delivers significant performance improvements for a collection of data analysis algorithm benchmarks. This is achieved without any native code generation and using only a single-thread of execution.
[Software notations and tools, Software and its engineering, Compilers]
Synthesizing Java expressions from free-form queries
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We present a new code assistance tool for integrated development environments. Our system accepts as input free-form queries containing a mixture of English and Java, and produces Java code expressions that take the query into account and respect syntax, types, and scoping rules of Java, as well as statistical usage patterns. In contrast to solutions based on code search, the results returned by our tool need not directly correspond to any previously seen code fragment. As part of our system we have constructed a probabilistic context free grammar for Java constructs and library invocations, as well as an algorithm that uses a customized natural language processing tool chain to extract information from free-form text queries. We present the results on a number of examples showing that our technique (1) often produces the expected code fragments, (2) tolerates much of the flexibility of natural language, and (3) can repair incorrect Java expressions that use, for example, the wrong syntax or missing arguments.
[Decision support systems, Information systems applications, Expert systems, Information systems]
Accurate profiling in the presence of dynamic compilation
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Many profilers based on bytecode instrumentation yield wrong results in the presence of an optimizing dynamic compiler, either due to not being aware of optimizations such as stack allocation and method inlining, or due to the inserted code disrupting such optimizations. To avoid such perturbations, we present a novel technique to make any profiler implemented at the bytecode level aware of optimizations performed by the dynamic compiler. We implement our approach in a state-of-the-art Java virtual machine and demonstrate its significance with concrete profilers. We quantify the impact of escape analysis on allocation profiling, object life-time analysis, and the impact of method inlining on callsite profiling. We illustrate how our approach enables new kinds of profilers, such as a profiler for non-inlined callsites, and a testing framework for locating performance bugs in dynamic compiler implementations.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software notations and tools, Software and its engineering, Compilers]
Fast, multicore-scalable, low-fragmentation memory allocation through large virtual memory and global data structures
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We demonstrate that general-purpose memory allocation involving many threads on many cores can be done with high performance, multicore scalability, and low memory consumption. For this purpose, we have designed and implemented scalloc, a concurrent allocator that generally performs and scales in our experiments better than other allocators while using less memory, and is still competitive otherwise. The main ideas behind the design of scalloc are: uniform treatment of small and big objects through so-called virtual spans, efficiently and effectively reclaiming free memory through fast and scalable global data structures, and constant-time (modulo synchronization) allocation and deallocation operations that trade off memory reuse and spatial locality without being subject to false sharing.
[File systems management, Information storage systems, Operating systems, Storage management, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Information systems, Software and its engineering, Compilers]
Probability type inference for flexible approximate programming
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
In approximate computing, programs gain efficiency by allowing occasional errors. Controlling the probabilistic effects of this approximation remains a key challenge. We propose a new approach where programmers use a type system to communicate high-level constraints on the degree of approximation. A combination of type inference, code specialization, and optional dynamic tracking makes the system expressive and convenient. The core type system captures the probability that each operation exhibits an error and bounds the probability that each expression deviates from its correct value. Solver-aided type inference lets the programmer specify the correctness probability on only some variables&#8212;program outputs, for example&#8212;and automatically fills in other types to meet these specifications. An optional dynamic type helps cope with complex run-time behavior where static approaches are insufficient. Together, these features interact to yield a high degree of programmer control while offering a strong soundness guarantee. We use existing approximate-computing benchmarks to show how our language, DECAF, maintains a low annotation burden. Our constraint-based approach can encode hardware details, such as finite degrees of reliability, so we also use DECAF to examine implications for approximate hardware design. We find that multi-level architectures can offer advantages over simpler two-level machines and that solver-aided optimization improves efficiency.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Cross-layer memory management for managed language applications
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Performance and energy efficiency in memory have become critically important for a wide range of computing domains. However, it is difficult to control and optimize memory power and performance because these effects depend upon activity across multiple layers of the vertical execution stack. To address this challenge, we construct a novel and collaborative framework that employs object placement, cross-layer communication, and page-level management to effectively distribute application objects in the DRAM hardware to achieve desired power/performance goals. In this work, we describe the design and implementation of our framework, which is the first to integrate automatic object profiling and analysis at the application layer with fine-grained management of memory hardware resources in the operating system. We demonstrate the utility of our framework by employing it to more effectively control memory power consumption. We design a custom memory-intensive workload to show the potential of our approach. Next, we develop sampling and profiling-based analyses and modify the code generator in the HotSpot VM to understand object usage patterns and automatically determine and control the placement of hot and cold objects in a partitioned VM heap. This information is communicated to the operating system, which uses it to map the logical application pages to the appropriate DRAM ranks according to user-defined provisioning goals. We evaluate our framework and find that it achieves our test goal of significant DRAM energy savings across a variety of workloads, without any source code modifications or recompilations.
[File systems management, Information storage systems, Operating systems, Storage management, Memory management, Software notations and tools, Contextual software domains, Software organization and properties, Software and its engineering, Compilers, Information systems]
Static analysis of event-driven Node.js JavaScript applications
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Many JavaScript programs are written in an event-driven style. In particular, in server-side Node.js applications, operations involving sockets, streams, and files are typically performed in an asynchronous manner, where the execution of listeners is triggered by events. Several types of programming errors are specific to such event-based programs (e.g., unhandled events, and listeners that are registered too late). We present the event-based call graph, a program representation that can be used to detect bugs related to event handling. We have designed and implemented three analyses for constructing event-based call graphs. Our results show that these analyses are capable of detecting problems reported on StackOverflow. Moreover, we show that the number of false positives reported by the analysis on a suite of small Node.js applications is manageable.
[Theory of computation, Semantics and reasoning, Program semantics]
EXPLORER : query- and demand-driven exploration of interprocedural control flow properties
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
This paper describes a general framework and its implementation in a tool called EXPLORER for statically answering a class of interprocedural control flow queries about Java programs. EXPLORER allows users to formulate queries about feasible callstack configurations using regular expressions, and it employs a precise, demand-driven algorithm for answering such queries. Specifically, EXPLORER constructs an automaton A that is iteratively refined until either the language accepted by A is empty (meaning that the query has been refuted) or until no further refinement is possible based on a precise, context-sensitive abstraction of the program. We evaluate EXPLORER by applying it to three different program analysis tasks, namely, (1) analysis of the observer design pattern in Java, (2) identification of a class of performance bugs, and (3) analysis of inter-component communication in Android applications. Our evaluation shows that EXPLORER is both efficient and precise.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Giga-scale exhaustive points-to analysis for Java in under a minute
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Computing a precise points-to analysis for very large Java programs remains challenging despite the large body of research on points-to analysis. Any approach must solve an underlying dynamic graph reachability problem, for which the best algorithms have near-cubic worst-case runtime complexity, and, hence, previous work does not scale to programs with millions of lines of code. In this work, we present a novel approach for solving the field-sensitive points-to problem for Java with the means of (1) a transitive-closure data-structure, and (2) a pre-computed set of potentially matching load/store pairs to accelerate the fix-point calculation. Experimentation on Java benchmarks validates the superior performance of our approach over the standard context-free language reachability implementations. Our approach computes a points-to index for the OpenJDK with over 1.5 billion tuples in under a minute.
[Theory of computation, Semantics and reasoning, Program semantics]
Galois transformers and modular abstract interpreters: reusable metatheory for program analysis
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
The design and implementation of static analyzers has become increasingly systematic. Yet for a given language or analysis feature, it often requires tedious and error prone work to implement an analyzer and prove it sound. In short, static analysis features and their proofs of soundness do not compose well, causing a dearth of reuse in both implementation and metatheory. We solve the problem of systematically constructing static analyzers by introducing Galois transformers: monad transformers that transport Galois connection properties. In concert with a monadic interpreter, we define a library of monad transformers that implement building blocks for classic analysis parameters like context, path, and heap (in)sensitivity. Moreover, these can be composed together independent of the language being analyzed. Significantly, a Galois transformer can be proved sound once and for all, making it a reusable analysis component. As new analysis features and abstractions are developed and mixed in, soundness proofs need not be reconstructed, as the composition of a monad transformer stack is sound by virtue of its constituents. Galois transformers provide a viable foundation for reusable and composable metatheory for program analysis. Finally, these Galois transformers shift the level of abstraction in analysis design and implementation to a level where non-specialists have the ability to synthesize sound analyzers over a number of parameters.
[Theory of computation, Semantics and reasoning, Program semantics]
Learning a strategy for adapting a program analysis via bayesian optimisation
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Building a cost-effective static analyser for real-world programs is still regarded an art. One key contributor to this grim reputation is the difficulty in balancing the cost and the precision of an analyser. An ideal analyser should be adaptive to a given analysis task, and avoid using techniques that unnecessarily improve precision and increase analysis cost. However, achieving this ideal is highly nontrivial, and it requires a large amount of engineering efforts. In this paper we present a new approach for building an adaptive static analyser. In our approach, the analyser includes a sophisticated parameterised strategy that decides, for each part of a given program, whether to apply a precision-improving technique to that part or not. We present a method for learning a good parameter for such a strategy from an existing codebase via Bayesian optimisation. The learnt strategy is then used for new, unseen programs. Using our approach, we developed partially flow- and context-sensitive variants of a realistic C static analyser. The experimental results demonstrate that using Bayesian optimisation is crucial for learning from an existing codebase. Also, they show that among all program queries that require flow- or context-sensitivity, our partially flow- and context-sensitive analysis answers the 75% of them, while increasing the analysis cost only by 3.3x of the baseline flow- and context-insensitive analysis, rather than 40x or more of the fully sensitive version.
[Theory of computation, Semantics and reasoning, Mathematical analysis, Program semantics, Mathematics of computing, Mathematical optimization, Design and analysis of algorithms]
Runtime pointer disambiguation
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
To optimize code effectively, compilers must deal with memory dependencies. However, the state-of-the-art heuristics available in the literature to track memory dependencies are inherently imprecise and computationally expensive. Consequently, the most advanced code transformations that compilers have today are ineffective when applied on real-world programs. The goal of this paper is to solve this conundrum through dynamic disambiguation of pointers. We provide different ways to determine at runtime when two memory locations can overlap. We then produce two versions of a code region: one that is aliasing-free - hence, easy to optimize - and another that is not. Our checks let us safely branch to the optimizable region. We have applied these ideas on Polly-LLVM, a loop optimizer built on top of the LLVM compilation infrastructure. Our experiments indicate that our method is precise, effective and useful: we can disambiguate every pair of pointer in the loop intensive Polybench benchmark suite. The result of this precision is code quality: the binaries we generate are 10% faster than those that Polly-LLVM produces without our optimization, at the -O3 optimization level of LLVM.
[Software notations and tools, Software and its engineering, Compilers]
Performance problems you can fix: a dynamic analysis of memoization opportunities
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Performance bugs are a prevalent problem and recent research proposes various techniques to identify such bugs. This paper addresses a kind of performance problem that often is easy to address but difficult to identify: redundant computations that may be avoided by reusing already computed results for particular inputs, a technique called memoization. To help developers find and use memoization opportunities, we present MemoizeIt, a dynamic analysis that identifies methods that repeatedly perform the same computation. The key idea is to compare inputs and outputs of method calls in a scalable yet precise way. To avoid the overhead of comparing objects at all method invocations in detail, MemoizeIt first compares objects without following any references and iteratively increases the depth of exploration while shrinking the set of considered methods. After each iteration, the approach ignores methods that cannot benefit from memoization, allowing it to analyze calls to the remaining methods in more detail. For every memoization opportunity that MemoizeIt detects, it provides hints on how to implement memoization, making it easy for the developer to fix the performance issue. Applying MemoizeIt to eleven real-world Java programs reveals nine profitable memoization opportunities, most of which are missed by traditional CPU time profilers, conservative compiler optimizations, and other existing approaches for finding performance bugs. Adding memoization as proposed by MemoizeIt leads to statistically significant speedups by factors between 1.04x and 12.93x.
[Software defect analysis, Networks, Cross-computing tools and techniques, Software creation and management, Object oriented languages, Software verification and validation, Language types, Dependable and fault-tolerant systems and networks, Software notations and tools, Computer systems organization, Software testing and debugging, General programming languages, Performance, General and reference, Network performance evaluation, Software and its engineering]
RAIVE: runtime assessment of floating-point instability by vectorization
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Floating point representation has limited precision and inputs to floating point programs may also have errors. Consequently, during execution, errors are introduced, propagated, and accumulated, leading to unreliable outputs. We call this the instability problem. We propose RAIVE, a technique that identifies output variations of a floating point execution in the presence of instability. RAIVE transforms every floating point value to a vector of multiple values &#8211; the values added to create the vector are obtained by introducing artifi- cial errors that are upper bounds of actual errors. The propagation of artificial errors models the propagation of actual errors. When values in vectors result in discrete execution differences (e.g., following different paths), the execution is forked to capture the resulting output variations. Our evaluation shows that RAIVE can precisely capture output variations. Its overhead (340%) is 2.43 times lower than the state of the art
[Theory of computation, Software defect analysis, Software creation and management, Semantics and reasoning, Numerical analysis, Software testing and debugging, Mathematical analysis, Software verification and validation, Program semantics, Mathematics of computing, Software and its engineering]
Automated backward error analysis for numerical code
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Numerical code uses floating-point arithmetic and necessarily suffers from roundoff and truncation errors. Error analysis is the process to quantify such uncertainty in the solution to a problem. Forward error analysis and backward error analysis are two popular paradigms of error analysis. Forward error analysis is more intuitive and has been explored and automated by the programming languages (PL) community. In contrast, although backward error analysis is more preferred by numerical analysts and the foundation for numerical stability, it is less known and unexplored by the PL community. To fill the gap, this paper presents an automated backward error analysis for numerical code to empower both numerical analysts and application developers. In addition, we use the computed backward error results to also compute the condition number, an important quantity recognized by numerical analysts for measuring how sensitive a function is to changes or errors in the input. Experimental results on Intel X87 FPU functions and widely-used GNU C Library functions demonstrate that our analysis is effective at analyzing the accuracy of floating-point programs.
[Numerical analysis, Mathematical analysis, Mathematics of computing, Mathematical software]
Using C language extensions for developing embedded software: a case study
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We report on an industrial case study on developing the embedded software for a smart meter using the C programming language and domain-specific extensions of C such as components, physical units, state machines, registers and interrupts. We find that the extensions help significantly with managing the complexity of the software. They improve testability mainly by supporting hardware-independent testing, as illustrated by low integration efforts. The extensions also do not incur significant overhead regarding memory consumption and performance. Our case study relies on mbeddr, an extensible version of C. mbeddr, in turn, builds on the MPS language workbench which supports modular extension of languages and IDEs.
[Computer systems organization, General programming languages, Embedded and cyber-physical systems, Language types, Software notations and tools, Real-time systems, Software and its engineering, Compilers]
How scale affects structure in Java programs
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Many internal software metrics and external quality attributes of Java programs correlate strongly with program size. This knowledge has been used pervasively in quantitative studies of software through practices such as normalization on size metrics. This paper reports size-related super- and sublinear effects that have not been known before. Findings obtained on a very large collection of Java programs -- 30,911 projects hosted at Google Code as of Summer 2011 -- unveils how certain characteristics of programs vary disproportionately with program size, sometimes even non-monotonically. Many of the specific parameters of nonlinear relations are reported. This result gives further insights for the differences of ``programming in the small&#039;&#039; vs. ``programming in the large.&#039;&#039; The reported findings carry important consequences for OO software metrics, and software research in general: metrics that have been known to correlate with size can now be properly normalized so that all the information that is left in them is size-independent.
[Cross-computing tools and techniques, Metrics, General and reference]
Use at your own risk: the Java unsafe API in the wild
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Java is a safe language. Its runtime environment provides strong safety guarantees that any Java application can rely on. Or so we think. We show that the runtime actually does not provide these guarantees---for a large fraction of today&#039;s Java code. Unbeknownst to many application developers, the Java runtime includes a "backdoor" that allows expert library and framework developers to circumvent Java&#039;s safety guarantees. This backdoor is there by design, and is well known to experts, as it enables them to write high-performance "systems-level" code in Java. For much the same reasons that safe languages are preferred over unsafe languages, these powerful---but unsafe---capabilities in Java should be restricted. They should be made safe by changing the language, the runtime system, or the libraries. At the very least, their use should be restricted. This paper is a step in that direction. We analyzed 74 GB of compiled Java code, spread over 86,479 Java archives, to determine how Java&#039;s unsafe capabilities are used in real-world libraries and applications. We found that 25% of Java bytecode archives depend on unsafe third-party Java code, and thus Java&#039;s safety guarantees cannot be trusted. We identify 14 different usage patterns of Java&#039;s unsafe capabilities, and we provide supporting evidence for why real-world code needs these capabilities. Our long-term goal is to provide a foundation for the design of new language features to regain safety in Java.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Approximate computation with outlier detection in Topaz
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We present Topaz, a new task-based language for computations that execute on approximate computing platforms that may occasionally produce arbitrarily inaccurate results. Topaz maps tasks onto the approximate hardware and integrates the generated results into the main computation. To prevent unacceptably inaccurate task results from corrupting the main computation, Topaz deploys a novel outlier detection mechanism that recognizes and precisely reexecutes outlier tasks. Outlier detection enables Topaz to work effectively with approximate hardware platforms that have complex fault characteristics, including platforms with bit pattern dependent faults (in which the presence of faults may depend on values stored in adjacent memory cells). Our experimental results show that, for our set of benchmark applications, outlier detection enables Topaz to deliver acceptably accurate results (less than 1% error) on our target approximate hardware platforms. Depending on the application and the hardware platform, the overall energy savings range from 5 to 13 percent. Without outlier detection, only one of the applications produces acceptably accurate results.
[General programming languages, Language types, Software notations and tools, Software and its engineering]
Remote-scope promotion: clarified, rectified, and verified
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Modern accelerator programming frameworks, such as OpenCL, organise threads into work-groups. Remote-scope promotion (RSP) is a language extension recently proposed by AMD researchers that is designed to enable applications, for the first time, both to optimise for the common case of intra-work-group communication (using memory scopes to provide consistency only within a work-group) and to allow occasional inter-work-group communication (as required, for instance, to support the popular load-balancing idiom of work stealing). We present the first formal, axiomatic memory model of OpenCL extended with RSP. We have extended the Herd memory model simulator with support for OpenCL kernels that exploit RSP, and used it to discover bugs in several litmus tests and a work-stealing queue, that have been used previously in the study of RSP. We have also formalised the proposed GPU implementation of RSP. The formalisation process allowed us to identify bugs in the description of RSP that could result in well-synchronised programs experiencing memory inconsistencies. We present and prove sound a new implementation of RSP that incorporates bug fixes and requires less non-standard hardware than the original implementation. This work, a collaboration between academia and industry, clearly demonstrates how, when designing hardware support for a new concurrent language feature, the early application of formal tools and techniques can help to prevent errors, such as those we have found, from making it into silicon.
[Theory of computation, Computer systems organization, Formal language definitions, Software notations and tools, Parallel architectures, Formal languages and automata theory, Architectures, Software and its engineering]
Incremental computation with names
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Over the past thirty years, there has been significant progress in developing general-purpose, language-based approaches to incremental computation, which aims to efficiently update the result of a computation when an input is changed. A key design challenge in such approaches is how to provide efficient incremental support for a broad range of programs. In this paper, we argue that first-class names are a critical linguistic feature for efficient incremental computation. Names identify computations to be reused across differing runs of a program, and making them first class gives programmers a high level of control over reuse. We demonstrate the benefits of names by presenting Nominal Adapton, an ML-like language for incremental computation with names. We describe how to use Nominal Adapton to efficiently incrementalize several standard programming patterns---including maps, folds, and unfolds---and show how to build efficient, incremental probabilistic trees and tries. Since Nominal Adapton&#039;s implementation is subtle, we formalize it as a core calculus and prove it is from-scratch consistent, meaning it always produces the same answer as simply re-running the computation. Finally, we demonstrate that Nominal Adapton can provide large speedups over both from-scratch computation and Adapton, a previous state-of-the-art incremental computation system.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Program semantics, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
Checks and balances: constraint solving without surprises in object-constraint programming languages
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Object-constraint programming systems integrate declarative constraint solving with imperative, object-oriented languages, seamlessly providing the power of both paradigms. However, experience with object-constraint systems has shown that giving too much power to the constraint solver opens up the potential for solutions that are surprising and unintended as well as for complex interactions between constraints and imperative code. On the other hand, systems that overly limit the power of the solver, for example by disallowing constraints involving mutable objects, object identity, or polymorphic message sends, run the risk of excluding the core object-oriented features of the language from the constraint part, and consequently not being able to express declaratively a large set of interesting problem solutions. In this paper we present design principles that tame the power of the constraint solver in object-constraint languages to avoid difficult corner cases and surprising solutions while retaining the key features of the approach, including constraints over mutable objects, constraints involving object identity, and constraints on the results of message sends. We present our solution concretely in the context of the Babelsberg object-constraint language framework, providing both an informal description of the resulting language and a formal semantics for a core subset of it. We validate the utility of this semantics with an executable version that allows us to run test programs and to verify that they provide the same results as existing implementations of Babelsberg in JavaScript, Ruby, and Smalltalk.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Optimizing hash-array mapped tries for fast and lean immutable JVM collections
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
The data structures under-pinning collection API (e.g. lists, sets, maps) in the standard libraries of programming languages are used intensively in many applications. The standard libraries of recent Java Virtual Machine languages, such as Clojure or Scala, contain scalable and well-performing immutable collection data structures that are implemented as Hash-Array Mapped Tries (HAMTs). HAMTs already feature efficient lookup, insert, and delete operations, however due to their tree-based nature their memory footprints and the runtime performance of iteration and equality checking lag behind array-based counterparts. This particularly prohibits their application in programs which process larger data sets. In this paper, we propose changes to the HAMT design that increase the overall performance of immutable sets and maps. The resulting general purpose design increases cache locality and features a canonical representation. It outperforms Scala&#8217;s and Clojure&#8217;s data structure implementations in terms of memory footprint and runtime efficiency of iteration (1.3&#8211;6.7x) and equality checking (3&#8211;25.4x).
[Information storage systems, Record storage alternatives, Record storage systems, Information systems]
Automating ad hoc data representation transformations
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
To maximize run-time performance, programmers often specialize their code by hand, replacing library collections and containers by custom objects in which data is restructured for efficient access. However, changing the data representation is a tedious and error-prone process that makes it hard to test, maintain and evolve the source code. We present an automated and composable mechanism that allows programmers to safely change the data representation in delimited scopes containing anything from expressions to entire class definitions. To achieve this, programmers define a transformation and our mechanism automatically and transparently applies it during compilation, eliminating the need to manually change the source code. Our technique leverages the type system in order to offer correctness guarantees on the transformation and its interaction with object-oriented language features, such as dynamic dispatch, inheritance and generics. We have embedded this technique in a Scala compiler plugin and used it in four very different transformations, ranging from improving the data layout and encoding, to retrofitting specialization and value class status, and all the way to collection deforestation. On our benchmarks, the technique obtained speedups between 1.8x and 24.5x.
[Information storage systems, Record storage alternatives, Record storage systems, Information systems]
Tracing vs. partial evaluation: comparing meta-compilation approaches for self-optimizing interpreters
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs. This study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object-oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.
[Software notations and tools, Software and its engineering, Compilers]
Effectively mapping linguistic abstractions for message-passing concurrency to threads on the Java virtual machine
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Efficient mapping of message passing concurrency (MPC) abstractions to Java Virtual Machine (JVM) threads is critical for performance, scalability, and CPU utilization; but tedious and time consuming to perform manually. In general, this mapping cannot be found in polynomial time, but we show that by exploiting the local characteristics of MPC abstractions and their communication patterns this mapping can be determined effectively. We describe our MPC abstraction to thread mapping technique, its realization in two frame- works (Panini and Akka), and its rigorous evaluation using several benchmarks from representative MPC frameworks. We also compare our technique against four default mapping techniques: thread-all, round-robin-task-all, random-task-all and work-stealing. Our evaluation shows that our mapping technique can improve the performance by 30%-60% over default mapping techniques. These improvements are due to a number of challenges addressed by our technique namely: i) balancing the computations across JVM threads, ii) reducing the communication overheads, iii) utilizing information about cache locality, and iv) mapping MPC abstractions to threads in a way that reduces the contention between JVM threads.
[General programming languages, Language features, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Partial evaluation of machine code
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
This paper presents an algorithm for off-line partial evaluation of machine code. The algorithm follows the classical two-phase approach of binding-time analysis (BTA) followed by specialization. However, machine-code partial evaluation presents a number of new challenges, and it was necessary to devise new techniques for use in each phase. - Our BTA algorithm makes use of an instruction-rewriting method that ``decouples&#039;&#039; multiple updates performed by a single instruction. This method counters the cascading imprecision that would otherwise occur with a more naive approach to BTA. - Our specializer specializes an explicit representation of the semantics of an instruction, and emits residual code via machine-code synthesis. Moreover, to create code that allows the stack and heap to be at different positions at run-time than at specialization-time, the specializer represents specialization-time addresses using symbolic constants, and uses a symbolic state for specialization. Our experiments show that our algorithm can be used to specialize binaries with respect to commonly used inputs to produce faster binaries, as well as to extract an executable component from a bloated binary.
[Theory of computation, Semantics and reasoning, Program semantics]
A co-contextual formulation of type rules and its application to incremental type checking
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Type rules associate types to expressions given a typing context. As the type checker traverses the expression tree top-down, it extends the typing context with additional context information that becomes available. This way, the typing context coordinates type checking in otherwise independent subexpressions, which inhibits parallelization and incrementalization of type checking. We propose a co-contextual formulation of type rules that only take an expression as input and produce a type and a set of context requirements. Co-contextual type checkers traverse an expression tree bottom-up and merge context requirements of independently checked subexpressions. We describe a method for systematically constructing a co-contextual formulation of type rules from a regular context-based formulation and we show how co-contextual type rules give rise to incremental type checking. Using our method, we derive incremental type checkers for PCF and for extensions that introduce records, parametric polymorphism, and subtyping. Our performance evaluation shows that co-contextual type checking has performance comparable to standard context-based type checking, and incrementalization can improve performance significantly.
[Theory of computation, Models of computation, Semantics and reasoning, Program semantics, Program reasoning, Logic, Computability]
Disjointness domains for fine-grained aliasing
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Aliasing is crucial for supporting useful implementation patterns, but it makes reasoning about programs difficult. To deal with this problem, numerous type-based aliasing control mechanisms have been proposed, expressing properties such as uniqueness. Uniqueness, however, is black-and-white: either a reference is unique or it can be arbitrarily aliased; and global: excluding aliases throughout the entire system, making code brittle to changing requirements. Disjointness domains, a new approach to alias control, address this problem by enabling more graduations between uniqueness and arbitrary reference sharing. They allow expressing aliasing constraints local to a certain set of variables (either stack variables or fields) for instance that no aliasing occurs between variables within some set of variables but between such sets or the opposite, that aliasing occurs within that set but not between different sets. A hierarchy of disjointness domains controls the flow of references through a program, helping the programmer reason about disjointness and enforce local alias invariants. The resulting system supports fine-grained control of aliasing between both variables and objects, making aliasing explicit to programmers, compilers, and tooling. This paper presents a formal account of disjointness domains along with examples. Disjointness domains provide novel means of expressing may-alias kinds of constraints, which may prove useful in compiler optimisation and verification.
[Theory of computation, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
The chemical approach to typestate-oriented programming
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
We study a novel approach to typestate-oriented programming based on the chemical metaphor: state and operations on objects are molecules of messages and state transformations are chemical reactions. This approach allows us to investigate typestate in an inherently concurrent setting, whereby objects can be accessed and modified concurrently by several processes, each potentially changing only part of their state. We introduce a simple behavioral type theory to express in a uniform way both the private and the public interfaces of objects, to describe and enforce structured object protocols consisting of possibilities, prohibitions, and obligations, and to control object sharing.
[Software creation and management, Language features, Software verification and validation, Software notations and tools, Software verification, Theory of computation, Software development process management, Semantics and reasoning, Concurrent programming languages, Program reasoning, Formal methods, Software organization and properties, Software and its engineering, Cross-computing tools and techniques, Software functional properties, Computing methodologies, Language types, Verification, Program constructs, Program verification, General programming languages, Formal software verification, Concurrent computing methodologies, General and reference]
Customizable gradual polymorphic effects for Scala
Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 50 ISSUE 10
2015
Despite their obvious advantages in terms of static reasoning, the adoption of effect systems is still rather limited in practice. Recent advances such as generic effect systems, lightweight effect polymorphism, and gradual effect checking, all represent promising steps towards making effect systems suitable for widespread use. However, no existing system combines these approaches: the theory of gradual polymorphic effects has not been developed, and there are no implementations of gradual effect checking. In addition, a limiting factor in the adoption of effect systems is their unsuitability for localized and customized effect disciplines. This paper addresses these issues by presenting the first implementation of gradual effect checking, for Scala, which supports both effect polymorphism and a domain-specific language called Effscript to declaratively define and customize effect disciplines. We report on the theory, implementation, and practical application of the system.
[Theory of computation, General programming languages, Language features, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering]
A compiler for throughput optimization of graph algorithms on GPUs
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Writing high-performance GPU implementations of graph algorithms can be challenging. In this paper, we argue that three optimizations called throughput optimizations are key to high-performance for this application class. These optimizations describe a large implementation space making it unrealistic for programmers to implement them by hand.   To address this problem, we have implemented these optimizations in a compiler that produces CUDA code from an intermediate-level program representation called IrGL. Compared to state-of-the-art handwritten CUDA implementations of eight graph applications, code generated by the IrGL compiler is up to 5.95x times faster (median 1.4x) for five applications and never more than 30% slower for the others. Throughput optimizations contribute an improvement up to 4.16x (median 1.4x) to the performance of unoptimized IrGL code.
[General programming languages, Language features, Software notations and tools, Software and its engineering, Compilers]
Automatic parallelization of pure method calls via conditional future synthesis
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
We introduce a novel approach for using futures to automatically parallelize the execution of pure method calls. Our approach is built on three new techniques to address the challenge of automatic parallelization via future synthesis: candidate future synthesis, parallelism benefit analysis, and threshold expression synthesis. During <em>candidate future synthesis</em>, our system annotates pure method calls as async expressions and synthesizes a parallel program with future objects and their type declarations. Next, the system performs a <em>parallel benefit analysis</em> to determine which async expressions may need to be executed sequentially due to overhead reasons, based on execution profile information collected from multiple test inputs. Finally, <em>threshold expression synthesis</em> uses the output from parallelism benefit analysis to synthesize predicate expressions that can be used to determine at runtime if a specific pure method call should be executed sequentially or in parallel. We have implemented our approach, and the results obtained from an experimental evaluation of the complete system on a range of sequential Java benchmarks are very encouraging. Our evaluation shows that our approach can provide significant parallel speedups of up to 7.4Ã (geometric mean of 3.69Ã) relative to the sequential programs when using 8 processor cores, with zero programmer effort beyond providing the sequential program and test cases for parallelism benefit analysis.
[Theory of computation, Semantics and reasoning, General programming languages, Program semantics, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
Parallel incremental whole-program optimizations for Scala.js
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Whole-program optimizations are powerful tools that can dramatically improve performance, size and other aspects of programs. Because they depend on global knowledge, they must typically be reapplied to the whole program when small changes are made, which makes them too slow for the development cycle. This is an issue for some environments that require, or benefit a lot from, whole-program optimizations, such as compilation to JavaScript or to the Dalvik VM, because their development cycle is slowed down either by the lack of optimizations, or by the time spent on applying them.   We present a new approach to designing incremental whole-program optimizers for object-oriented and functional languages: when part of a program changes, only the portions affected by the changes are reoptimized. An incremental optimizer using this approach for Scala.js, the Scala to JavaScript compiler, demonstrates speedups from 10x to 100x compared to its batch version. As a result, the optimizer&#039;s running time becomes insignificant compared to separate compilation, making it fit for use on every compilation run during the development cycle. We also show how to parallelize the incremental algorithm to take advantage of multicore hardware.
[Software notations and tools, Software and its engineering, Compilers]
Semantics-based program verifiers for all languages
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
We present a language-independent verification framework that can be instantiated with an operational semantics to automatically generate a program verifier. The framework treats both the operational semantics and the program correctness specifications as reachability rules between matching logic patterns, and uses the sound and relatively complete reachability logic proof system to prove the specifications using the semantics. We instantiate the framework with the semantics of one academic language, KernelC, as well as with three recent semantics of real-world languages, C, Java, and JavaScript, developed independently of our verification infrastructure. We evaluate our approach empirically and show that the generated program verifiers can check automatically the full functional correctness of challenging heap-manipulating programs implementing operations on list and tree data structures, like AVL trees. This is the first approach that can turn the operational semantics of real-world languages into correct-by-construction automatic verifiers.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program semantics, Program reasoning, Formal software verification, Formal methods, Logic, General and reference, Software organization and properties, Software and its engineering]
Hoare-style specifications as correctness conditions for non-linearizable concurrent objects
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Designing efficient concurrent objects often requires abandoning the standard specification technique of linearizability in favor of more relaxed correctness conditions. However, the variety of alternatives makes it difficult to choose which condition to employ, and how to compose them when using objects specified by different conditions.   In this work, we propose a uniform alternative in the form of Hoare logic, which can explicitly capture--in the auxiliary state--the interference of environment threads. We demonstrate the expressiveness of our method by verifying a number of concurrent objects and their clients, which have so far been specified only by non-standard conditions of concurrency-aware linearizability, quiescent, and quantitative quiescent consistency. We report on the implementation of the ideas in an existing Coq-based tool, providing the first mechanized proofs for all the examples in the paper.
[Theory of computation, Semantics and reasoning, Formal language definitions, Software notations and tools, Formal languages and automata theory, Program reasoning, Logic, Software and its engineering]
An operational semantics for C/C++11 concurrency
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
The C/C++11 concurrency model balances two goals: it is relaxed enough to be efficiently implementable and (leaving aside the ``thin-air&#039;&#039; problem) it is strong enough to give useful guarantees to programmers. It is mathematically precise and has been used in verification research and compiler testing. However, the model is expressed in an axiomatic style, as predicates on complete candidate executions. This suffices for computing the set of allowed executions of a small litmus test, but it does not directly support the incremental construction of executions of larger programs. It is also at odds with conventional operational semantics, as used implicitly in the rest of the C/C++ standards.   Our main contribution is the development of an operational model for C/C++11 concurrency. This covers all the features of the previous formalised axiomatic model, and we have a mechanised proof that the two are equivalent, in Isabelle/HOL. We also integrate this semantics with an operational semantics for sequential C (described elsewhere); the combined semantics can incrementally execute programs in a small fragment of C.   Doing this uncovered several new aspects of the C/C++11 model: we show that one cannot build an equivalent operational model that simply follows program order, sequential consistent order, or the synchronises-with order. The first negative result is forced by hardware-observable behaviour, but the latter two are not, and so might be ameliorated by changing C/C++11. More generally, we hope that this work, with its focus on incremental construction of executions, will inform the future design of new concurrency models.
[Theory of computation, Semantics and reasoning, Program semantics]
Modeling and analysis of remote memory access programming
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Recent advances in networking hardware have led to a new generation of Remote Memory Access (RMA) networks in which processors from different machines can communicate directly, bypassing the operating system and allowing higher performance. Researchers and practitioners have proposed libraries and programming models for RMA to enable the development of applications running on these networks, However, the memory models implied by these RMA libraries and languages are often loosely specified, poorly understood, and differ depending on the underlying network architecture and other factors. Hence, it is difficult to precisely reason about the semantics of RMA programs or how changes in the network architecture affect them. We address this problem with the following contributions: (i) a <em>coreRMA</em> language which serves as a common foundation, formalizing the essential characteristics of RMA programming; (ii) complete axiomatic semantics for that language; (iii) integration of our semantics with an existing constraint solver, enabling us to exhaustively generate <em>coreRMA</em> programs (litmus tests) up to a specified bound and check whether the tests satisfy their specification; and (iv) extensive validation of our semantics on real-world RMA systems. We generated and ran 7441 litmus tests using each of the low-level RMA network APIs: DMAPP, VPI Verbs, and Portals 4. Our results confirmed that our model successfully captures behaviors exhibited by these networks. Moreover, we found RMA programs that behave inconsistently with existing documentation, confirmed by network experts. Our work provides an important step towards understanding existing RMA networks, thus influencing the design of future RMA interfaces and hardware.
[Hardware validation, Hardware]
Deriving divide-and-conquer dynamic programming algorithms using solver-aided transformations
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
We introduce a framework allowing domain experts to manipulate computational terms in the interest of deriving better, more efficient implementations.It employs deductive reasoning to generate provably correct efficient implementations from a very high-level specification of an algorithm, and inductive constraint-based synthesis to improve automation. Semantic information is encoded into program terms through the use of refinement types.   In this paper, we develop the technique in the context of a system called Bellmania that uses solver-aided tactics to derive parallel divide-and-conquer implementations of dynamic programming algorithms that have better locality and are significantly more efficient than traditional loop-based implementations. Bellmania includes a high-level language for specifying dynamic programming algorithms and a calculus that facilitates gradual transformation of these specifications into efficient implementations. These transformations formalize the divide-and conquer technique; a visualization interface helps users to interactively guide the process, while an SMT-based back-end verifies each step and takes care of low-level reasoning required for parallelism.   We have used the system to generate provably correct implementations of several algorithms, including some important algorithms from computational biology, and show that the performance is comparable to that of the best manually optimized code.
[]
Speeding up machine-code synthesis
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Machine-code synthesis is the problem of searching for an instruction sequence that implements a semantic specification, given as a formula in quantifier-free bit-vector logic (QFBV). Instruction sets like Intel&#039;s IA-32 have around 43,000 unique instruction schemas; this huge instruction pool, along with the exponential cost inherent in enumerative synthesis, results in an enormous search space for a machine-code synthesizer: even for relatively small specifications, the synthesizer might take several hours or days to find an implementation. In this paper, we present several improvements to the algorithms used in a state-of-the-art machine-code synthesizer McSynth. In addition to a novel pruning heuristic, our improvements incorporate a number of ideas known from the literature, which we adapt in novel ways for the purpose of speeding up machine-code synthesis. Our experiments for Intel&#039;s IA-32 instruction set show that our improvements enable synthesis of code for 12 out of 14 formulas on which McSynth times out, speeding up the synthesis time by at least 1981X, and for the remaining formulas, speeds up synthesis by 3X.
[]
Automated reasoning for web page layout
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Web pages define their appearance using Cascading Style Sheets, a modular language for layout of tree-structured documents. In principle, using CSS is easy: the developer specifies declarative constraints on the layout of an HTML document (such as the positioning of nodes in the HTML tree), and the browser solves the constraints to produce a box-based rendering of that document. In practice, however, the subtleties of CSS semantics make it difficult to develop stylesheets that produce the intended layout across different user preferences and browser settings.   This paper presents the first mechanized formalization of a substantial fragment of the CSS semantics. This formalization is equipped with an efficient reduction to the theory of quantifier-free linear real arithmetic, enabling effective automated reasoning about CSS stylesheets and their behavior. We implement this reduction in Cassius, a solver-aided framework for building semantics-aware tools for CSS. To demonstrate the utility of Cassius, we prototype new tools for automated verification, debugging, and synthesis of CSS code. We show that these tools work on fragments of real-world websites, and that Cassius is a practical first step toward solver-aided programming for the web.
[Software notations and tools, Software and its engineering]
FIDEX: filtering spreadsheet data using examples
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Data filtering in spreadsheets is a common problem faced by millions of end-users. The task of data filtering requires a computational model that can separate intended positive and negative string instances. We present a system, FIDEX, that can efficiently learn desired data filtering expressions from a small set of positive and negative string examples.   There are two key ideas of our approach. First, we design an expressive DSL to represent disjunctive filter expressions needed for several real-world data filtering tasks. Second, we develop an efficient synthesis algorithm for incrementally learning consistent filter expressions in the DSL from very few positive and negative examples. A DAG-based data structure is used to succinctly represent a large number of filter expressions, and two corresponding operators are defined for algorithmically handling positive and negative examples, namely, the intersection and subtraction operators. FIDEX is able to learn data filters for 452 out of 460 real-world data filtering tasks in real time (0.22s), using only 2.2 positive string instances and 2.7 negative string instances on average.
[]
Extensible access control with authorization contracts
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Existing programming language access control frameworks do not meet the needs of all software components. We propose an expressive framework for implementing access control monitors for components. The basis of the framework is a novel concept: the authority environment. An authority environment associates rights with an execution context. The building blocks of access control monitors in our framework are authorization contracts: software contracts that manage authority environments. We demonstrate the expressiveness of our framework by implementing a diverse set of existing access control mechanisms and writing custom access control monitors for three realistic case studies.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Software notations and tools, Verification, Formal languages and automata theory, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Formal language definitions, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Gentrification gone too far? affordable 2nd-class values for fun and (co-)effect
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
First-class functions dramatically increase expressiveness, at the expense of static guarantees. In ALGOL or PASCAL, functions could be passed as arguments but never escape their defining scope. Therefore, function arguments could serve as temporary access tokens or capabilities, enabling callees to perform some action, but only for the duration of the call. In modern languages, such programming patterns are no longer available. The central thrust of this paper is to re-introduce second-class functions and other values alongside first-class entities in modern languages. We formalize second-class values with stack-bounded lifetimes as an extension to simply-typed &#206;» calculus, and for richer type systems such as F<sub>&lt;:</sub> and systems with path-dependent types. We generalize the binary first- vs second-class distinction to arbitrary privilege lattices, with the underlying type lattice as a special case. In this setting, abstract types naturally enable privilege parametricity. We prove type soundness and lifetime properties in Coq. We implement our system as an extension of Scala, and present several case studies. First, we modify the Scala Collections library and add privilege annotations to all higher-order functions. Privilege parametricity is key to retain the high degree of code-reuse between sequential and parallel as well as lazy and eager collections. Second, we use scoped capabilities to introduce a model of checked exceptions in the Scala library, with only few changes to the code. Third, we employ second-class capabilities for memory safety in a region-based off-heap memory library.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Incremental forest: a DSL for efficiently managing filestores
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
File systems are often used to store persistent application data, but manipulating file systems using standard APIs can be difficult for programmers. Forest is a domain-specific language that bridges the gap between the on-disk and in-memory representations of file system data. Given a high-level specification of the structure, contents, and properties of a collection of directories, files, and symbolic links, the Forest compiler generates tools for loading, storing, and validating that data. Unfortunately, the initial implementation of Forest offered few mechanisms for controlling cost&#226;e.g., the run-time system could load gigabytes of data, even if only a few bytes were needed. This paper introduces Incremental Forest (iForest), an extension to Forest with an explicit delay construct that programmers can use to precisely control costs. We describe the design of iForest using a series of running examples, present a formal semantics in a core calculus, and define a simple cost model that accurately characterizes the resources needed to use a given specification. We propose skins, which allow programmers to modify the delay structure of a specification in a compositional way, and develop a static type system for ensuring compatibility between specifications and skins. We prove the soundness and completeness of the type system and a variety of algebraic properties of skins. We describe an OCaml implementation and evaluate its performance on applications developed in collaboration with watershed hydrologists.
[]
LaCasa: lightweight affinity and object capabilities in Scala
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Aliasing is a known source of challenges in the context of imperative object-oriented languages, which have led to important advances in type systems for aliasing control. However, their large-scale adoption has turned out to be a surprisingly difficult challenge. While new language designs show promise, they do not address the need of aliasing control in existing languages.   This paper presents a new approach to isolation and uniqueness in an existing, widely-used language, Scala. The approach is unique in the way it addresses some of the most important obstacles to the adoption of type system extensions for aliasing control. First, adaptation of existing code requires only a minimal set of annotations. Only a single bit of information is required per class. Surprisingly, the paper shows that this information can be provided by the object-capability discipline, widely-used in program security. We formalize our approach as a type system and prove key soundness theorems. The type system is implemented for the full Scala language, providing, for the first time, a sound integration with Scala&#039;s local type inference. Finally, we empirically evaluate the conformity of existing Scala open-source code on a corpus of over 75,000 LOC.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Software notations and tools, Program constructs, Software and its engineering]
Purposes, concepts, misfits, and a redesign of git
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Git is a widely used version control system that is powerful but complicated. Its complexity may not be an inevitable consequence of its power but rather evidence of flaws in its design. To explore this hypothesis, we analyzed the design of Git using a theory that identifies concepts, purposes, and misfits. Some well-known difficulties with Git are described, and explained as misfits in which underlying concepts fail to meet their intended purpose. Based on this analysis, we designed a reworking of Git (called Gitless) that attempts to remedy these flaws.   To correlate misfits with issues reported by users, we conducted a study of Stack Overflow questions. And to determine whether users experienced fewer complications using Gitless in place of Git, we conducted a small user study. Results suggest our approach can be profitable in identifying, analyzing, and fixing design problems.
[Software design techniques, Management of computing and information systems, Software maintenance, Software creation and management, Professional topics, Software post-development issues, Software implementation planning, Designing software, Software development process management, Software management, Social and professional topics, Software and its engineering]
Apex: automatic programming assignment error explanation
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
This paper presents Apex, a system that can automatically generate explanations for programming assignment bugs, regarding where the bugs are and how the root causes led to the runtime failures. It works by comparing the passing execution of a correct implementation (provided by the instructor) and the failing execution of the buggy implementation (submitted by the student). The technique overcomes a number of technical challenges caused by syntactic and semantic differences of the two implementations. It collects the symbolic traces of the executions and matches assignment statements in the two execution traces by reasoning about symbolic equivalence. It then matches predicates by aligning the control dependences of the matched assignment statements, avoiding direct matching of path conditions which are usually quite different. Our evaluation shows that Apex is every effective for 205 buggy real world student submissions of 4 programming assignments, and a set of 15 programming assignment type of buggy programs collected from stackoverflow.com, precisely pinpointing the root causes and capturing the causality for 94.5% of them. The evaluation on a standard benchmark set with over 700 student bugs shows similar results. A user study in the classroom shows that Apex has substantially improved student productivity.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Asserting reliable convergence for configuration management scripts
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
The rise of elastically scaling applications that frequently deploy new machines has led to the adoption of DevOps practices across the cloud engineering stack. So-called configuration management tools utilize scripts that are based on declarative resource descriptions and make the system converge to the desired state. It is crucial for convergent configurations to be able to gracefully handle transient faults, e.g., network outages when downloading and installing software packages. In this paper we introduce a conceptual framework for asserting reliable convergence in configuration management. Based on a formal definition of configuration scripts and their resources, we utilize state transition graphs to test whether a script makes the system converge to the desired state under different conditions. In our generalized model, configuration actions are partially ordered, often resulting in prohibitively many possible execution orders. To reduce this problem space, we define and analyze a property called preservation, and we show that if preservation holds for all pairs of resources, then convergence holds for the entire configuration. Our implementation builds on Puppet, but the approach is equally applicable to other frameworks like Chef, Ansible, etc. We perform a comprehensive evaluation based on real world Puppet scripts and show the effectiveness of the approach. Our tool is able to detect all idempotence and convergence related issues in a set of existing Puppet scripts with known issues as well as some hitherto undiscovered bugs in a large random sample of scripts.
[Software defect analysis, Management of computing and information systems, Project and people management, Software creation and management, Software verification and validation, Language features, Professional topics, Software notations and tools, Software configuration management and version control systems, Software development process management, Software testing and debugging, General programming languages, Social and professional topics, Software and its engineering]
Dependent partitioning
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
A key problem in parallel programming is how data is <em>partitioned</em>: divided into subsets that can be operated on in parallel and, in distributed memory machines, spread across multiple address spaces. We present a <em>dependent partitioning</em> framework that allows an application to concisely describe relationships between partitions. Applications first establish <em>independent partitions</em>, which may contain arbitrary subsets of application data, permitting the expression of arbitrary application-specific data distributions. <em>Dependent partitions</em> are then derived from these using the <em>dependent partitioning operations</em> provided by the framework. By directly capturing inter-partition relationships, our framework can soundly and precisely reason about programs to perform important program analyses crucial to ensuring correctness and achieving good performance. As an example of the reasoning made possible, we present a static analysis that discharges most consistency checks on partitioned data during compilation. We describe an implementation of our framework within Regent, a language designed for the Legion programming model. The use of dependent partitioning constructs results in a 86-96% decrease in the lines of code required to describe the partitioning, eliminates many of the expensive dynamic checks required for soundness by the current Regent partitioning implementation, and speeds up the computation of partitions by 2.6-12.7X even on a single thread. Additionally, we show that a distributed implementation incorporated into the the Legion runtime system allows partitioning of data sets that are too large to fit on a single node and yields a further 29X speedup of partitioning operations on 64 nodes.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Language features, Software verification and validation, Computing methodologies, Language types, Software notations and tools, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, General programming languages, Concurrent programming languages, Program reasoning, Formal software verification, Formal methods, Concurrent computing methodologies, General and reference, Software organization and properties, Software and its engineering]
Accelerating program analyses by cross-program training
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Practical programs share large modules of code. However, many program analyses are ineffective at reusing analysis results for shared code across programs. We present POLYMER, an analysis optimizer to address this problem. POLYMER runs the analysis offline on a corpus of training programs and learns analysis facts over shared code. It prunes the learnt facts to eliminate intermediate computations and then reuses these pruned facts to accelerate the analysis of other programs that share code with the training corpus. We have implemented POLYMER to accelerate analyses specified in Datalog, and apply it to optimize two analyses for Java programs: a call-graph analysis that is flow- and context-insensitive, and a points-to analysis that is flow- and context-sensitive. We evaluate the resulting analyses on ten programs from the DaCapo suite that share the JDK library. POLYMER achieves average speedups of 2.6&#215; for the call- graph analysis and 5.2&#215; for the points-to analysis.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
An improved algorithm for slicing machine code
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Machine-code slicing is an important primitive for building binary analysis and rewriting tools, such as taint trackers, fault localizers, and partial evaluators. However, it is not easy to create a machine-code slicer that exhibits a high level of precision. Moreover, the problem of creating such a tool is compounded by the fact that a small amount of local imprecision can be amplified via cascade effects.   Most instructions in instruction sets such as Intel&#039;s IA-32 and ARM are multi-assignments: they have several inputs and several outputs (registers, flags, and memory locations). This aspect of the instruction set introduces a granularity issue during slicing: there are often instructions at which we would like the slice to include only a subset of the instruction&#039;s semantics, whereas the slice is forced to include the entire instruction. Consequently, the slice computed by state-of-the-art tools is very imprecise, often including essentially the entire program.   This paper presents an algorithm to slice machine code more accurately. To counter the granularity issue, our algorithm performs slicing at the microcode level, instead of the instruction level, and obtains a more precise microcode slice. To reconstitute a machine-code program from a microcode slice, our algorithm uses machine-code synthesis. Our experiments on IA-32 binaries of FreeBSD utilities show that, in comparison to slices computed by a state-of-the-art tool, our algorithm reduces the size of backward slices by 33%, and forward slices by 70%.
[Theory of computation, Semantics and reasoning, Program semantics]
Call graphs for languages with parametric polymorphism
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
The performance of contemporary object oriented languages depends on optimizations such as devirtualization, inlining, and specialization, and these in turn depend on precise call graph analysis. Existing call graph analyses do not take advantage of the information provided by the rich type systems of contemporary languages, in particular generic type arguments. Many existing approaches analyze Java bytecode, in which generic types have been erased. This paper shows that this discarded information is actually very useful as the context in a context-sensitive analysis, where it significantly improves precision and keeps the running time small. Specifically, we propose and evaluate call graph construction algorithms in which the contexts of a method are (i) the type arguments passed to its type parameters, and (ii) the static types of the arguments passed to its term parameters. The use of static types from the caller as context is effective because it allows more precise dispatch of call sites inside the callee. Our evaluation indicates that the average number of contexts required per method is small. We implement the analysis in the Dotty compiler for Scala, and evaluate it on programs that use the type-parametric Scala collections library and on the Dotty compiler itself. The context-sensitive analysis runs 1.4x faster than a context-insensitive one and discovers 20% more monomorphic call sites at the same time. When applied to method specialization, the imprecision in a context-insensitive call graph would require the average method to be cloned 22 times, whereas the context-sensitive call graph indicates a much more practical 1.00 to 1.50 clones per method. We applied the proposed analysis to automatically specialize generic methods. The resulting automatic transformation achieves the same performance as state-of-the-art techniques requiring manual annotations, while reducing the size of the generated bytecode by up to 5Ã.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Program semantics, Software notations and tools, Software and its engineering, Compilers]
Type inference for static compilation of JavaScript
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
We present a type system and inference algorithm for a rich subset of JavaScript equipped with objects, structural subtyping, prototype inheritance, and first-class methods. The type system supports abstract and recursive objects, and is expressive enough to accommodate several standard benchmarks with only minor workarounds. The invariants enforced by the types enable an ahead-of-time compiler to carry out optimizations typically beyond the reach of static compilers for dynamic languages. Unlike previous inference techniques for prototype inheritance, our algorithm uses a combination of lower and upper bound propagation to infer types and discover type errors in all code, including uninvoked functions. The inference is expressed in a simple constraint language, designed to leverage off-the-shelf fixed point solvers. We prove soundness for both the type system and inference algorithm. An experimental evaluation showed that the inference is powerful, handling the aforementioned benchmarks with no manual type annotation, and that the inferred types enable effective static compilation.
[General programming languages, Language features, Software notations and tools, Software and its engineering, Compilers]
Directed synthesis of failing concurrent executions
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Detecting concurrency-induced bugs in multithreaded libraries can be challenging due to the intricacies associated with their manifestation. This includes invocation of multiple methods, synthesis of inputs to the methods to reach the failing location, and crafting of thread interleavings that cause the erroneous behavior. Neither fuzzing-based testing techniques nor over-approximate static analyses are well positioned to detect such subtle defects while retaining high accuracy alongside satisfactory coverage.   In this paper, we propose a directed, iterative and scalable testing engine that combines the strengths of static and dynamic analysis to help synthesize concurrent executions to expose complex concurrency-induced bugs. Our engine accepts as input the library, its client (either sequential or concurrent) and a specification of correctness. Then, it iteratively refines the client to generate an execution that can break the input specification. Each step of the iterative process includes statically identifying sub-goals towards the goal of failing the specification, generating a plan toward meeting these goals, and merging of the paths traversed dynamically with the plan computed statically via constraint solving to generate a new client. The engine reports full reproduction scenarios, guaranteed to be true, for the bugs it finds.   We have created a prototype of our approach named MINION. We validated MINION by applying it to well-tested concurrent classes from popular Java libraries, including the latest versions of openjdk and google-guava. We were able to detect 31 real crashes across 10 classes in a total of 23 minutes, including previously unknown bugs. Comparison with three other tools reveals that combined, they report only 9 of the 31 crashes (and no other crashes beyond MINION). This is because several of these bugs manifest under deeply nested path conditions (observed maximum of 11), deep nesting of method invocations (observed maximum of 6) and multiple refinement iterations to generate the crash-inducing client.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Maximal causality reduction for TSO and PSO
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Verifying concurrent programs is challenging due to the exponentially large thread interleaving space. The problem is exacerbated by relaxed memory models such as Total Store Order (TSO) and Partial Store Order (PSO) which further explode the interleaving space by reordering instructions. A recent advance, Maximal Causality Reduction (MCR), has shown great promise to improve verification effectiveness by maximally reducing redundant explorations. However, the original MCR only works for the Sequential Consistency (SC) memory model, but not for TSO and PSO. In this paper, we develop novel extensions to MCR by solving two key problems under TSO and PSO: 1) generating interleavings that can reach new states by encoding the operational semantics of TSO and PSO with first-order logical constraints and solving them with SMT solvers, and 2) enforcing TSO and PSO interleavings by developing novel replay algorithms that allow executions out of the program order. We show that our approach successfully enables MCR to effectively explore TSO and PSO interleavings. We have compared our approach with a recent Dynamic Partial Order Reduction (DPOR) algorithm for TSO and PSO and a SAT-based stateless model checking approach. Our results show that our approach is much more effective than the other approaches for both state-space exploration and bug finding &#8211; on average it explores 5-10X fewer executions and finds many bugs that the other tools cannot find.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Precise and maximal race detection from incomplete traces
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
We present RDIT, a novel dynamic technique to detect data races in multithreaded programs with incomplete trace information, i.e., in the presence of missing events. RDIT is both precise and maximal: it does not report any false alarms and it detects a maximal set of true traces from the observed incomplete trace. RDIT is underpinned by a sound BarrierPair model that abstracts away the missing events by capturing the invocation data of their enclosing methods. By making the least conservative abstraction that a missing method introduces synchronization only when it has a memory address in scope that overlaps with other events or other missing methods, and by formulating maximal thread causality as logical constraints, RDIT guarantees to precisely detect races with maximal capability. RDIT has been applied in seven real-world large concurrent systems and has detected dozens of true races with zero false alarms. Comparatively, existing algorithms such as Happens-Before, Causal- Precedes, and Maximal-Causality which are known to be precise all report many false alarms when missing synchronizations.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
Stateless model checking with data-race preemption points
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Stateless model checking is a powerful technique for testing concurrent programs, but suffers from exponential state space explosion when the test input parameters are too large. Several reduction techniques can mitigate this explosion, but even after pruning equivalent interleavings, the state space size is often intractable. Most prior tools are limited to preempting only on synchronization APIs, which reduces the space further, but can miss unsynchronized thread communication bugs. Data race detection, another concurrency testing approach, focuses on suspicious memory access pairs during a single test execution. It avoids concerns of state space size, but may report races that do not lead to observable failures, which jeopardizes a user&#8217;s willingness to use the analysis.   We present Quicksand, a new stateless model checking framework which manages the exploration of many state spaces using different preemption points. It uses state space estimation to prioritize jobs most likely to complete in a fixed CPU budget, and it incorporates data-race analysis to add new preemption points on the fly. Preempting threads during a data race&#8217;s instructions can automatically classify the race as buggy or benign, and uncovers new bugs not reachable by prior model checkers. It also enables full verification of all possible schedules when every data race is verified as benign within the CPU budget. In our evaluation, Quicksand found 1.25x as many bugs and verified 4.3x as many tests compared to prior model checking approaches.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Automatic enforcement of expressive security policies using enclaves
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Hardware-based enclave protection mechanisms, such as Intel&#226;s SGX, ARM&#226;s TrustZone, and Apple&#226;s Secure Enclave, can protect code and data from powerful low-level attackers. In this work, we use enclaves to enforce strong application-specific information security policies. We present IMP<sub>E</sub>, a novel calculus that captures the essence of SGX-like enclave mechanisms, and show that a security-type system for IMP<sub>E</sub> can enforce expressive confidentiality policies (including erasure policies and delimited release policies) against powerful low-level attackers, including attackers that can arbitrarily corrupt non-enclave code, and, under some circumstances, corrupt enclave code. We present a translation from an expressive security-typed calculus (that is not aware of enclaves) to IMP<sub>E</sub>. The translation automatically places code and data into enclaves to enforce the security policies of the source program.
[Security and privacy, General programming languages, Language features, Software notations and tools, Systems security, Operating systems security, Software and its engineering]
Chain: tasks and channels for reliable intermittent programs
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Energy harvesting computers enable general-purpose computing using energy collected from their environment. Energy-autonomy of such devices has great potential, but their intermittent power supply poses a challenge. Intermittent program execution compromises progress and leaves state inconsistent. This work describes Chain: a new model for programming intermittent devices.   A Chain program is a set of programmer-defined tasks that compute and exchange data through channels. Chain guarantees forward progress at task granularity. A task is restartable and never sees inconsistent state, because its input and output channels are separated. Our system supports language features for expressing advanced data exchange patterns and for encapsulating reusable functionality.   Chain fundamentally differs from state-of-the-art checkpointing approaches and does not incur the associated overhead. We implement Chain as C language extensions and a runtime library. We used Chain to implement four applications: machine learning, encryption, compression, and sensing. In experiments, Chain ensured consistency where prior approaches failed and improved throughput by 2-7x over the leading state-of-the-art system.
[Cross-computing tools and techniques, Computer systems organization, Embedded and cyber-physical systems, Extra-functional properties, Real-time systems, Software reliability, Reliability, General and reference, Software organization and properties, Software and its engineering]
GEMs: shared-memory parallel programming for Node.js
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
JavaScript is the most popular programming language for client-side Web applications, and Node.js has popularized the language for server-side computing, too. In this domain, the minimal support for parallel programming remains however a major limitation. In this paper we introduce a novel parallel programming abstraction called Generic Messages (GEMs). GEMs allow one to combine message passing and shared-memory parallelism, extending the classes of parallel applications that can be built with Node.js. GEMs have customizable semantics and enable several forms of thread safety, isolation, and concurrency control. GEMs are designed as convenient JavaScript abstractions that expose high-level and safe parallelism models to the developer. Experiments show that GEMs outperform equivalent Node.js applications thanks to their usage of shared memory.
[General programming languages, Computing methodologies, Language types, Software notations and tools, Concurrent programming languages, Concurrent computing methodologies, Software and its engineering]
OrcO: a concurrency-first approach to objects
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
The majority of modern programming languages provide concurrency and object-orientation in some form. However, object-oriented concurrency remains cumbersome in many situations. We introduce the language OrcO, Orc with concurrent Objects, which enables a flexible style of concurrent object-oriented programming. OrcO extends the Orc programming language by adding abstractions for programming-in-the-large; namely objects, classes, and inheritance. OrcO objects are designed to be orthogonal to concurrency, allowing the concurrent structure and object structure of a program to evolve independently. This paper describes OrcO&#039;s goals and design and provides examples of how OrcO can be used to deftly handle events, object management, and object composition.
[General programming languages, Language features, Language types, Software notations and tools, Software and its engineering]
Semantic subtyping for imperative object-oriented languages
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Semantic subtyping is an approach for defining sound and complete procedures to decide subtyping for expressive types, including union and intersection types; although it has been exploited especially in functional languages for XML based programming, recently it has been partially investigated in the context of object-oriented languages, and a sound and complete subtyping algorithm has been proposed for record types, but restricted to immutable fields, with union and recursive types interpreted coinductively to support cyclic objects. In this work we address the problem of studying semantic subtyping for imperative object-oriented languages, where fields can be mutable; in particular, we add read/write field annotations to record types, and, besides union, we consider intersection types as well, while maintaining coinductive interpretation of recursive types. In this way, we get a richer notion of type with a flexible subtyping relation, able to express a variety of type invariants useful for enforcing static guarantees for mutable objects. The addition of these features radically changes the defi- nition of subtyping, and, hence, the corresponding decision procedure, and surprisingly invalidates some subtyping laws that hold in the functional setting. We propose an intuitive model where mutable record val- ues contain type information to specify the values that can be correctly stored in fields. Such a model, and the correspond- ing subtyping rules, require particular care to avoid circularity between coinductive judgments and their negations which, by duality, have to be interpreted inductively. A sound and complete subtyping algorithm is provided, together with a prototype implementation.
[Theory of computation, Semantics and reasoning, Formal language definitions, Software notations and tools, Formal languages and automata theory, Program reasoning, Logic, Software and its engineering]
Parsing with first-class derivatives
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Brzozowski derivatives, well known in the context of regular expressions, have recently been rediscovered to give a simplified explanation to parsers of context-free languages. We add derivatives as a novel first-class feature to a standard parser combinator language. First-class derivatives enable an inversion of the control flow, allowing to implement modular parsers for languages that previously required separate pre-processing steps or cross-cutting modifications of the parsers. We show that our framework offers new opportunities for reuse and supports a modular definition of interesting use cases of layout-sensitive parsing.
[Theory of computation, Grammars and context-free languages, Formalisms, Rewrite systems, Formal language definitions, Software notations and tools, Formal languages and automata theory, Software and its engineering, Compilers]
The missing link: explaining ELF static linking, semantically
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Beneath the surface, software usually depends on complex <em>linker behaviour</em> to work as intended. Even linking &lt;pre&gt;hello_world.c&lt;/pre&gt; is surprisingly involved, and systems software such as &lt;pre&gt;libc&lt;/pre&gt; and operating system kernels rely on a host of linker features. But linking is poorly understood by working programmers and has largely been neglected by language researchers. In this paper we survey the many use-cases that linkers support and the poorly specified <em>linker speak</em> by which they are controlled: metadata in object files, command-line options, and linker-script language. We provide the first validated formalisation of a realistic executable and linkable format (ELF), and capture aspects of the Application Binary Interfaces for four mainstream platforms (AArch64, AMD64, Power64, and IA32). Using these, we develop an executable specification of static linking, covering (among other things) enough to link small C programs (we use the example of bzip2) into a correctly running executable. We provide our specification in Lem and Isabelle/HOL forms. This is the first formal specification of mainstream linking. We have used the Isabelle/HOL version to prove a sample correctness property for one case of AMD64 ABI relocation, demonstrating that the specification supports formal proof, and as a first step towards the much more ambitious goal of verified linking. Our work should enable several novel strands of research, including linker-aware verified compilation and program analysis, and better languages for controlling linking.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Software notations and tools, Verification, Formal languages and automata theory, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Formal language definitions, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering, Compilers]
Type soundness for dependent object types (DOT)
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Scala&#8217;s type system unifies aspects of ML modules, object- oriented, and functional programming. The Dependent Object Types (DOT) family of calculi has been proposed as a new theoretic foundation for Scala and similar expressive languages. Unfortunately, type soundness has only been established for restricted subsets of DOT. In fact, it has been shown that important Scala features such as type refinement or a subtyping relation with lattice structure break at least one key metatheoretic property such as environment narrowing or invertible subtyping transitivity, which are usually required for a type soundness proof. The main contribution of this paper is to demonstrate how, perhaps surprisingly, even though these properties are lost in their full generality, a rich DOT calculus that includes recursive type refinement and a subtyping lattice with intersection types can still be proved sound. The key insight is that subtyping transitivity only needs to be invertible in code paths executed at runtime, with contexts consisting entirely of valid runtime objects, whereas inconsistent subtyping contexts can be permitted for code that is never executed.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
Efficient and thread-safe objects for dynamically-typed languages
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
We are in the multi-core era. Dynamically-typed languages are in widespread use, but their support for multithreading still lags behind. One of the reasons is that the sophisticated techniques they use to efficiently represent their dynamic object models are often unsafe in multithreaded environments.   This paper defines safety requirements for dynamic object models in multithreaded environments. Based on these requirements, a language-agnostic and thread-safe object model is designed that maintains the efficiency of sequential approaches. This is achieved by ensuring that field reads do not require synchronization and field updates only need to synchronize on objects shared between threads.   Basing our work on JRuby+Truffle, we show that our safe object model has zero overhead on peak performance for thread-local objects and only 3% average overhead on parallel benchmarks where field updates require synchronization. Thus, it can be a foundation for safe and efficient multithreaded VMs for a wide range of dynamic languages.
[General programming languages, Language features, Software notations and tools, Software and its engineering, Compilers]
Hybrid STM/HTM for nested transactions on OpenJDK
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Transactional memory (TM) has long been advocated as a promising pathway to more automated concurrency control for scaling concurrent programs running on parallel hardware. Software TM (STM) has the benefit of being able to run general transactional programs, but at the significant cost of overheads imposed to log memory accesses, mediate access conflicts, and maintain other transaction metadata. Recently, hardware manufacturers have begun to offer commodity hardware TM (HTM) support in their processors wherein the transaction metadata is maintained &#226;for free&#226; in hardware. However, HTM approaches are only <em>best-effort</em>: they cannot successfully run all transactional programs, whether because of hardware capacity issues (causing large transactions to fail), or compatibility restrictions on the processor instructions permitted within hardware transactions (causing transactions that execute those instructions to fail). In such cases, programs must include failure-handling code to attempt the computation by some other software means, since retrying the transaction would be futile. Thus, a canonical use of HTM is <em>lock elision</em>: replacing lock regions with transactions, retrying some number of times in the case of conflicts, but falling back to locking when HTM fails for other reasons. Here, we describe how software and hardware schemes can combine seamlessly into a hybrid system in support of transactional programs, allowing use of low-cost HTM when it works, but reverting to STM when it doesn&#226;t. We describe heuristics used to make this choice dynamically and automatically, but allowing the transition back to HTM opportunistically. Our implementation is for an extension of Java having syntax for both open and closed nested transactions, and boosting, running on the OpenJDK, with dynamic injection of STM mechanisms (into code variants used under STM) and HTM instructions (into code variants used under HTM). Both schemes are compatible to allow different threads to run concurrently with either mechanism, while preserving transaction safety. Using a standard synthetic benchmark we demonstrate that HTM offers significant acceleration of both closed and open nested transactions, while yielding parallel scaling up to the limits of the hardware, whereupon scaling in software continues but with the penalty to throughput imposed by software mechanisms.
[General programming languages, Language features, Software notations and tools, Software and its engineering, Compilers]
Makalu: fast recoverable allocation of non-volatile memory
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Byte addressable non-volatile memory (NVRAM) is likely to supplement, and perhaps eventually replace, DRAM. Applications can then persist data structures directly in memory instead of serializing them and storing them onto a durable block device. However, failures during execution can leave data structures in NVRAM unreachable or corrupt. In this paper, we present Makalu, a system that addresses non-volatile memory management. Makalu offers an integrated allocator and recovery-time garbage collector that maintains internal consistency, avoids NVRAM memory leaks, and is efficient, all in the face of failures.   We show that a careful allocator design can support a less restrictive and a much more familiar programming model than existing persistent memory allocators. Our allocator significantly reduces the per allocation persistence overhead by lazily persisting non-essential metadata and by employing a post-failure recovery-time garbage collector. Experimental results show that the resulting online speed and scalability of our allocator are comparable to well-known transient allocators, and significantly better than state-of-the-art persistent allocators.
[Cross-computing tools and techniques, File systems management, Software notations and tools, Extra-functional properties, Software reliability, Contextual software domains, Information systems, Information storage systems, Operating systems, Storage management, Memory management, Reliability, General and reference, Software organization and properties, Software and its engineering, Compilers]
Prioritized garbage collection: explicit GC support for software caches
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Programmers routinely trade space for time to increase performance, often in the form of caching or memoization. In managed languages like Java or JavaScript, however, this space-time tradeoff is complex. Using more space translates into higher garbage collection costs, especially at the limit of available memory. Existing runtime systems provide limited support for space-sensitive algorithms, forcing programmers into difficult and often brittle choices about provisioning. This paper presents <em>prioritized garbage collection</em>, a cooperative programming language and runtime solution to this problem. Prioritized GC provides an interface similar to soft references, called <em>priority references</em>, which identify objects that the collector can reclaim eagerly if necessary. The key difference is an API for defining the policy that governs when priority references are cleared and in what order. Application code specifies a priority value for each reference and a target memory bound. The collector reclaims references, lowest priority first, until the total memory footprint of the cache fits within the bound. We use this API to implement a space-aware least-recently-used (LRU) cache, called a <em>Sache</em>, that is a drop-in replacement for existing caches, such as Google&#226;s Guava library. The garbage collector automatically grows and shrinks the Sache in response to available memory and workload with minimal provisioning information from the programmer. Using a Sache, it is almost impossible for an application to experience a memory leak, memory pressure, or an out-of-memory crash caused by software caching.
[Software notations and tools, Software and its engineering, Compilers]
Computing repair alternatives for malformed programs using constraint attribute grammars
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Attribute grammars decorate the nodes of a program&#039;s parse tree with attributes whose values are defined by equations encoding the (static) semantics of a programming language. We show how replacing the equations of an attribute grammar with equivalent constraints that can be solved by a constraint solver allows us to compute repairs of a malformed program solely from a specification that was originally designed for checking its well-formedness. We present two repair modes --- shallow and deep fixing --- whose computed repair alternatives are guaranteed to repair every error on which they are invoked. While shallow fixing may introduce new errors, deep fixing never does; to make it tractable, we implement it using neighborhood search. We demonstrate the feasibility of our approach by implementing it on top of ExtendJ, an attribute grammar based Java compiler, and by applying it to an example from the Java EE context, detecting and fixing well-formedness errors (both real and injected) in a body of 14 open-source subject programs.
[Theory of computation, Grammars and context-free languages, Formalisms, Rewrite systems, Formal languages and automata theory]
Probabilistic model for code with decision trees
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
In this paper we introduce a new approach for learning precise and general probabilistic models of code based on decision tree learning. Our approach directly benefits an emerging class of statistical programming tools which leverage probabilistic models of code learned over large codebases (e.g., GitHub) to make predictions about new programs (e.g., code completion, repair, etc).   The key idea is to phrase the problem of learning a probabilistic model of code as learning a decision tree in a domain specific language over abstract syntax trees (called TGen). This allows us to condition the prediction of a program element on a dynamically computed context. Further, our problem formulation enables us to easily instantiate known decision tree learning algorithms such as ID3, but also to obtain new variants we refer to as ID3+ and E13, not previously explored and ones that outperform ID3 in prediction accuracy.   Our approach is general and can be used to learn a probabilistic model of any programming language. We implemented our approach in a system called Deep3 and evaluated it for the challenging task of learning probabilistic models of JavaScript and Python. Our experimental results indicate that Deep3 predicts elements of JavaScript and Python code with precision above 82% and 69%, respectively. Further, Deep3 often significantly outperforms state-of-the-art approaches in overall prediction accuracy.
[Software notations and tools, Software and its engineering]
Ringer: web automation by demonstration
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
With increasing amounts of data available on the web and a diverse range of users interested in programmatically accessing that data, web automation must become easier. Automation helps users complete many tedious interactions, such as scraping data, completing forms, or transferring data between websites. However, writing web automation scripts typically requires an expert programmer because the writer must be able to reverse engineer the target webpage. We have built a record and replay tool, Ringer, that makes web automation accessible to non-coders. Ringer takes a user demonstration as input and creates a script that interacts with the page as a user would. This approach makes Ringer scripts more robust to webpage changes because user-facing interfaces remain relatively stable compared to the underlying webpage implementations. We evaluated our approach on benchmarks recorded on real webpages and found that it replayed 4x more benchmarks than a state-of-the-art replay tool.
[Collaborative and social computing, Human-centered computing]
Scalable verification of border gateway protocol configurations with an SMT solver
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Internet Service Providers (ISPs) use the Border Gateway Protocol (BGP) to announce and exchange routes for de- livering packets through the internet. ISPs must carefully configure their BGP routers to ensure traffic is routed reli- ably and securely. Correctly configuring BGP routers has proven challenging in practice, and misconfiguration has led to worldwide outages and traffic hijacks. This paper presents Bagpipe, a system that enables ISPs to declaratively express BGP policies and that automatically verifies that router configurations implement such policies. The novel initial network reduction soundly reduces policy verification to a search for counterexamples in a finite space. An SMT-based symbolic execution engine performs this search efficiently. Bagpipe reduces the size of its search space using predicate abstraction and parallelizes its search using symbolic variable hoisting. Bagpipe&#039;s policy specification language is expressive: we expressed policies inferred from real AS configurations, policies from the literature, and policies for 10 Juniper TechLibrary configuration scenarios. Bagpipe is efficient: we ran it on three ASes with a total of over 240,000 lines of Cisco and Juniper BGP configuration. Bagpipe is effective: it revealed 19 policy violations without issuing any false positives.
[Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
A practical framework for type inference error explanation
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Many languages have support for automatic type inference. But when inference fails, the reported error messages can be unhelpful, highlighting a code location far from the source of the problem. Several lines of work have emerged proposing error reports derived from correcting sets: a set of program points that, when fixed, produce a well-typed program. Unfortunately, these approaches are tightly tied to specific languages; targeting a new language requires encoding a type inference algorithm for the language in a custom constraint system specific to the error reporting tool.   We show how to produce correcting set-based error reports by leveraging existing type inference implementations, easing the burden of adoption and, as type inference algorithms tend to be efficient in practice, producing error reports of comparable quality to similar error reporting tools orders of magnitude faster. Many type inference algorithms are already formulated as dual phases of type constraint generation and solving; rather than (re)implementing type inference in an error explanation tool, we isolate the solving phase and treat it as an oracle for solving typing constraints. Given any set of typing constraints, error explanation proceeds by iteratively removing conflicting constraints from the initial constraint set until discovering a subset on which the solver succeeds; the constraints removed form a correcting set. Our approach is agnostic to the semantics of any particular language or type system, instead leveraging the existing type inference engine to give meaning to constraints.
[Software defect analysis, Theory of computation, Software creation and management, Software testing and debugging, Semantics and reasoning, Software verification and validation, Program semantics, Software and its engineering]
Dynamically diagnosing type errors in unsafe code
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Existing approaches for detecting type errors in unsafe languages are limited. Static analysis methods are imprecise, and often require source-level changes, while most dynamic methods check only memory properties (bounds, liveness, etc.), owing to a lack of run-time type information. This paper describes libcrunch, a system for binary-compatible run-time type checking of unmodified unsafe code, currently focusing on C. Practical experience shows that our prototype implementation is easily applicable to many real codebases without source-level modification, correctly flags programmer errors with a very low rate of false positives, offers a very low run-time overhead, and covers classes of error caught by no previously existing tool.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software and its engineering]
First-class effect reflection for effect-guided programming
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
This paper introduces a novel type-and-effect calculus, first-class effects, where the computational effect of an expression can be programmatically reflected, passed around as values, and analyzed at run time. A broad range of designs "hard-coded" in existing effect-guided analyses &#8212; from thread scheduling, version-consistent software updating, to data zeroing &#8212; can be naturally supported through the programming abstractions. The core technical development is a type system with a number of features, including a hybrid type system that integrates static and dynamic effect analyses, a refinement type system to verify application-specific effect management properties, a double-bounded type system that computes both over-approximation of effects and their under-approximation. We introduce and establish a notion of soundness called trace consistency, defined in terms of how the effect and trace correspond. The property sheds foundational insight on "good" first-class effect programming.
[Theory of computation, Semantics and reasoning, General programming languages, Language features, Program semantics, Software notations and tools, Software and its engineering]
Java and scala's type systems are unsound: the existential crisis of null pointers
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
We present short programs that demonstrate the unsoundness of Java and Scala&#039;s current type systems. In particular, these programs provide parametrically polymorphic functions that can turn any type into any type without (down)casting. Fortunately, parametric polymorphism was not integrated into the Java Virtual Machine (JVM), so these examples do not demonstrate any unsoundness of the JVM. Nonetheless, we discuss broader implications of these findings on the field of programming languages.
[General programming languages, Language features, Language types, Software notations and tools, Software and its engineering]
Finding compiler bugs via live code mutation
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Validating optimizing compilers is challenging because it is hard to generate valid test programs (i.e., those that do not expose any undefined behavior). Equivalence Modulo Inputs (EMI) is an effective, promising methodology to tackle this problem. Given a test program with some inputs, EMI mutates the program to derive variants that are semantically equivalent w.r.t. these inputs. The state-of-the-art instantiations of EMI are Orion and Athena, both of which rely on deleting code from or inserting code into code regions that are not executed under the inputs. Although both have demonstrated their ability in finding many bugs in GCC and LLVM, they are still limited due to their mutation strategies that operate only on dead code regions.   This paper presents a novel EMI technique that allows mutation in the entire program (i.e., both live and dead regions). By removing the restriction of mutating only the dead regions, our technique significantly increases the EMI variant space. It also helps to more thoroughly stress test compilers as compilers must optimize mutated live code, whereas mutated dead code might be eliminated. Finally, our technique also makes compiler bugs more noticeable as miscompilations on mutated dead code may not be observable.   We have realized the proposed technique in Hermes. The evaluation demonstrates Hermes&#8217;s effectiveness. In 13 months, Hermes found 168 confirmed, valid bugs in GCC and LLVM, of which 132 have already been fixed.
[Software defect analysis, Software creation and management, Software testing and debugging, Information storage systems, Software verification and validation, General programming languages, Language types, Information retrieval, Software notations and tools, Software and its engineering, Information systems]
Finding resume and restart errors in Android applications
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Smartphone apps create and handle a large variety of ``instance&#039;&#039; data that has to persist across runs, such as the current navigation route, workout results, antivirus settings, or game state. Due to the nature of the smartphone platform, an app can be paused, sent into background, or killed at any time. If the instance data is not saved and restored between runs, in addition to data loss, partially-saved or corrupted data can crash the app upon resume or restart. While smartphone platforms offer API support for data-saving and data-retrieving operations, the use of this API is ad-hoc: left to the programmer, rather than enforced by the compiler. We have observed that several categories of bugs---including data loss, failure to resume/restart or resuming/restarting in the wrong state---are due to incorrect handling of instance data and are easily triggered by just pressing the `Home&#039; or `Back&#039; buttons. To help address this problem, we have constructed a tool chain for Android (the KREfinder static analysis and the KREreproducer input generator) that helps find and reproduce such incorrect handling. We have evaluated our approach by running the static analysis on 324 apps, of which 49 were further analyzed manually. Results indicate that our approach is (i) effective, as it has discovered 49 bugs, including in popular Android apps, and (ii) efficient, completing on average in 61 seconds per app. More generally, our approach helps determine whether an app saves too much or too little state.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
Low-overhead and fully automated statistical debugging with abstraction refinement
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Cooperative statistical debugging is an effective approach for diagnosing production-run failures. To quickly identify failure predictors from the huge program predicate space, existing techniques rely on random or heuristics-guided predicate sampling at the user side. However, none of them can satisfy the requirements of low cost, low diagnosis latency, and high diagnosis quality simultaneously, which are all indispensable for statistical debugging to be practical.   This paper presents a new technique that tackles the above challenges. We formulate the technique as an instance of abstraction refinement, where efficient abstract-level profiling is first applied to the whole program and its execution brings information that can pinpoint suspicious coarse-grained entities that need to be refined. The refinement profiles a corresponding set of fine-grained entities, and generates feedback that determines what to prune and what to refine next. The process is fully automated, and more importantly, guided by a mathematically rigorous analysis that guarantees that our approach produces the same debugging results as an exhaustive analysis in deterministic settings.   We have implemented this technique for both C and Java on both single machine and distributed system. A thorough evaluation demonstrates that our approach yields (1) an order of magnitude reduction in the user-side runtime overhead even compared to a sampling-based approach and (2) two orders of magnitude reduction in the size of data transferred over the network, completely automatically without sacrificing any debugging capability.
[Software defect analysis, Cross-computing tools and techniques, Software creation and management, Software functional properties, Software verification and validation, Verification, Software verification, Program verification, Theory of computation, Software development process management, Semantics and reasoning, Software testing and debugging, Program reasoning, Formal software verification, Formal methods, General and reference, Software organization and properties, Software and its engineering]
To be precise: regression aware debugging
Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
ACM SIGPLAN Notices VOLUME 51 ISSUE 10
2016
Bounded model checking based debugging solutions search for mutations of program expressions that produce the expected output for a currently failing test. However, the current localization tools are not regression aware: they do not use information from the passing tests in their localization formula. On the other hand, the current repair tools attempt to guarantee regression freedom: when provided with a set of passing tests, they guarantee that none of these tests can break due to the suggested repair patch, thereby constructing a large repair formula.   In this paper, we propose regression awareness as a means to improve the quality of localization and to scale repair. To enable regression awareness, we summarize the proof of correctness of each passing test by computing Craig Interpolants over a symbolic encoding of the passing execution, and use these summaries as additional soft constraints while synthesizing altered executions corresponding to failing tests. Intuitively, these additional constraints act as roadblocks, thereby discouraging executions that may damage the proof of a passing test. We use a partial MAXSAT solver to relax the proofs in a systematic way, and use a ranking function that penalizes mutations that damage the existing proofs.   We have implemented our algorithms into a tool, TINTIN, that enables regression aware localization and repair. For localizations, our strategy is effective in extracting a superior ranking of suspicious locations: on a set of 52 different versions across 12 different programs spanning three benchmark suites, TINTIN achieves a saving of developer effort by almost 45% (in terms of the locations that must be examined by a developer to reach the ground-truth repair) in the worst case and 27% in the average case over existing techniques. For automated repairs, on our set of benchmarks, TINTIN achieves a 2.3X speedup over existing techniques without sacrificing much on the ranking of the repair patches: the ground-truth repair appears as the topmost suggestion in more than 70% of our benchmarks.
[Software defect analysis, Theory of computation, Software creation and management, Software testing and debugging, Semantics and reasoning, Software verification and validation, Program reasoning, Logic, Software and its engineering]
How to make tasks faster: revealing the complex interactions of tasks in the memory system
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
New programming models have been introduced to aid the programmer dealing with the complexity of large-scale systems, simplifying the coding process and making applications more scalable regardless. Task-based programming is one example that became popular recently. At the same time, understanding performance of multicore systems is crucial for getting faster execution times and to optimize efficiency, but it is becoming harder due to the increased complexity of hardware architectures, and the interplay between the scheduling of tasks and caches. In this work, we develop models to understand how scheduling affects the performance of tasks due to memory behavior in the task-based context, and for that, we study cache sharing both in temporal and spatial ways. In temporal cache sharing, the effect of data reused over time by the tasks executed is modeled to predict different scenarios resulting in a tool called StatTask. In spatial cache sharing, the effect of tasks fighting for the cache at a given point in time through their execution is quantified and used to model their behavior on arbitrary cache sizes. We also present a new methodology called TaskInsight that can explain performance differences across different schedules for the same application. Finally, we explain how these methods set up a unique and solid platform to reveal insight into how to improve the performance of the execution of large-scale task-based applications.
[Modeling and simulation, Computing methodologies, Parallel computing methodologies, Parallel programming languages, Model development and analysis, Modeling methodologies]
Genetic improvement in code interpreters and compilers
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
Modern compilers provide code optimizations before and during run-time, thus moving required domain knowledge about the compilation process away from the developer and speeding up resulting software. These optimizations are often based on formal proof, or alternatively have recovery paths as backup. Genetic improvement (GI), a field of science utilizing genetic programming, a stochastic optimization technique, has been previously utilized to fix bugs in software and improve non-functional software requirements.   This work proposes to research the applicability of GI in an offline phase directly at the interpreter or compiler level. The primary goal is to reformulate existing source code in such a way that existing optimizations can be applied in order to increase performance even further and requiring even less domain knowledge from the developer about a programming language and/or compiler. From these reformulations, patterns can be identified that allow code restructuring without the overhead GI poses.
[Software creation and management, Software evolution, Software post-development issues, Software and its engineering, Search-based software engineering]
Simulation-based code duplication for enhancing compiler optimizations
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
The scope of compiler optimizations is often limited by control flow, which prohibits optimizations across basic block boundaries. Code duplication can solve this problem by extending basic block sizes, thus enabling subsequent optimizations. However, duplicating code for every optimization opportunity may lead to excessive code growth. Therefore, a holistic approach is required that is capable of finding optimization opportunities and classifying their impact.   This paper presents a novel approach to determine which code should be duplicated in order to improve peak performance. The approach analyzes duplication candidates for subsequent optimizations opportunities. It does so by simulating a duplication and analyzing its impact on other optimizations. This allows a compiler to weight up multiple success metrics in order to choose those duplications with the maximum optimization potential. We further show how to map code duplication opportunities to an optimization cost model that allows us to maximize performance while minimizing code size increase.
[Just-in-time compilers, Dynamic compilers, Software infrastructure, Software notations and tools, Virtual machines, Contextual software domains, Software organization and properties, Software and its engineering, Compilers]
Advanced debugging techniques to identify concurrency bugs in actor-based programs
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
Actor-based programs are not exempt from concurrency bugs. Inspiring contributions for debugging actor-based programs have been developed, however there is no approach that reliably identifies the root cause of complex concurrency bugs. Solving this problem can result in a reduction of the debugging time that programmers spend when developing concurrent applications. I propose a debugging approach based on the combination of offline debugging techniques that aim to help developers in the process of finding the root cause of concurrency bugs. I plan to evaluate this proposal through user studies and performance evaluation.
[Software defect analysis, Software creation and management, Software testing and debugging, General programming languages, Software verification and validation, Language types, Software notations and tools, Concurrent programming languages, Software and its engineering]
Framework support for usability evaluation of domain-specific languages
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
In this paper we propose a conceptual framework that supports the iterative development process of DSLs concerning the issue of their Usability evaluation. A multiple-case studies were conducted in order validate the proposed method.
[Software usability, Context specific languages, Extra-functional properties, Software notations and tools, Software organization and properties, Software and its engineering, Domain specific languages]
What merge tool should I use?
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
While unstructured merge tools try to automatically resolve merge conflicts via textual similarity, semistructured and structured merge tools try to go further by exploiting the syntactic structure and semantics of the involved artefacts. Previous studies compare these merge approaches with respect to the number of reported conflicts, showing, for most projects and merge situations, a reduction in favor of semistructured and structured merge. However, these studies do not investigate whether this reduction actually leads to integration effort reduction (Productivity) without negative impact on the correctness of the merging process (Quality). To analyze this, and to better understand how these tools could be improved, we propose empirical studies to identify spurious conflicts (false positives) reported by one approach but not by the other, and interference reported as conflict by one approach but missed by the other (false negatives).
[Software configuration management and version control systems, Cross-computing tools and techniques, Empirical studies, Software notations and tools, General and reference, Software and its engineering]
Understanding the interplay between task scheduling, memory and performance
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
New programming models have been introduced to aid the programmer dealing with the complexity of large-scale systems, simplifying the coding process and making applications more scalable. Task-based programming is one example that became popular recently. At the same time, understanding performance of multicore systems is key for getting faster execution times and optimize workloads, but it is becoming harder due to the increased complexity of hardware and the runtime systems. To address this, we present TaskInsight, a technique to characterize the memory behavior of different task schedulers through the analysis of data reuse. TaskInsight provides high-level information that can be correlated with tasks&#226; performance variation over time to understand data reuse through the caches due to scheduling choices. This allows to identify <em>which</em> scheduling decisions affected performance, <em>when</em> were they taken, and <em>why</em> the performance changed, both in single and multi-threaded executions. We demonstrate how TaskInsight can diagnose cases where poor scheduling caused over 60% difference on average (and up to 7x slowdowns) due to changes in the tasks&#226; data reuse through the caches.
[Modeling and simulation, Computing methodologies, Parallel computing methodologies, Parallel programming languages, Model development and analysis, Modeling methodologies]
Automatic testing of interactive JavaScript debuggers
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
When debugging programs, we often assume the debugger itself is correct. However, when it is not, it becomes hard to find bugs or lets developers search for bugs that are not even present. We thus propose a new approach to automatic testing of debuggers, inspired by differential testing of compilers. Our approach generates debugger actions to exercise the debugger and records a trace during the debugging session. By comparing traces of different debuggers against each other, we find deviating behavior and bugs. We evaluate our approach on the JavaScript debuggers of Firefox and Chromium and find 16 previously unreported bugs, four of which are already confirmed and fixed.
[Software defect analysis, Software creation and management, Software testing and debugging, Software verification and validation, Software notations and tools, Software maintenance tools, Software and its engineering]
Computer-assisted specification of asynchronous interfaces with non-deterministic behavior
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
The Android Framework is designed around components with <em>asynchronous interfaces</em>, in which inputs and outputs are not directly coupled. Precisely specifying behavior of this sort is a slow, error-prone process, and thus documentation and testing for such components is usually incomplete. I have participated over the last year in a collaborative research project seeking to solve this problem by automating the generation and verification of these specifications via active learning on a live Android system. Part of my work has been the extension of our automation technique to Android Framework components with <em>non-deterministic</em> behavior that prevents direct application of active learning algorithms. To this end, I have applied our learning engine in the form of a <em>specification assistant</em> which mixes automation and manual guidance to learn non-deterministic interfaces with as little user intervention as possible.
[Theory of computation, Software creation and management, Software verification and validation, Documentation, Context specific languages, Software notations and tools, Software post-development issues, Interface definition languages, Formal languages and automata theory, Software and its engineering]
Verifying the proxy design pattern using object propositions
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
In this extended abstract we explore the expressiveness and modularity of our recently published object propositions methodology by applying it to verify properties about programs that use the proxy design pattern. Our instance of the proxy pattern implements a general proxy-real object system that is routinely used in industry and the verification of which is challenging.
[Software creation and management, Software verification and validation, Formal software verification, Software and its engineering]
ZenSheet studio: a spreadsheet-inspired environment for reactive computing
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
Widely criticized as error-prone, causing millions of dollars in losses, spreadsheets continue to be extremely popular, decades after their introduction. The ZenSheet project aims to turn spreadsheets into modern and robust computing environments, with minimal impact on the learning curve. This paper focuses on ZenSheet Studio: a web client that delivers a generalized spreadsheet computing experience.
[Integrated and visual development environments, Human-centered computing, Software notations and tools, Human computer interaction (HCI), Interaction paradigms, Development frameworks and environments, Software and its engineering, Graphical user interfaces]
How to efficiently process 2 100 list variations
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
Variational execution offers an avenue of efficiently analyzing configurable systems, but data structures like lists require special consideration. We implement automatic substitution of a more efficient list representation in a variational execution framework and evaluate its performance in micro-benchmarks. The results suggest that the substitution may offer substantial performance improvements to programs involving highly variational lists.
[Software configuration management and version control systems, Software notations and tools, Extra-functional properties, Software reliability, Software organization and properties, Software and its engineering]
How are programming questions from women received on stack overflow? a case study of peer parity
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
Stack Overflow is a useful Q&A online community for programmers. However, it has not been as popular among programmers who are women. Prior studies have shown low participation of women programmers on Stack Overflow, but have not demonstrated how the presence of their peers may promote activity. In this work, we understand how the presence of women, through peer parity, can encourage women to participate more on Stack Overflow. We extracted 3,2209,817 posts from the most recent Stack Overflow data dump. By modifying a popular gender computing tool, we took the first names of online users and identified the gender of 2,502,438 users from the 5,987,284 list of current users. We randomly selected peer parity and non peer parity questions asked by women and identify differences in participation on those posts. We found that women become more active after they have taken part in a peer parity post. With further analysis of peer parity through eye tracking and tone detection tools we can determine ways to foster a more welcoming community that would encourage women to participate.
[Women, Software creation and management, Collaboration in software development, Human-centered computing, Gender, Human computer interaction (HCI), Social and professional topics, User characteristics, Software and its engineering, Empirical studies in HCI]
Devirtualization in LLVM
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
Devirtualization is an optimization changing indirect (virtual) calls to direct calls. It improves performance by allowing extra inlining and removal of redundant loads. This paper presents a novel way of handling C++ devirtualization in LLVM by unifying virtual table loads across calls using different SSA values to represent different dynamic types.
[Source code generation, General programming languages, Language features, Software notations and tools, Software and its engineering, Compilers, Polymorphism]
Principles, patterns, and techniques for designing and implementing practical fluent interfaces in Java
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
In this research, the author sought a meta-theory that establishes essential concepts and fundamental techniques in helping programmers design and implement practical fluent interfaces in the Java language. An anatomy of the conceptual establishment of fluent interfaces is established and presented. Six <em>primitives</em>, roles that a key method could play are also identified. The author also coined the term <em>transition choreography</em> and attributed it as the core of the design theory for practical fluent interfaces in Java. Results in this research may apply as well in languages other than Java.
[Software creation and management, Context specific languages, Software notations and tools, Software development techniques, Software and its engineering, Domain specific languages]
Abstracting resource effects
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
In developing secure programs, reasoning about effects on resources can be hindered by obscure changes in program state. Effect systems mitigate this difficulty by describing these changes, but may require large amounts of low-level effect annotations, and create obstacles for reasoning. To reduce overhead, we propose an effect system, with a focus on system resources, that supports effect abstraction. It is being implemented in Wyvern, a capability-safe language.
[General programming languages, Language features, Software notations and tools, Software and its engineering]
SmartJS: dynamic and self-adaptable runtime middleware for next-generation IoT systems
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
The Internet of Things (IoT) has gained wide popularity both in the academic and industrial contexts. However, IoT-based systems exhibit many important challenges across many dimensions. In this work, we propose <em>SmartJS</em>, a rich Javascript-based middleware platform and runtime environment that abstracts the complexity of the various IoT platforms by providing a high-level framework for IoT system developers. SmartJS abstracts large-scale distributed system considerations, such as scheduling, monitoring and self-adaptation, and proposes a rich inter-device Javascript-based code migration framework. Finally, it provides debugging and monitoring techniques to analyze performance and observe system-wide security properties.
[Software notations and tools, Runtime environments, Development frameworks and environments, System description languages, Software and its engineering, Compilers]
Incremental parametric syntax for multi-language transformation
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
We present a new approach for building source-to-source transformations that can run on multiple programming languages, based on a new way of representing programs called incremental parametric syntax. We implement this approach in our Cubix system, and construct incremental parametric syntaxes for C, Java, JavaScript, Lua, and Python, demonstrating three multi-language program transformations that can run on all of them. Our evaluation shows that (1) once a transformation is written, relatively little work is required to configure it for a new language (2) transformations built this way output readable code which preserve the structure of the original, according to participants in our human study, and (3) despite dealing with many languages, our transformations can still handle language corner-cases, and pass 90% of compiler test suites.
[Translator writing systems and compiler generators, Software notations and tools, Formal language definitions, Syntax, Software and its engineering, Compilers]
QuixBugs: a multi-lingual program repair benchmark set based on the quixey challenge
Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity
None
2017
Recent years have seen an explosion of work in automated program repair. While previous work has focused exclusively on tools for single languages, recent work in multi-language transformation has opened the door for multi-language program repair tools. Evaluating the performance of such a tool requires having a benchmark set of similar buggy programs in different languages. We present QuixBugs, consisting of 40 programs translated to both Python and Java, each with a bug on a single line. The QuixBugs benchmark suite is based on problems from the Quixey Challenge, where programmers were given a short buggy program and 1 minute to fix the bug.
[Software notations and tools, Software maintenance tools, Software and its engineering]
